
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model users
 * ///////////////////
 * ///////////////////
 */
export type users = $Result.DefaultSelection<Prisma.$usersPayload>
/**
 * Model Mitra
 * ///////////////////
 * ///////////////////
 */
export type Mitra = $Result.DefaultSelection<Prisma.$MitraPayload>
/**
 * Model otp_codes
 * ////////////////
 * ////////////////
 */
export type otp_codes = $Result.DefaultSelection<Prisma.$otp_codesPayload>
/**
 * Model Lapangan
 * ///////////////////
 * ///////////////////
 */
export type Lapangan = $Result.DefaultSelection<Prisma.$LapanganPayload>
/**
 * Model LapanganDetail
 * 
 */
export type LapanganDetail = $Result.DefaultSelection<Prisma.$LapanganDetailPayload>
/**
 * Model LapanganGambar
 * 
 */
export type LapanganGambar = $Result.DefaultSelection<Prisma.$LapanganGambarPayload>
/**
 * Model JadwalLapangan
 * 
 */
export type JadwalLapangan = $Result.DefaultSelection<Prisma.$JadwalLapanganPayload>
/**
 * Model order_booking
 * ///////////////////
 * ///////////////////
 */
export type order_booking = $Result.DefaultSelection<Prisma.$order_bookingPayload>
/**
 * Model transaksi
 * ///////////////////
 * ///////////////////
 */
export type transaksi = $Result.DefaultSelection<Prisma.$transaksiPayload>
/**
 * Model raket_padel
 * ///////////////////
 * ///////////////////
 */
export type raket_padel = $Result.DefaultSelection<Prisma.$raket_padelPayload>
/**
 * Model sewa_raket
 * 
 */
export type sewa_raket = $Result.DefaultSelection<Prisma.$sewa_raketPayload>
/**
 * Model wallet_user
 * ///////////////////
 * ///////////////////
 */
export type wallet_user = $Result.DefaultSelection<Prisma.$wallet_userPayload>
/**
 * Model wallet_history
 * 
 */
export type wallet_history = $Result.DefaultSelection<Prisma.$wallet_historyPayload>
/**
 * Model refund
 * ///////////////////
 * ///////////////////
 */
export type refund = $Result.DefaultSelection<Prisma.$refundPayload>
/**
 * Model notifikasi
 * ///////////////////
 * ///////////////////
 */
export type notifikasi = $Result.DefaultSelection<Prisma.$notifikasiPayload>
/**
 * Model ulasan
 * ///////////////////
 * ///////////////////
 */
export type ulasan = $Result.DefaultSelection<Prisma.$ulasanPayload>
/**
 * Model pendapatan_mitra
 * ///////////////////
 * ///////////////////
 */
export type pendapatan_mitra = $Result.DefaultSelection<Prisma.$pendapatan_mitraPayload>
/**
 * Model pencairan_pendapatan
 * 
 */
export type pencairan_pendapatan = $Result.DefaultSelection<Prisma.$pencairan_pendapatanPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const users_role: {
  admin: 'admin',
  user: 'user',
  mitra: 'mitra'
};

export type users_role = (typeof users_role)[keyof typeof users_role]


export const users_status: {
  aktif: 'aktif',
  nonaktif: 'nonaktif'
};

export type users_status = (typeof users_status)[keyof typeof users_status]


export const mitra_status: {
  pending: 'pending',
  aktif: 'aktif',
  ditolak: 'ditolak'
};

export type mitra_status = (typeof mitra_status)[keyof typeof mitra_status]


export const lapangan_status: {
  tersedia: 'tersedia',
  dalam_perbaikan: 'dalam_perbaikan'
};

export type lapangan_status = (typeof lapangan_status)[keyof typeof lapangan_status]


export const jadwal_status: {
  tersedia: 'tersedia',
  dikunci: 'dikunci',
  booked: 'booked'
};

export type jadwal_status = (typeof jadwal_status)[keyof typeof jadwal_status]


export const transaksi_status_pembayaran: {
  pending: 'pending',
  berhasil: 'berhasil',
  gagal: 'gagal',
  refund: 'refund'
};

export type transaksi_status_pembayaran = (typeof transaksi_status_pembayaran)[keyof typeof transaksi_status_pembayaran]


export const wallet_tipe: {
  booking: 'booking',
  refund: 'refund',
  topup: 'topup'
};

export type wallet_tipe = (typeof wallet_tipe)[keyof typeof wallet_tipe]


export const refund_status: {
  pending: 'pending',
  approved: 'approved',
  rejected: 'rejected',
  selesai: 'selesai'
};

export type refund_status = (typeof refund_status)[keyof typeof refund_status]


export const pencairan_status: {
  pending: 'pending',
  diproses: 'diproses',
  berhasil: 'berhasil',
  ditolak: 'ditolak'
};

export type pencairan_status = (typeof pencairan_status)[keyof typeof pencairan_status]

}

export type users_role = $Enums.users_role

export const users_role: typeof $Enums.users_role

export type users_status = $Enums.users_status

export const users_status: typeof $Enums.users_status

export type mitra_status = $Enums.mitra_status

export const mitra_status: typeof $Enums.mitra_status

export type lapangan_status = $Enums.lapangan_status

export const lapangan_status: typeof $Enums.lapangan_status

export type jadwal_status = $Enums.jadwal_status

export const jadwal_status: typeof $Enums.jadwal_status

export type transaksi_status_pembayaran = $Enums.transaksi_status_pembayaran

export const transaksi_status_pembayaran: typeof $Enums.transaksi_status_pembayaran

export type wallet_tipe = $Enums.wallet_tipe

export const wallet_tipe: typeof $Enums.wallet_tipe

export type refund_status = $Enums.refund_status

export const refund_status: typeof $Enums.refund_status

export type pencairan_status = $Enums.pencairan_status

export const pencairan_status: typeof $Enums.pencairan_status

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.users.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.users.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.users`: Exposes CRUD operations for the **users** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.users.findMany()
    * ```
    */
  get users(): Prisma.usersDelegate<ExtArgs>;

  /**
   * `prisma.mitra`: Exposes CRUD operations for the **Mitra** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Mitras
    * const mitras = await prisma.mitra.findMany()
    * ```
    */
  get mitra(): Prisma.MitraDelegate<ExtArgs>;

  /**
   * `prisma.otp_codes`: Exposes CRUD operations for the **otp_codes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Otp_codes
    * const otp_codes = await prisma.otp_codes.findMany()
    * ```
    */
  get otp_codes(): Prisma.otp_codesDelegate<ExtArgs>;

  /**
   * `prisma.lapangan`: Exposes CRUD operations for the **Lapangan** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Lapangans
    * const lapangans = await prisma.lapangan.findMany()
    * ```
    */
  get lapangan(): Prisma.LapanganDelegate<ExtArgs>;

  /**
   * `prisma.lapanganDetail`: Exposes CRUD operations for the **LapanganDetail** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LapanganDetails
    * const lapanganDetails = await prisma.lapanganDetail.findMany()
    * ```
    */
  get lapanganDetail(): Prisma.LapanganDetailDelegate<ExtArgs>;

  /**
   * `prisma.lapanganGambar`: Exposes CRUD operations for the **LapanganGambar** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LapanganGambars
    * const lapanganGambars = await prisma.lapanganGambar.findMany()
    * ```
    */
  get lapanganGambar(): Prisma.LapanganGambarDelegate<ExtArgs>;

  /**
   * `prisma.jadwalLapangan`: Exposes CRUD operations for the **JadwalLapangan** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more JadwalLapangans
    * const jadwalLapangans = await prisma.jadwalLapangan.findMany()
    * ```
    */
  get jadwalLapangan(): Prisma.JadwalLapanganDelegate<ExtArgs>;

  /**
   * `prisma.order_booking`: Exposes CRUD operations for the **order_booking** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Order_bookings
    * const order_bookings = await prisma.order_booking.findMany()
    * ```
    */
  get order_booking(): Prisma.order_bookingDelegate<ExtArgs>;

  /**
   * `prisma.transaksi`: Exposes CRUD operations for the **transaksi** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Transaksis
    * const transaksis = await prisma.transaksi.findMany()
    * ```
    */
  get transaksi(): Prisma.transaksiDelegate<ExtArgs>;

  /**
   * `prisma.raket_padel`: Exposes CRUD operations for the **raket_padel** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Raket_padels
    * const raket_padels = await prisma.raket_padel.findMany()
    * ```
    */
  get raket_padel(): Prisma.raket_padelDelegate<ExtArgs>;

  /**
   * `prisma.sewa_raket`: Exposes CRUD operations for the **sewa_raket** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sewa_rakets
    * const sewa_rakets = await prisma.sewa_raket.findMany()
    * ```
    */
  get sewa_raket(): Prisma.sewa_raketDelegate<ExtArgs>;

  /**
   * `prisma.wallet_user`: Exposes CRUD operations for the **wallet_user** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Wallet_users
    * const wallet_users = await prisma.wallet_user.findMany()
    * ```
    */
  get wallet_user(): Prisma.wallet_userDelegate<ExtArgs>;

  /**
   * `prisma.wallet_history`: Exposes CRUD operations for the **wallet_history** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Wallet_histories
    * const wallet_histories = await prisma.wallet_history.findMany()
    * ```
    */
  get wallet_history(): Prisma.wallet_historyDelegate<ExtArgs>;

  /**
   * `prisma.refund`: Exposes CRUD operations for the **refund** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Refunds
    * const refunds = await prisma.refund.findMany()
    * ```
    */
  get refund(): Prisma.refundDelegate<ExtArgs>;

  /**
   * `prisma.notifikasi`: Exposes CRUD operations for the **notifikasi** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifikasis
    * const notifikasis = await prisma.notifikasi.findMany()
    * ```
    */
  get notifikasi(): Prisma.notifikasiDelegate<ExtArgs>;

  /**
   * `prisma.ulasan`: Exposes CRUD operations for the **ulasan** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Ulasans
    * const ulasans = await prisma.ulasan.findMany()
    * ```
    */
  get ulasan(): Prisma.ulasanDelegate<ExtArgs>;

  /**
   * `prisma.pendapatan_mitra`: Exposes CRUD operations for the **pendapatan_mitra** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Pendapatan_mitras
    * const pendapatan_mitras = await prisma.pendapatan_mitra.findMany()
    * ```
    */
  get pendapatan_mitra(): Prisma.pendapatan_mitraDelegate<ExtArgs>;

  /**
   * `prisma.pencairan_pendapatan`: Exposes CRUD operations for the **pencairan_pendapatan** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Pencairan_pendapatans
    * const pencairan_pendapatans = await prisma.pencairan_pendapatan.findMany()
    * ```
    */
  get pencairan_pendapatan(): Prisma.pencairan_pendapatanDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.21.1
   * Query Engine version: bf0e5e8a04cada8225617067eaa03d041e2bba36
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    users: 'users',
    Mitra: 'Mitra',
    otp_codes: 'otp_codes',
    Lapangan: 'Lapangan',
    LapanganDetail: 'LapanganDetail',
    LapanganGambar: 'LapanganGambar',
    JadwalLapangan: 'JadwalLapangan',
    order_booking: 'order_booking',
    transaksi: 'transaksi',
    raket_padel: 'raket_padel',
    sewa_raket: 'sewa_raket',
    wallet_user: 'wallet_user',
    wallet_history: 'wallet_history',
    refund: 'refund',
    notifikasi: 'notifikasi',
    ulasan: 'ulasan',
    pendapatan_mitra: 'pendapatan_mitra',
    pencairan_pendapatan: 'pencairan_pendapatan'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "users" | "mitra" | "otp_codes" | "lapangan" | "lapanganDetail" | "lapanganGambar" | "jadwalLapangan" | "order_booking" | "transaksi" | "raket_padel" | "sewa_raket" | "wallet_user" | "wallet_history" | "refund" | "notifikasi" | "ulasan" | "pendapatan_mitra" | "pencairan_pendapatan"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      users: {
        payload: Prisma.$usersPayload<ExtArgs>
        fields: Prisma.usersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.usersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.usersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          findFirst: {
            args: Prisma.usersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.usersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          findMany: {
            args: Prisma.usersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>[]
          }
          create: {
            args: Prisma.usersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          createMany: {
            args: Prisma.usersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.usersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          update: {
            args: Prisma.usersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          deleteMany: {
            args: Prisma.usersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.usersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.usersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          aggregate: {
            args: Prisma.UsersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUsers>
          }
          groupBy: {
            args: Prisma.usersGroupByArgs<ExtArgs>
            result: $Utils.Optional<UsersGroupByOutputType>[]
          }
          count: {
            args: Prisma.usersCountArgs<ExtArgs>
            result: $Utils.Optional<UsersCountAggregateOutputType> | number
          }
        }
      }
      Mitra: {
        payload: Prisma.$MitraPayload<ExtArgs>
        fields: Prisma.MitraFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MitraFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MitraPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MitraFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MitraPayload>
          }
          findFirst: {
            args: Prisma.MitraFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MitraPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MitraFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MitraPayload>
          }
          findMany: {
            args: Prisma.MitraFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MitraPayload>[]
          }
          create: {
            args: Prisma.MitraCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MitraPayload>
          }
          createMany: {
            args: Prisma.MitraCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.MitraDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MitraPayload>
          }
          update: {
            args: Prisma.MitraUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MitraPayload>
          }
          deleteMany: {
            args: Prisma.MitraDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MitraUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MitraUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MitraPayload>
          }
          aggregate: {
            args: Prisma.MitraAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMitra>
          }
          groupBy: {
            args: Prisma.MitraGroupByArgs<ExtArgs>
            result: $Utils.Optional<MitraGroupByOutputType>[]
          }
          count: {
            args: Prisma.MitraCountArgs<ExtArgs>
            result: $Utils.Optional<MitraCountAggregateOutputType> | number
          }
        }
      }
      otp_codes: {
        payload: Prisma.$otp_codesPayload<ExtArgs>
        fields: Prisma.otp_codesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.otp_codesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$otp_codesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.otp_codesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$otp_codesPayload>
          }
          findFirst: {
            args: Prisma.otp_codesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$otp_codesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.otp_codesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$otp_codesPayload>
          }
          findMany: {
            args: Prisma.otp_codesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$otp_codesPayload>[]
          }
          create: {
            args: Prisma.otp_codesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$otp_codesPayload>
          }
          createMany: {
            args: Prisma.otp_codesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.otp_codesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$otp_codesPayload>
          }
          update: {
            args: Prisma.otp_codesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$otp_codesPayload>
          }
          deleteMany: {
            args: Prisma.otp_codesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.otp_codesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.otp_codesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$otp_codesPayload>
          }
          aggregate: {
            args: Prisma.Otp_codesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOtp_codes>
          }
          groupBy: {
            args: Prisma.otp_codesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Otp_codesGroupByOutputType>[]
          }
          count: {
            args: Prisma.otp_codesCountArgs<ExtArgs>
            result: $Utils.Optional<Otp_codesCountAggregateOutputType> | number
          }
        }
      }
      Lapangan: {
        payload: Prisma.$LapanganPayload<ExtArgs>
        fields: Prisma.LapanganFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LapanganFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LapanganPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LapanganFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LapanganPayload>
          }
          findFirst: {
            args: Prisma.LapanganFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LapanganPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LapanganFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LapanganPayload>
          }
          findMany: {
            args: Prisma.LapanganFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LapanganPayload>[]
          }
          create: {
            args: Prisma.LapanganCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LapanganPayload>
          }
          createMany: {
            args: Prisma.LapanganCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.LapanganDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LapanganPayload>
          }
          update: {
            args: Prisma.LapanganUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LapanganPayload>
          }
          deleteMany: {
            args: Prisma.LapanganDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LapanganUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LapanganUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LapanganPayload>
          }
          aggregate: {
            args: Prisma.LapanganAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLapangan>
          }
          groupBy: {
            args: Prisma.LapanganGroupByArgs<ExtArgs>
            result: $Utils.Optional<LapanganGroupByOutputType>[]
          }
          count: {
            args: Prisma.LapanganCountArgs<ExtArgs>
            result: $Utils.Optional<LapanganCountAggregateOutputType> | number
          }
        }
      }
      LapanganDetail: {
        payload: Prisma.$LapanganDetailPayload<ExtArgs>
        fields: Prisma.LapanganDetailFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LapanganDetailFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LapanganDetailPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LapanganDetailFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LapanganDetailPayload>
          }
          findFirst: {
            args: Prisma.LapanganDetailFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LapanganDetailPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LapanganDetailFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LapanganDetailPayload>
          }
          findMany: {
            args: Prisma.LapanganDetailFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LapanganDetailPayload>[]
          }
          create: {
            args: Prisma.LapanganDetailCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LapanganDetailPayload>
          }
          createMany: {
            args: Prisma.LapanganDetailCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.LapanganDetailDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LapanganDetailPayload>
          }
          update: {
            args: Prisma.LapanganDetailUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LapanganDetailPayload>
          }
          deleteMany: {
            args: Prisma.LapanganDetailDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LapanganDetailUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LapanganDetailUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LapanganDetailPayload>
          }
          aggregate: {
            args: Prisma.LapanganDetailAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLapanganDetail>
          }
          groupBy: {
            args: Prisma.LapanganDetailGroupByArgs<ExtArgs>
            result: $Utils.Optional<LapanganDetailGroupByOutputType>[]
          }
          count: {
            args: Prisma.LapanganDetailCountArgs<ExtArgs>
            result: $Utils.Optional<LapanganDetailCountAggregateOutputType> | number
          }
        }
      }
      LapanganGambar: {
        payload: Prisma.$LapanganGambarPayload<ExtArgs>
        fields: Prisma.LapanganGambarFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LapanganGambarFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LapanganGambarPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LapanganGambarFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LapanganGambarPayload>
          }
          findFirst: {
            args: Prisma.LapanganGambarFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LapanganGambarPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LapanganGambarFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LapanganGambarPayload>
          }
          findMany: {
            args: Prisma.LapanganGambarFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LapanganGambarPayload>[]
          }
          create: {
            args: Prisma.LapanganGambarCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LapanganGambarPayload>
          }
          createMany: {
            args: Prisma.LapanganGambarCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.LapanganGambarDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LapanganGambarPayload>
          }
          update: {
            args: Prisma.LapanganGambarUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LapanganGambarPayload>
          }
          deleteMany: {
            args: Prisma.LapanganGambarDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LapanganGambarUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LapanganGambarUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LapanganGambarPayload>
          }
          aggregate: {
            args: Prisma.LapanganGambarAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLapanganGambar>
          }
          groupBy: {
            args: Prisma.LapanganGambarGroupByArgs<ExtArgs>
            result: $Utils.Optional<LapanganGambarGroupByOutputType>[]
          }
          count: {
            args: Prisma.LapanganGambarCountArgs<ExtArgs>
            result: $Utils.Optional<LapanganGambarCountAggregateOutputType> | number
          }
        }
      }
      JadwalLapangan: {
        payload: Prisma.$JadwalLapanganPayload<ExtArgs>
        fields: Prisma.JadwalLapanganFieldRefs
        operations: {
          findUnique: {
            args: Prisma.JadwalLapanganFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JadwalLapanganPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.JadwalLapanganFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JadwalLapanganPayload>
          }
          findFirst: {
            args: Prisma.JadwalLapanganFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JadwalLapanganPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.JadwalLapanganFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JadwalLapanganPayload>
          }
          findMany: {
            args: Prisma.JadwalLapanganFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JadwalLapanganPayload>[]
          }
          create: {
            args: Prisma.JadwalLapanganCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JadwalLapanganPayload>
          }
          createMany: {
            args: Prisma.JadwalLapanganCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.JadwalLapanganDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JadwalLapanganPayload>
          }
          update: {
            args: Prisma.JadwalLapanganUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JadwalLapanganPayload>
          }
          deleteMany: {
            args: Prisma.JadwalLapanganDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.JadwalLapanganUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.JadwalLapanganUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JadwalLapanganPayload>
          }
          aggregate: {
            args: Prisma.JadwalLapanganAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateJadwalLapangan>
          }
          groupBy: {
            args: Prisma.JadwalLapanganGroupByArgs<ExtArgs>
            result: $Utils.Optional<JadwalLapanganGroupByOutputType>[]
          }
          count: {
            args: Prisma.JadwalLapanganCountArgs<ExtArgs>
            result: $Utils.Optional<JadwalLapanganCountAggregateOutputType> | number
          }
        }
      }
      order_booking: {
        payload: Prisma.$order_bookingPayload<ExtArgs>
        fields: Prisma.order_bookingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.order_bookingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$order_bookingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.order_bookingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$order_bookingPayload>
          }
          findFirst: {
            args: Prisma.order_bookingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$order_bookingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.order_bookingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$order_bookingPayload>
          }
          findMany: {
            args: Prisma.order_bookingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$order_bookingPayload>[]
          }
          create: {
            args: Prisma.order_bookingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$order_bookingPayload>
          }
          createMany: {
            args: Prisma.order_bookingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.order_bookingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$order_bookingPayload>
          }
          update: {
            args: Prisma.order_bookingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$order_bookingPayload>
          }
          deleteMany: {
            args: Prisma.order_bookingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.order_bookingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.order_bookingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$order_bookingPayload>
          }
          aggregate: {
            args: Prisma.Order_bookingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrder_booking>
          }
          groupBy: {
            args: Prisma.order_bookingGroupByArgs<ExtArgs>
            result: $Utils.Optional<Order_bookingGroupByOutputType>[]
          }
          count: {
            args: Prisma.order_bookingCountArgs<ExtArgs>
            result: $Utils.Optional<Order_bookingCountAggregateOutputType> | number
          }
        }
      }
      transaksi: {
        payload: Prisma.$transaksiPayload<ExtArgs>
        fields: Prisma.transaksiFieldRefs
        operations: {
          findUnique: {
            args: Prisma.transaksiFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transaksiPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.transaksiFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transaksiPayload>
          }
          findFirst: {
            args: Prisma.transaksiFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transaksiPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.transaksiFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transaksiPayload>
          }
          findMany: {
            args: Prisma.transaksiFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transaksiPayload>[]
          }
          create: {
            args: Prisma.transaksiCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transaksiPayload>
          }
          createMany: {
            args: Prisma.transaksiCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.transaksiDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transaksiPayload>
          }
          update: {
            args: Prisma.transaksiUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transaksiPayload>
          }
          deleteMany: {
            args: Prisma.transaksiDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.transaksiUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.transaksiUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transaksiPayload>
          }
          aggregate: {
            args: Prisma.TransaksiAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTransaksi>
          }
          groupBy: {
            args: Prisma.transaksiGroupByArgs<ExtArgs>
            result: $Utils.Optional<TransaksiGroupByOutputType>[]
          }
          count: {
            args: Prisma.transaksiCountArgs<ExtArgs>
            result: $Utils.Optional<TransaksiCountAggregateOutputType> | number
          }
        }
      }
      raket_padel: {
        payload: Prisma.$raket_padelPayload<ExtArgs>
        fields: Prisma.raket_padelFieldRefs
        operations: {
          findUnique: {
            args: Prisma.raket_padelFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$raket_padelPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.raket_padelFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$raket_padelPayload>
          }
          findFirst: {
            args: Prisma.raket_padelFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$raket_padelPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.raket_padelFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$raket_padelPayload>
          }
          findMany: {
            args: Prisma.raket_padelFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$raket_padelPayload>[]
          }
          create: {
            args: Prisma.raket_padelCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$raket_padelPayload>
          }
          createMany: {
            args: Prisma.raket_padelCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.raket_padelDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$raket_padelPayload>
          }
          update: {
            args: Prisma.raket_padelUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$raket_padelPayload>
          }
          deleteMany: {
            args: Prisma.raket_padelDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.raket_padelUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.raket_padelUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$raket_padelPayload>
          }
          aggregate: {
            args: Prisma.Raket_padelAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRaket_padel>
          }
          groupBy: {
            args: Prisma.raket_padelGroupByArgs<ExtArgs>
            result: $Utils.Optional<Raket_padelGroupByOutputType>[]
          }
          count: {
            args: Prisma.raket_padelCountArgs<ExtArgs>
            result: $Utils.Optional<Raket_padelCountAggregateOutputType> | number
          }
        }
      }
      sewa_raket: {
        payload: Prisma.$sewa_raketPayload<ExtArgs>
        fields: Prisma.sewa_raketFieldRefs
        operations: {
          findUnique: {
            args: Prisma.sewa_raketFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sewa_raketPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.sewa_raketFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sewa_raketPayload>
          }
          findFirst: {
            args: Prisma.sewa_raketFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sewa_raketPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.sewa_raketFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sewa_raketPayload>
          }
          findMany: {
            args: Prisma.sewa_raketFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sewa_raketPayload>[]
          }
          create: {
            args: Prisma.sewa_raketCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sewa_raketPayload>
          }
          createMany: {
            args: Prisma.sewa_raketCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.sewa_raketDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sewa_raketPayload>
          }
          update: {
            args: Prisma.sewa_raketUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sewa_raketPayload>
          }
          deleteMany: {
            args: Prisma.sewa_raketDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.sewa_raketUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.sewa_raketUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sewa_raketPayload>
          }
          aggregate: {
            args: Prisma.Sewa_raketAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSewa_raket>
          }
          groupBy: {
            args: Prisma.sewa_raketGroupByArgs<ExtArgs>
            result: $Utils.Optional<Sewa_raketGroupByOutputType>[]
          }
          count: {
            args: Prisma.sewa_raketCountArgs<ExtArgs>
            result: $Utils.Optional<Sewa_raketCountAggregateOutputType> | number
          }
        }
      }
      wallet_user: {
        payload: Prisma.$wallet_userPayload<ExtArgs>
        fields: Prisma.wallet_userFieldRefs
        operations: {
          findUnique: {
            args: Prisma.wallet_userFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$wallet_userPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.wallet_userFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$wallet_userPayload>
          }
          findFirst: {
            args: Prisma.wallet_userFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$wallet_userPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.wallet_userFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$wallet_userPayload>
          }
          findMany: {
            args: Prisma.wallet_userFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$wallet_userPayload>[]
          }
          create: {
            args: Prisma.wallet_userCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$wallet_userPayload>
          }
          createMany: {
            args: Prisma.wallet_userCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.wallet_userDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$wallet_userPayload>
          }
          update: {
            args: Prisma.wallet_userUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$wallet_userPayload>
          }
          deleteMany: {
            args: Prisma.wallet_userDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.wallet_userUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.wallet_userUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$wallet_userPayload>
          }
          aggregate: {
            args: Prisma.Wallet_userAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWallet_user>
          }
          groupBy: {
            args: Prisma.wallet_userGroupByArgs<ExtArgs>
            result: $Utils.Optional<Wallet_userGroupByOutputType>[]
          }
          count: {
            args: Prisma.wallet_userCountArgs<ExtArgs>
            result: $Utils.Optional<Wallet_userCountAggregateOutputType> | number
          }
        }
      }
      wallet_history: {
        payload: Prisma.$wallet_historyPayload<ExtArgs>
        fields: Prisma.wallet_historyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.wallet_historyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$wallet_historyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.wallet_historyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$wallet_historyPayload>
          }
          findFirst: {
            args: Prisma.wallet_historyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$wallet_historyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.wallet_historyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$wallet_historyPayload>
          }
          findMany: {
            args: Prisma.wallet_historyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$wallet_historyPayload>[]
          }
          create: {
            args: Prisma.wallet_historyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$wallet_historyPayload>
          }
          createMany: {
            args: Prisma.wallet_historyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.wallet_historyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$wallet_historyPayload>
          }
          update: {
            args: Prisma.wallet_historyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$wallet_historyPayload>
          }
          deleteMany: {
            args: Prisma.wallet_historyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.wallet_historyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.wallet_historyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$wallet_historyPayload>
          }
          aggregate: {
            args: Prisma.Wallet_historyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWallet_history>
          }
          groupBy: {
            args: Prisma.wallet_historyGroupByArgs<ExtArgs>
            result: $Utils.Optional<Wallet_historyGroupByOutputType>[]
          }
          count: {
            args: Prisma.wallet_historyCountArgs<ExtArgs>
            result: $Utils.Optional<Wallet_historyCountAggregateOutputType> | number
          }
        }
      }
      refund: {
        payload: Prisma.$refundPayload<ExtArgs>
        fields: Prisma.refundFieldRefs
        operations: {
          findUnique: {
            args: Prisma.refundFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$refundPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.refundFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$refundPayload>
          }
          findFirst: {
            args: Prisma.refundFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$refundPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.refundFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$refundPayload>
          }
          findMany: {
            args: Prisma.refundFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$refundPayload>[]
          }
          create: {
            args: Prisma.refundCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$refundPayload>
          }
          createMany: {
            args: Prisma.refundCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.refundDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$refundPayload>
          }
          update: {
            args: Prisma.refundUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$refundPayload>
          }
          deleteMany: {
            args: Prisma.refundDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.refundUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.refundUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$refundPayload>
          }
          aggregate: {
            args: Prisma.RefundAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRefund>
          }
          groupBy: {
            args: Prisma.refundGroupByArgs<ExtArgs>
            result: $Utils.Optional<RefundGroupByOutputType>[]
          }
          count: {
            args: Prisma.refundCountArgs<ExtArgs>
            result: $Utils.Optional<RefundCountAggregateOutputType> | number
          }
        }
      }
      notifikasi: {
        payload: Prisma.$notifikasiPayload<ExtArgs>
        fields: Prisma.notifikasiFieldRefs
        operations: {
          findUnique: {
            args: Prisma.notifikasiFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notifikasiPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.notifikasiFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notifikasiPayload>
          }
          findFirst: {
            args: Prisma.notifikasiFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notifikasiPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.notifikasiFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notifikasiPayload>
          }
          findMany: {
            args: Prisma.notifikasiFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notifikasiPayload>[]
          }
          create: {
            args: Prisma.notifikasiCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notifikasiPayload>
          }
          createMany: {
            args: Prisma.notifikasiCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.notifikasiDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notifikasiPayload>
          }
          update: {
            args: Prisma.notifikasiUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notifikasiPayload>
          }
          deleteMany: {
            args: Prisma.notifikasiDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.notifikasiUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.notifikasiUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notifikasiPayload>
          }
          aggregate: {
            args: Prisma.NotifikasiAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotifikasi>
          }
          groupBy: {
            args: Prisma.notifikasiGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotifikasiGroupByOutputType>[]
          }
          count: {
            args: Prisma.notifikasiCountArgs<ExtArgs>
            result: $Utils.Optional<NotifikasiCountAggregateOutputType> | number
          }
        }
      }
      ulasan: {
        payload: Prisma.$ulasanPayload<ExtArgs>
        fields: Prisma.ulasanFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ulasanFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ulasanPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ulasanFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ulasanPayload>
          }
          findFirst: {
            args: Prisma.ulasanFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ulasanPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ulasanFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ulasanPayload>
          }
          findMany: {
            args: Prisma.ulasanFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ulasanPayload>[]
          }
          create: {
            args: Prisma.ulasanCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ulasanPayload>
          }
          createMany: {
            args: Prisma.ulasanCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ulasanDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ulasanPayload>
          }
          update: {
            args: Prisma.ulasanUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ulasanPayload>
          }
          deleteMany: {
            args: Prisma.ulasanDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ulasanUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ulasanUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ulasanPayload>
          }
          aggregate: {
            args: Prisma.UlasanAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUlasan>
          }
          groupBy: {
            args: Prisma.ulasanGroupByArgs<ExtArgs>
            result: $Utils.Optional<UlasanGroupByOutputType>[]
          }
          count: {
            args: Prisma.ulasanCountArgs<ExtArgs>
            result: $Utils.Optional<UlasanCountAggregateOutputType> | number
          }
        }
      }
      pendapatan_mitra: {
        payload: Prisma.$pendapatan_mitraPayload<ExtArgs>
        fields: Prisma.pendapatan_mitraFieldRefs
        operations: {
          findUnique: {
            args: Prisma.pendapatan_mitraFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pendapatan_mitraPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.pendapatan_mitraFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pendapatan_mitraPayload>
          }
          findFirst: {
            args: Prisma.pendapatan_mitraFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pendapatan_mitraPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.pendapatan_mitraFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pendapatan_mitraPayload>
          }
          findMany: {
            args: Prisma.pendapatan_mitraFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pendapatan_mitraPayload>[]
          }
          create: {
            args: Prisma.pendapatan_mitraCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pendapatan_mitraPayload>
          }
          createMany: {
            args: Prisma.pendapatan_mitraCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.pendapatan_mitraDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pendapatan_mitraPayload>
          }
          update: {
            args: Prisma.pendapatan_mitraUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pendapatan_mitraPayload>
          }
          deleteMany: {
            args: Prisma.pendapatan_mitraDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.pendapatan_mitraUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.pendapatan_mitraUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pendapatan_mitraPayload>
          }
          aggregate: {
            args: Prisma.Pendapatan_mitraAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePendapatan_mitra>
          }
          groupBy: {
            args: Prisma.pendapatan_mitraGroupByArgs<ExtArgs>
            result: $Utils.Optional<Pendapatan_mitraGroupByOutputType>[]
          }
          count: {
            args: Prisma.pendapatan_mitraCountArgs<ExtArgs>
            result: $Utils.Optional<Pendapatan_mitraCountAggregateOutputType> | number
          }
        }
      }
      pencairan_pendapatan: {
        payload: Prisma.$pencairan_pendapatanPayload<ExtArgs>
        fields: Prisma.pencairan_pendapatanFieldRefs
        operations: {
          findUnique: {
            args: Prisma.pencairan_pendapatanFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pencairan_pendapatanPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.pencairan_pendapatanFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pencairan_pendapatanPayload>
          }
          findFirst: {
            args: Prisma.pencairan_pendapatanFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pencairan_pendapatanPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.pencairan_pendapatanFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pencairan_pendapatanPayload>
          }
          findMany: {
            args: Prisma.pencairan_pendapatanFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pencairan_pendapatanPayload>[]
          }
          create: {
            args: Prisma.pencairan_pendapatanCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pencairan_pendapatanPayload>
          }
          createMany: {
            args: Prisma.pencairan_pendapatanCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.pencairan_pendapatanDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pencairan_pendapatanPayload>
          }
          update: {
            args: Prisma.pencairan_pendapatanUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pencairan_pendapatanPayload>
          }
          deleteMany: {
            args: Prisma.pencairan_pendapatanDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.pencairan_pendapatanUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.pencairan_pendapatanUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pencairan_pendapatanPayload>
          }
          aggregate: {
            args: Prisma.Pencairan_pendapatanAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePencairan_pendapatan>
          }
          groupBy: {
            args: Prisma.pencairan_pendapatanGroupByArgs<ExtArgs>
            result: $Utils.Optional<Pencairan_pendapatanGroupByOutputType>[]
          }
          count: {
            args: Prisma.pencairan_pendapatanCountArgs<ExtArgs>
            result: $Utils.Optional<Pencairan_pendapatanCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UsersCountOutputType
   */

  export type UsersCountOutputType = {
    orders: number
    transaksi: number
    notifikasi: number
    ulasan: number
    refund: number
  }

  export type UsersCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orders?: boolean | UsersCountOutputTypeCountOrdersArgs
    transaksi?: boolean | UsersCountOutputTypeCountTransaksiArgs
    notifikasi?: boolean | UsersCountOutputTypeCountNotifikasiArgs
    ulasan?: boolean | UsersCountOutputTypeCountUlasanArgs
    refund?: boolean | UsersCountOutputTypeCountRefundArgs
  }

  // Custom InputTypes
  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsersCountOutputType
     */
    select?: UsersCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: order_bookingWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountTransaksiArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: transaksiWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountNotifikasiArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: notifikasiWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountUlasanArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ulasanWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountRefundArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: refundWhereInput
  }


  /**
   * Count Type MitraCountOutputType
   */

  export type MitraCountOutputType = {
    lapangan: number
    pendapatan: number
    pencairan: number
  }

  export type MitraCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lapangan?: boolean | MitraCountOutputTypeCountLapanganArgs
    pendapatan?: boolean | MitraCountOutputTypeCountPendapatanArgs
    pencairan?: boolean | MitraCountOutputTypeCountPencairanArgs
  }

  // Custom InputTypes
  /**
   * MitraCountOutputType without action
   */
  export type MitraCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MitraCountOutputType
     */
    select?: MitraCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MitraCountOutputType without action
   */
  export type MitraCountOutputTypeCountLapanganArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LapanganWhereInput
  }

  /**
   * MitraCountOutputType without action
   */
  export type MitraCountOutputTypeCountPendapatanArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: pendapatan_mitraWhereInput
  }

  /**
   * MitraCountOutputType without action
   */
  export type MitraCountOutputTypeCountPencairanArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: pencairan_pendapatanWhereInput
  }


  /**
   * Count Type LapanganCountOutputType
   */

  export type LapanganCountOutputType = {
    gambarList: number
    jadwal: number
    orders: number
    transaksi: number
    ulasan: number
  }

  export type LapanganCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    gambarList?: boolean | LapanganCountOutputTypeCountGambarListArgs
    jadwal?: boolean | LapanganCountOutputTypeCountJadwalArgs
    orders?: boolean | LapanganCountOutputTypeCountOrdersArgs
    transaksi?: boolean | LapanganCountOutputTypeCountTransaksiArgs
    ulasan?: boolean | LapanganCountOutputTypeCountUlasanArgs
  }

  // Custom InputTypes
  /**
   * LapanganCountOutputType without action
   */
  export type LapanganCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LapanganCountOutputType
     */
    select?: LapanganCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LapanganCountOutputType without action
   */
  export type LapanganCountOutputTypeCountGambarListArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LapanganGambarWhereInput
  }

  /**
   * LapanganCountOutputType without action
   */
  export type LapanganCountOutputTypeCountJadwalArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JadwalLapanganWhereInput
  }

  /**
   * LapanganCountOutputType without action
   */
  export type LapanganCountOutputTypeCountOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: order_bookingWhereInput
  }

  /**
   * LapanganCountOutputType without action
   */
  export type LapanganCountOutputTypeCountTransaksiArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: transaksiWhereInput
  }

  /**
   * LapanganCountOutputType without action
   */
  export type LapanganCountOutputTypeCountUlasanArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ulasanWhereInput
  }


  /**
   * Count Type JadwalLapanganCountOutputType
   */

  export type JadwalLapanganCountOutputType = {
    orders: number
    transaksi: number
  }

  export type JadwalLapanganCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orders?: boolean | JadwalLapanganCountOutputTypeCountOrdersArgs
    transaksi?: boolean | JadwalLapanganCountOutputTypeCountTransaksiArgs
  }

  // Custom InputTypes
  /**
   * JadwalLapanganCountOutputType without action
   */
  export type JadwalLapanganCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JadwalLapanganCountOutputType
     */
    select?: JadwalLapanganCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * JadwalLapanganCountOutputType without action
   */
  export type JadwalLapanganCountOutputTypeCountOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: order_bookingWhereInput
  }

  /**
   * JadwalLapanganCountOutputType without action
   */
  export type JadwalLapanganCountOutputTypeCountTransaksiArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: transaksiWhereInput
  }


  /**
   * Count Type Order_bookingCountOutputType
   */

  export type Order_bookingCountOutputType = {
    wallet_histories: number
  }

  export type Order_bookingCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    wallet_histories?: boolean | Order_bookingCountOutputTypeCountWallet_historiesArgs
  }

  // Custom InputTypes
  /**
   * Order_bookingCountOutputType without action
   */
  export type Order_bookingCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order_bookingCountOutputType
     */
    select?: Order_bookingCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Order_bookingCountOutputType without action
   */
  export type Order_bookingCountOutputTypeCountWallet_historiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: wallet_historyWhereInput
  }


  /**
   * Count Type TransaksiCountOutputType
   */

  export type TransaksiCountOutputType = {
    sewa_raket: number
  }

  export type TransaksiCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sewa_raket?: boolean | TransaksiCountOutputTypeCountSewa_raketArgs
  }

  // Custom InputTypes
  /**
   * TransaksiCountOutputType without action
   */
  export type TransaksiCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransaksiCountOutputType
     */
    select?: TransaksiCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TransaksiCountOutputType without action
   */
  export type TransaksiCountOutputTypeCountSewa_raketArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: sewa_raketWhereInput
  }


  /**
   * Count Type Raket_padelCountOutputType
   */

  export type Raket_padelCountOutputType = {
    sewa_raket: number
  }

  export type Raket_padelCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sewa_raket?: boolean | Raket_padelCountOutputTypeCountSewa_raketArgs
  }

  // Custom InputTypes
  /**
   * Raket_padelCountOutputType without action
   */
  export type Raket_padelCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Raket_padelCountOutputType
     */
    select?: Raket_padelCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Raket_padelCountOutputType without action
   */
  export type Raket_padelCountOutputTypeCountSewa_raketArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: sewa_raketWhereInput
  }


  /**
   * Count Type Wallet_userCountOutputType
   */

  export type Wallet_userCountOutputType = {
    history: number
  }

  export type Wallet_userCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    history?: boolean | Wallet_userCountOutputTypeCountHistoryArgs
  }

  // Custom InputTypes
  /**
   * Wallet_userCountOutputType without action
   */
  export type Wallet_userCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wallet_userCountOutputType
     */
    select?: Wallet_userCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Wallet_userCountOutputType without action
   */
  export type Wallet_userCountOutputTypeCountHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: wallet_historyWhereInput
  }


  /**
   * Models
   */

  /**
   * Model users
   */

  export type AggregateUsers = {
    _count: UsersCountAggregateOutputType | null
    _avg: UsersAvgAggregateOutputType | null
    _sum: UsersSumAggregateOutputType | null
    _min: UsersMinAggregateOutputType | null
    _max: UsersMaxAggregateOutputType | null
  }

  export type UsersAvgAggregateOutputType = {
    id: number | null
  }

  export type UsersSumAggregateOutputType = {
    id: number | null
  }

  export type UsersMinAggregateOutputType = {
    id: number | null
    nama: string | null
    username: string | null
    email: string | null
    password: string | null
    no_hp: string | null
    foto: string | null
    bio: string | null
    role: $Enums.users_role | null
    status: $Enums.users_status | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type UsersMaxAggregateOutputType = {
    id: number | null
    nama: string | null
    username: string | null
    email: string | null
    password: string | null
    no_hp: string | null
    foto: string | null
    bio: string | null
    role: $Enums.users_role | null
    status: $Enums.users_status | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type UsersCountAggregateOutputType = {
    id: number
    nama: number
    username: number
    email: number
    password: number
    no_hp: number
    foto: number
    bio: number
    role: number
    status: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type UsersAvgAggregateInputType = {
    id?: true
  }

  export type UsersSumAggregateInputType = {
    id?: true
  }

  export type UsersMinAggregateInputType = {
    id?: true
    nama?: true
    username?: true
    email?: true
    password?: true
    no_hp?: true
    foto?: true
    bio?: true
    role?: true
    status?: true
    created_at?: true
    updated_at?: true
  }

  export type UsersMaxAggregateInputType = {
    id?: true
    nama?: true
    username?: true
    email?: true
    password?: true
    no_hp?: true
    foto?: true
    bio?: true
    role?: true
    status?: true
    created_at?: true
    updated_at?: true
  }

  export type UsersCountAggregateInputType = {
    id?: true
    nama?: true
    username?: true
    email?: true
    password?: true
    no_hp?: true
    foto?: true
    bio?: true
    role?: true
    status?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type UsersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which users to aggregate.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned users
    **/
    _count?: true | UsersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UsersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UsersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsersMaxAggregateInputType
  }

  export type GetUsersAggregateType<T extends UsersAggregateArgs> = {
        [P in keyof T & keyof AggregateUsers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsers[P]>
      : GetScalarType<T[P], AggregateUsers[P]>
  }




  export type usersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: usersWhereInput
    orderBy?: usersOrderByWithAggregationInput | usersOrderByWithAggregationInput[]
    by: UsersScalarFieldEnum[] | UsersScalarFieldEnum
    having?: usersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsersCountAggregateInputType | true
    _avg?: UsersAvgAggregateInputType
    _sum?: UsersSumAggregateInputType
    _min?: UsersMinAggregateInputType
    _max?: UsersMaxAggregateInputType
  }

  export type UsersGroupByOutputType = {
    id: number
    nama: string
    username: string
    email: string
    password: string
    no_hp: string | null
    foto: string | null
    bio: string | null
    role: $Enums.users_role
    status: $Enums.users_status
    created_at: Date
    updated_at: Date
    _count: UsersCountAggregateOutputType | null
    _avg: UsersAvgAggregateOutputType | null
    _sum: UsersSumAggregateOutputType | null
    _min: UsersMinAggregateOutputType | null
    _max: UsersMaxAggregateOutputType | null
  }

  type GetUsersGroupByPayload<T extends usersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UsersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsersGroupByOutputType[P]>
            : GetScalarType<T[P], UsersGroupByOutputType[P]>
        }
      >
    >


  export type usersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nama?: boolean
    username?: boolean
    email?: boolean
    password?: boolean
    no_hp?: boolean
    foto?: boolean
    bio?: boolean
    role?: boolean
    status?: boolean
    created_at?: boolean
    updated_at?: boolean
    mitra?: boolean | users$mitraArgs<ExtArgs>
    orders?: boolean | users$ordersArgs<ExtArgs>
    transaksi?: boolean | users$transaksiArgs<ExtArgs>
    notifikasi?: boolean | users$notifikasiArgs<ExtArgs>
    ulasan?: boolean | users$ulasanArgs<ExtArgs>
    wallet?: boolean | users$walletArgs<ExtArgs>
    refund?: boolean | users$refundArgs<ExtArgs>
    _count?: boolean | UsersCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["users"]>


  export type usersSelectScalar = {
    id?: boolean
    nama?: boolean
    username?: boolean
    email?: boolean
    password?: boolean
    no_hp?: boolean
    foto?: boolean
    bio?: boolean
    role?: boolean
    status?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type usersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mitra?: boolean | users$mitraArgs<ExtArgs>
    orders?: boolean | users$ordersArgs<ExtArgs>
    transaksi?: boolean | users$transaksiArgs<ExtArgs>
    notifikasi?: boolean | users$notifikasiArgs<ExtArgs>
    ulasan?: boolean | users$ulasanArgs<ExtArgs>
    wallet?: boolean | users$walletArgs<ExtArgs>
    refund?: boolean | users$refundArgs<ExtArgs>
    _count?: boolean | UsersCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $usersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "users"
    objects: {
      mitra: Prisma.$MitraPayload<ExtArgs> | null
      orders: Prisma.$order_bookingPayload<ExtArgs>[]
      transaksi: Prisma.$transaksiPayload<ExtArgs>[]
      notifikasi: Prisma.$notifikasiPayload<ExtArgs>[]
      ulasan: Prisma.$ulasanPayload<ExtArgs>[]
      wallet: Prisma.$wallet_userPayload<ExtArgs> | null
      refund: Prisma.$refundPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nama: string
      username: string
      email: string
      password: string
      no_hp: string | null
      foto: string | null
      bio: string | null
      role: $Enums.users_role
      status: $Enums.users_status
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["users"]>
    composites: {}
  }

  type usersGetPayload<S extends boolean | null | undefined | usersDefaultArgs> = $Result.GetResult<Prisma.$usersPayload, S>

  type usersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<usersFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UsersCountAggregateInputType | true
    }

  export interface usersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['users'], meta: { name: 'users' } }
    /**
     * Find zero or one Users that matches the filter.
     * @param {usersFindUniqueArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends usersFindUniqueArgs>(args: SelectSubset<T, usersFindUniqueArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Users that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {usersFindUniqueOrThrowArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends usersFindUniqueOrThrowArgs>(args: SelectSubset<T, usersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindFirstArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends usersFindFirstArgs>(args?: SelectSubset<T, usersFindFirstArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Users that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindFirstOrThrowArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends usersFindFirstOrThrowArgs>(args?: SelectSubset<T, usersFindFirstOrThrowArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.users.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.users.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const usersWithIdOnly = await prisma.users.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends usersFindManyArgs>(args?: SelectSubset<T, usersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Users.
     * @param {usersCreateArgs} args - Arguments to create a Users.
     * @example
     * // Create one Users
     * const Users = await prisma.users.create({
     *   data: {
     *     // ... data to create a Users
     *   }
     * })
     * 
     */
    create<T extends usersCreateArgs>(args: SelectSubset<T, usersCreateArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {usersCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const users = await prisma.users.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends usersCreateManyArgs>(args?: SelectSubset<T, usersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Users.
     * @param {usersDeleteArgs} args - Arguments to delete one Users.
     * @example
     * // Delete one Users
     * const Users = await prisma.users.delete({
     *   where: {
     *     // ... filter to delete one Users
     *   }
     * })
     * 
     */
    delete<T extends usersDeleteArgs>(args: SelectSubset<T, usersDeleteArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Users.
     * @param {usersUpdateArgs} args - Arguments to update one Users.
     * @example
     * // Update one Users
     * const users = await prisma.users.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends usersUpdateArgs>(args: SelectSubset<T, usersUpdateArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {usersDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.users.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends usersDeleteManyArgs>(args?: SelectSubset<T, usersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const users = await prisma.users.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends usersUpdateManyArgs>(args: SelectSubset<T, usersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Users.
     * @param {usersUpsertArgs} args - Arguments to update or create a Users.
     * @example
     * // Update or create a Users
     * const users = await prisma.users.upsert({
     *   create: {
     *     // ... data to create a Users
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Users we want to update
     *   }
     * })
     */
    upsert<T extends usersUpsertArgs>(args: SelectSubset<T, usersUpsertArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.users.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends usersCountArgs>(
      args?: Subset<T, usersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsersAggregateArgs>(args: Subset<T, UsersAggregateArgs>): Prisma.PrismaPromise<GetUsersAggregateType<T>>

    /**
     * Group by Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends usersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: usersGroupByArgs['orderBy'] }
        : { orderBy?: usersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, usersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the users model
   */
  readonly fields: usersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for users.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__usersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    mitra<T extends users$mitraArgs<ExtArgs> = {}>(args?: Subset<T, users$mitraArgs<ExtArgs>>): Prisma__MitraClient<$Result.GetResult<Prisma.$MitraPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    orders<T extends users$ordersArgs<ExtArgs> = {}>(args?: Subset<T, users$ordersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$order_bookingPayload<ExtArgs>, T, "findMany"> | Null>
    transaksi<T extends users$transaksiArgs<ExtArgs> = {}>(args?: Subset<T, users$transaksiArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$transaksiPayload<ExtArgs>, T, "findMany"> | Null>
    notifikasi<T extends users$notifikasiArgs<ExtArgs> = {}>(args?: Subset<T, users$notifikasiArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$notifikasiPayload<ExtArgs>, T, "findMany"> | Null>
    ulasan<T extends users$ulasanArgs<ExtArgs> = {}>(args?: Subset<T, users$ulasanArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ulasanPayload<ExtArgs>, T, "findMany"> | Null>
    wallet<T extends users$walletArgs<ExtArgs> = {}>(args?: Subset<T, users$walletArgs<ExtArgs>>): Prisma__wallet_userClient<$Result.GetResult<Prisma.$wallet_userPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    refund<T extends users$refundArgs<ExtArgs> = {}>(args?: Subset<T, users$refundArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$refundPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the users model
   */ 
  interface usersFieldRefs {
    readonly id: FieldRef<"users", 'Int'>
    readonly nama: FieldRef<"users", 'String'>
    readonly username: FieldRef<"users", 'String'>
    readonly email: FieldRef<"users", 'String'>
    readonly password: FieldRef<"users", 'String'>
    readonly no_hp: FieldRef<"users", 'String'>
    readonly foto: FieldRef<"users", 'String'>
    readonly bio: FieldRef<"users", 'String'>
    readonly role: FieldRef<"users", 'users_role'>
    readonly status: FieldRef<"users", 'users_status'>
    readonly created_at: FieldRef<"users", 'DateTime'>
    readonly updated_at: FieldRef<"users", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * users findUnique
   */
  export type usersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users findUniqueOrThrow
   */
  export type usersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users findFirst
   */
  export type usersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * users findFirstOrThrow
   */
  export type usersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * users findMany
   */
  export type usersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * users create
   */
  export type usersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * The data needed to create a users.
     */
    data: XOR<usersCreateInput, usersUncheckedCreateInput>
  }

  /**
   * users createMany
   */
  export type usersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many users.
     */
    data: usersCreateManyInput | usersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * users update
   */
  export type usersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * The data needed to update a users.
     */
    data: XOR<usersUpdateInput, usersUncheckedUpdateInput>
    /**
     * Choose, which users to update.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users updateMany
   */
  export type usersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update users.
     */
    data: XOR<usersUpdateManyMutationInput, usersUncheckedUpdateManyInput>
    /**
     * Filter which users to update
     */
    where?: usersWhereInput
  }

  /**
   * users upsert
   */
  export type usersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * The filter to search for the users to update in case it exists.
     */
    where: usersWhereUniqueInput
    /**
     * In case the users found by the `where` argument doesn't exist, create a new users with this data.
     */
    create: XOR<usersCreateInput, usersUncheckedCreateInput>
    /**
     * In case the users was found with the provided `where` argument, update it with this data.
     */
    update: XOR<usersUpdateInput, usersUncheckedUpdateInput>
  }

  /**
   * users delete
   */
  export type usersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter which users to delete.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users deleteMany
   */
  export type usersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which users to delete
     */
    where?: usersWhereInput
  }

  /**
   * users.mitra
   */
  export type users$mitraArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mitra
     */
    select?: MitraSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MitraInclude<ExtArgs> | null
    where?: MitraWhereInput
  }

  /**
   * users.orders
   */
  export type users$ordersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order_booking
     */
    select?: order_bookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: order_bookingInclude<ExtArgs> | null
    where?: order_bookingWhereInput
    orderBy?: order_bookingOrderByWithRelationInput | order_bookingOrderByWithRelationInput[]
    cursor?: order_bookingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Order_bookingScalarFieldEnum | Order_bookingScalarFieldEnum[]
  }

  /**
   * users.transaksi
   */
  export type users$transaksiArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transaksi
     */
    select?: transaksiSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transaksiInclude<ExtArgs> | null
    where?: transaksiWhereInput
    orderBy?: transaksiOrderByWithRelationInput | transaksiOrderByWithRelationInput[]
    cursor?: transaksiWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransaksiScalarFieldEnum | TransaksiScalarFieldEnum[]
  }

  /**
   * users.notifikasi
   */
  export type users$notifikasiArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifikasi
     */
    select?: notifikasiSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notifikasiInclude<ExtArgs> | null
    where?: notifikasiWhereInput
    orderBy?: notifikasiOrderByWithRelationInput | notifikasiOrderByWithRelationInput[]
    cursor?: notifikasiWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotifikasiScalarFieldEnum | NotifikasiScalarFieldEnum[]
  }

  /**
   * users.ulasan
   */
  export type users$ulasanArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ulasan
     */
    select?: ulasanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ulasanInclude<ExtArgs> | null
    where?: ulasanWhereInput
    orderBy?: ulasanOrderByWithRelationInput | ulasanOrderByWithRelationInput[]
    cursor?: ulasanWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UlasanScalarFieldEnum | UlasanScalarFieldEnum[]
  }

  /**
   * users.wallet
   */
  export type users$walletArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wallet_user
     */
    select?: wallet_userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: wallet_userInclude<ExtArgs> | null
    where?: wallet_userWhereInput
  }

  /**
   * users.refund
   */
  export type users$refundArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the refund
     */
    select?: refundSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: refundInclude<ExtArgs> | null
    where?: refundWhereInput
    orderBy?: refundOrderByWithRelationInput | refundOrderByWithRelationInput[]
    cursor?: refundWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RefundScalarFieldEnum | RefundScalarFieldEnum[]
  }

  /**
   * users without action
   */
  export type usersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
  }


  /**
   * Model Mitra
   */

  export type AggregateMitra = {
    _count: MitraCountAggregateOutputType | null
    _avg: MitraAvgAggregateOutputType | null
    _sum: MitraSumAggregateOutputType | null
    _min: MitraMinAggregateOutputType | null
    _max: MitraMaxAggregateOutputType | null
  }

  export type MitraAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    withdraw_day: number | null
  }

  export type MitraSumAggregateOutputType = {
    id: number | null
    userId: number | null
    withdraw_day: number | null
  }

  export type MitraMinAggregateOutputType = {
    id: number | null
    userId: number | null
    nama_usaha: string | null
    alamat_usaha: string | null
    no_ktp: string | null
    foto_ktp: string | null
    withdraw_type: string | null
    withdraw_day: number | null
    bank_mitra: string | null
    no_rekening_mitra: string | null
    status: $Enums.mitra_status | null
    created_at: Date | null
  }

  export type MitraMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    nama_usaha: string | null
    alamat_usaha: string | null
    no_ktp: string | null
    foto_ktp: string | null
    withdraw_type: string | null
    withdraw_day: number | null
    bank_mitra: string | null
    no_rekening_mitra: string | null
    status: $Enums.mitra_status | null
    created_at: Date | null
  }

  export type MitraCountAggregateOutputType = {
    id: number
    userId: number
    nama_usaha: number
    alamat_usaha: number
    no_ktp: number
    foto_ktp: number
    withdraw_type: number
    withdraw_day: number
    bank_mitra: number
    no_rekening_mitra: number
    status: number
    created_at: number
    _all: number
  }


  export type MitraAvgAggregateInputType = {
    id?: true
    userId?: true
    withdraw_day?: true
  }

  export type MitraSumAggregateInputType = {
    id?: true
    userId?: true
    withdraw_day?: true
  }

  export type MitraMinAggregateInputType = {
    id?: true
    userId?: true
    nama_usaha?: true
    alamat_usaha?: true
    no_ktp?: true
    foto_ktp?: true
    withdraw_type?: true
    withdraw_day?: true
    bank_mitra?: true
    no_rekening_mitra?: true
    status?: true
    created_at?: true
  }

  export type MitraMaxAggregateInputType = {
    id?: true
    userId?: true
    nama_usaha?: true
    alamat_usaha?: true
    no_ktp?: true
    foto_ktp?: true
    withdraw_type?: true
    withdraw_day?: true
    bank_mitra?: true
    no_rekening_mitra?: true
    status?: true
    created_at?: true
  }

  export type MitraCountAggregateInputType = {
    id?: true
    userId?: true
    nama_usaha?: true
    alamat_usaha?: true
    no_ktp?: true
    foto_ktp?: true
    withdraw_type?: true
    withdraw_day?: true
    bank_mitra?: true
    no_rekening_mitra?: true
    status?: true
    created_at?: true
    _all?: true
  }

  export type MitraAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Mitra to aggregate.
     */
    where?: MitraWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Mitras to fetch.
     */
    orderBy?: MitraOrderByWithRelationInput | MitraOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MitraWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Mitras from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Mitras.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Mitras
    **/
    _count?: true | MitraCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MitraAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MitraSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MitraMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MitraMaxAggregateInputType
  }

  export type GetMitraAggregateType<T extends MitraAggregateArgs> = {
        [P in keyof T & keyof AggregateMitra]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMitra[P]>
      : GetScalarType<T[P], AggregateMitra[P]>
  }




  export type MitraGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MitraWhereInput
    orderBy?: MitraOrderByWithAggregationInput | MitraOrderByWithAggregationInput[]
    by: MitraScalarFieldEnum[] | MitraScalarFieldEnum
    having?: MitraScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MitraCountAggregateInputType | true
    _avg?: MitraAvgAggregateInputType
    _sum?: MitraSumAggregateInputType
    _min?: MitraMinAggregateInputType
    _max?: MitraMaxAggregateInputType
  }

  export type MitraGroupByOutputType = {
    id: number
    userId: number
    nama_usaha: string
    alamat_usaha: string
    no_ktp: string
    foto_ktp: string
    withdraw_type: string | null
    withdraw_day: number | null
    bank_mitra: string | null
    no_rekening_mitra: string | null
    status: $Enums.mitra_status
    created_at: Date
    _count: MitraCountAggregateOutputType | null
    _avg: MitraAvgAggregateOutputType | null
    _sum: MitraSumAggregateOutputType | null
    _min: MitraMinAggregateOutputType | null
    _max: MitraMaxAggregateOutputType | null
  }

  type GetMitraGroupByPayload<T extends MitraGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MitraGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MitraGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MitraGroupByOutputType[P]>
            : GetScalarType<T[P], MitraGroupByOutputType[P]>
        }
      >
    >


  export type MitraSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    nama_usaha?: boolean
    alamat_usaha?: boolean
    no_ktp?: boolean
    foto_ktp?: boolean
    withdraw_type?: boolean
    withdraw_day?: boolean
    bank_mitra?: boolean
    no_rekening_mitra?: boolean
    status?: boolean
    created_at?: boolean
    user?: boolean | usersDefaultArgs<ExtArgs>
    lapangan?: boolean | Mitra$lapanganArgs<ExtArgs>
    pendapatan?: boolean | Mitra$pendapatanArgs<ExtArgs>
    pencairan?: boolean | Mitra$pencairanArgs<ExtArgs>
    _count?: boolean | MitraCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mitra"]>


  export type MitraSelectScalar = {
    id?: boolean
    userId?: boolean
    nama_usaha?: boolean
    alamat_usaha?: boolean
    no_ktp?: boolean
    foto_ktp?: boolean
    withdraw_type?: boolean
    withdraw_day?: boolean
    bank_mitra?: boolean
    no_rekening_mitra?: boolean
    status?: boolean
    created_at?: boolean
  }

  export type MitraInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | usersDefaultArgs<ExtArgs>
    lapangan?: boolean | Mitra$lapanganArgs<ExtArgs>
    pendapatan?: boolean | Mitra$pendapatanArgs<ExtArgs>
    pencairan?: boolean | Mitra$pencairanArgs<ExtArgs>
    _count?: boolean | MitraCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $MitraPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Mitra"
    objects: {
      user: Prisma.$usersPayload<ExtArgs>
      lapangan: Prisma.$LapanganPayload<ExtArgs>[]
      pendapatan: Prisma.$pendapatan_mitraPayload<ExtArgs>[]
      pencairan: Prisma.$pencairan_pendapatanPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      nama_usaha: string
      alamat_usaha: string
      no_ktp: string
      foto_ktp: string
      withdraw_type: string | null
      withdraw_day: number | null
      bank_mitra: string | null
      no_rekening_mitra: string | null
      status: $Enums.mitra_status
      created_at: Date
    }, ExtArgs["result"]["mitra"]>
    composites: {}
  }

  type MitraGetPayload<S extends boolean | null | undefined | MitraDefaultArgs> = $Result.GetResult<Prisma.$MitraPayload, S>

  type MitraCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MitraFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MitraCountAggregateInputType | true
    }

  export interface MitraDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Mitra'], meta: { name: 'Mitra' } }
    /**
     * Find zero or one Mitra that matches the filter.
     * @param {MitraFindUniqueArgs} args - Arguments to find a Mitra
     * @example
     * // Get one Mitra
     * const mitra = await prisma.mitra.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MitraFindUniqueArgs>(args: SelectSubset<T, MitraFindUniqueArgs<ExtArgs>>): Prisma__MitraClient<$Result.GetResult<Prisma.$MitraPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Mitra that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MitraFindUniqueOrThrowArgs} args - Arguments to find a Mitra
     * @example
     * // Get one Mitra
     * const mitra = await prisma.mitra.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MitraFindUniqueOrThrowArgs>(args: SelectSubset<T, MitraFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MitraClient<$Result.GetResult<Prisma.$MitraPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Mitra that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MitraFindFirstArgs} args - Arguments to find a Mitra
     * @example
     * // Get one Mitra
     * const mitra = await prisma.mitra.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MitraFindFirstArgs>(args?: SelectSubset<T, MitraFindFirstArgs<ExtArgs>>): Prisma__MitraClient<$Result.GetResult<Prisma.$MitraPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Mitra that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MitraFindFirstOrThrowArgs} args - Arguments to find a Mitra
     * @example
     * // Get one Mitra
     * const mitra = await prisma.mitra.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MitraFindFirstOrThrowArgs>(args?: SelectSubset<T, MitraFindFirstOrThrowArgs<ExtArgs>>): Prisma__MitraClient<$Result.GetResult<Prisma.$MitraPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Mitras that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MitraFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Mitras
     * const mitras = await prisma.mitra.findMany()
     * 
     * // Get first 10 Mitras
     * const mitras = await prisma.mitra.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mitraWithIdOnly = await prisma.mitra.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MitraFindManyArgs>(args?: SelectSubset<T, MitraFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MitraPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Mitra.
     * @param {MitraCreateArgs} args - Arguments to create a Mitra.
     * @example
     * // Create one Mitra
     * const Mitra = await prisma.mitra.create({
     *   data: {
     *     // ... data to create a Mitra
     *   }
     * })
     * 
     */
    create<T extends MitraCreateArgs>(args: SelectSubset<T, MitraCreateArgs<ExtArgs>>): Prisma__MitraClient<$Result.GetResult<Prisma.$MitraPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Mitras.
     * @param {MitraCreateManyArgs} args - Arguments to create many Mitras.
     * @example
     * // Create many Mitras
     * const mitra = await prisma.mitra.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MitraCreateManyArgs>(args?: SelectSubset<T, MitraCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Mitra.
     * @param {MitraDeleteArgs} args - Arguments to delete one Mitra.
     * @example
     * // Delete one Mitra
     * const Mitra = await prisma.mitra.delete({
     *   where: {
     *     // ... filter to delete one Mitra
     *   }
     * })
     * 
     */
    delete<T extends MitraDeleteArgs>(args: SelectSubset<T, MitraDeleteArgs<ExtArgs>>): Prisma__MitraClient<$Result.GetResult<Prisma.$MitraPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Mitra.
     * @param {MitraUpdateArgs} args - Arguments to update one Mitra.
     * @example
     * // Update one Mitra
     * const mitra = await prisma.mitra.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MitraUpdateArgs>(args: SelectSubset<T, MitraUpdateArgs<ExtArgs>>): Prisma__MitraClient<$Result.GetResult<Prisma.$MitraPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Mitras.
     * @param {MitraDeleteManyArgs} args - Arguments to filter Mitras to delete.
     * @example
     * // Delete a few Mitras
     * const { count } = await prisma.mitra.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MitraDeleteManyArgs>(args?: SelectSubset<T, MitraDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Mitras.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MitraUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Mitras
     * const mitra = await prisma.mitra.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MitraUpdateManyArgs>(args: SelectSubset<T, MitraUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Mitra.
     * @param {MitraUpsertArgs} args - Arguments to update or create a Mitra.
     * @example
     * // Update or create a Mitra
     * const mitra = await prisma.mitra.upsert({
     *   create: {
     *     // ... data to create a Mitra
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Mitra we want to update
     *   }
     * })
     */
    upsert<T extends MitraUpsertArgs>(args: SelectSubset<T, MitraUpsertArgs<ExtArgs>>): Prisma__MitraClient<$Result.GetResult<Prisma.$MitraPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Mitras.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MitraCountArgs} args - Arguments to filter Mitras to count.
     * @example
     * // Count the number of Mitras
     * const count = await prisma.mitra.count({
     *   where: {
     *     // ... the filter for the Mitras we want to count
     *   }
     * })
    **/
    count<T extends MitraCountArgs>(
      args?: Subset<T, MitraCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MitraCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Mitra.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MitraAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MitraAggregateArgs>(args: Subset<T, MitraAggregateArgs>): Prisma.PrismaPromise<GetMitraAggregateType<T>>

    /**
     * Group by Mitra.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MitraGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MitraGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MitraGroupByArgs['orderBy'] }
        : { orderBy?: MitraGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MitraGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMitraGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Mitra model
   */
  readonly fields: MitraFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Mitra.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MitraClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    lapangan<T extends Mitra$lapanganArgs<ExtArgs> = {}>(args?: Subset<T, Mitra$lapanganArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LapanganPayload<ExtArgs>, T, "findMany"> | Null>
    pendapatan<T extends Mitra$pendapatanArgs<ExtArgs> = {}>(args?: Subset<T, Mitra$pendapatanArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$pendapatan_mitraPayload<ExtArgs>, T, "findMany"> | Null>
    pencairan<T extends Mitra$pencairanArgs<ExtArgs> = {}>(args?: Subset<T, Mitra$pencairanArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$pencairan_pendapatanPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Mitra model
   */ 
  interface MitraFieldRefs {
    readonly id: FieldRef<"Mitra", 'Int'>
    readonly userId: FieldRef<"Mitra", 'Int'>
    readonly nama_usaha: FieldRef<"Mitra", 'String'>
    readonly alamat_usaha: FieldRef<"Mitra", 'String'>
    readonly no_ktp: FieldRef<"Mitra", 'String'>
    readonly foto_ktp: FieldRef<"Mitra", 'String'>
    readonly withdraw_type: FieldRef<"Mitra", 'String'>
    readonly withdraw_day: FieldRef<"Mitra", 'Int'>
    readonly bank_mitra: FieldRef<"Mitra", 'String'>
    readonly no_rekening_mitra: FieldRef<"Mitra", 'String'>
    readonly status: FieldRef<"Mitra", 'mitra_status'>
    readonly created_at: FieldRef<"Mitra", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Mitra findUnique
   */
  export type MitraFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mitra
     */
    select?: MitraSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MitraInclude<ExtArgs> | null
    /**
     * Filter, which Mitra to fetch.
     */
    where: MitraWhereUniqueInput
  }

  /**
   * Mitra findUniqueOrThrow
   */
  export type MitraFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mitra
     */
    select?: MitraSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MitraInclude<ExtArgs> | null
    /**
     * Filter, which Mitra to fetch.
     */
    where: MitraWhereUniqueInput
  }

  /**
   * Mitra findFirst
   */
  export type MitraFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mitra
     */
    select?: MitraSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MitraInclude<ExtArgs> | null
    /**
     * Filter, which Mitra to fetch.
     */
    where?: MitraWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Mitras to fetch.
     */
    orderBy?: MitraOrderByWithRelationInput | MitraOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Mitras.
     */
    cursor?: MitraWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Mitras from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Mitras.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Mitras.
     */
    distinct?: MitraScalarFieldEnum | MitraScalarFieldEnum[]
  }

  /**
   * Mitra findFirstOrThrow
   */
  export type MitraFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mitra
     */
    select?: MitraSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MitraInclude<ExtArgs> | null
    /**
     * Filter, which Mitra to fetch.
     */
    where?: MitraWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Mitras to fetch.
     */
    orderBy?: MitraOrderByWithRelationInput | MitraOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Mitras.
     */
    cursor?: MitraWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Mitras from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Mitras.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Mitras.
     */
    distinct?: MitraScalarFieldEnum | MitraScalarFieldEnum[]
  }

  /**
   * Mitra findMany
   */
  export type MitraFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mitra
     */
    select?: MitraSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MitraInclude<ExtArgs> | null
    /**
     * Filter, which Mitras to fetch.
     */
    where?: MitraWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Mitras to fetch.
     */
    orderBy?: MitraOrderByWithRelationInput | MitraOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Mitras.
     */
    cursor?: MitraWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Mitras from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Mitras.
     */
    skip?: number
    distinct?: MitraScalarFieldEnum | MitraScalarFieldEnum[]
  }

  /**
   * Mitra create
   */
  export type MitraCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mitra
     */
    select?: MitraSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MitraInclude<ExtArgs> | null
    /**
     * The data needed to create a Mitra.
     */
    data: XOR<MitraCreateInput, MitraUncheckedCreateInput>
  }

  /**
   * Mitra createMany
   */
  export type MitraCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Mitras.
     */
    data: MitraCreateManyInput | MitraCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Mitra update
   */
  export type MitraUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mitra
     */
    select?: MitraSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MitraInclude<ExtArgs> | null
    /**
     * The data needed to update a Mitra.
     */
    data: XOR<MitraUpdateInput, MitraUncheckedUpdateInput>
    /**
     * Choose, which Mitra to update.
     */
    where: MitraWhereUniqueInput
  }

  /**
   * Mitra updateMany
   */
  export type MitraUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Mitras.
     */
    data: XOR<MitraUpdateManyMutationInput, MitraUncheckedUpdateManyInput>
    /**
     * Filter which Mitras to update
     */
    where?: MitraWhereInput
  }

  /**
   * Mitra upsert
   */
  export type MitraUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mitra
     */
    select?: MitraSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MitraInclude<ExtArgs> | null
    /**
     * The filter to search for the Mitra to update in case it exists.
     */
    where: MitraWhereUniqueInput
    /**
     * In case the Mitra found by the `where` argument doesn't exist, create a new Mitra with this data.
     */
    create: XOR<MitraCreateInput, MitraUncheckedCreateInput>
    /**
     * In case the Mitra was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MitraUpdateInput, MitraUncheckedUpdateInput>
  }

  /**
   * Mitra delete
   */
  export type MitraDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mitra
     */
    select?: MitraSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MitraInclude<ExtArgs> | null
    /**
     * Filter which Mitra to delete.
     */
    where: MitraWhereUniqueInput
  }

  /**
   * Mitra deleteMany
   */
  export type MitraDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Mitras to delete
     */
    where?: MitraWhereInput
  }

  /**
   * Mitra.lapangan
   */
  export type Mitra$lapanganArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lapangan
     */
    select?: LapanganSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LapanganInclude<ExtArgs> | null
    where?: LapanganWhereInput
    orderBy?: LapanganOrderByWithRelationInput | LapanganOrderByWithRelationInput[]
    cursor?: LapanganWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LapanganScalarFieldEnum | LapanganScalarFieldEnum[]
  }

  /**
   * Mitra.pendapatan
   */
  export type Mitra$pendapatanArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pendapatan_mitra
     */
    select?: pendapatan_mitraSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pendapatan_mitraInclude<ExtArgs> | null
    where?: pendapatan_mitraWhereInput
    orderBy?: pendapatan_mitraOrderByWithRelationInput | pendapatan_mitraOrderByWithRelationInput[]
    cursor?: pendapatan_mitraWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Pendapatan_mitraScalarFieldEnum | Pendapatan_mitraScalarFieldEnum[]
  }

  /**
   * Mitra.pencairan
   */
  export type Mitra$pencairanArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pencairan_pendapatan
     */
    select?: pencairan_pendapatanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pencairan_pendapatanInclude<ExtArgs> | null
    where?: pencairan_pendapatanWhereInput
    orderBy?: pencairan_pendapatanOrderByWithRelationInput | pencairan_pendapatanOrderByWithRelationInput[]
    cursor?: pencairan_pendapatanWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Pencairan_pendapatanScalarFieldEnum | Pencairan_pendapatanScalarFieldEnum[]
  }

  /**
   * Mitra without action
   */
  export type MitraDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mitra
     */
    select?: MitraSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MitraInclude<ExtArgs> | null
  }


  /**
   * Model otp_codes
   */

  export type AggregateOtp_codes = {
    _count: Otp_codesCountAggregateOutputType | null
    _avg: Otp_codesAvgAggregateOutputType | null
    _sum: Otp_codesSumAggregateOutputType | null
    _min: Otp_codesMinAggregateOutputType | null
    _max: Otp_codesMaxAggregateOutputType | null
  }

  export type Otp_codesAvgAggregateOutputType = {
    id: number | null
  }

  export type Otp_codesSumAggregateOutputType = {
    id: number | null
  }

  export type Otp_codesMinAggregateOutputType = {
    id: number | null
    user_email: string | null
    kode_otp: string | null
    expired_at: Date | null
    digunakan: boolean | null
    created_at: Date | null
  }

  export type Otp_codesMaxAggregateOutputType = {
    id: number | null
    user_email: string | null
    kode_otp: string | null
    expired_at: Date | null
    digunakan: boolean | null
    created_at: Date | null
  }

  export type Otp_codesCountAggregateOutputType = {
    id: number
    user_email: number
    kode_otp: number
    expired_at: number
    digunakan: number
    created_at: number
    _all: number
  }


  export type Otp_codesAvgAggregateInputType = {
    id?: true
  }

  export type Otp_codesSumAggregateInputType = {
    id?: true
  }

  export type Otp_codesMinAggregateInputType = {
    id?: true
    user_email?: true
    kode_otp?: true
    expired_at?: true
    digunakan?: true
    created_at?: true
  }

  export type Otp_codesMaxAggregateInputType = {
    id?: true
    user_email?: true
    kode_otp?: true
    expired_at?: true
    digunakan?: true
    created_at?: true
  }

  export type Otp_codesCountAggregateInputType = {
    id?: true
    user_email?: true
    kode_otp?: true
    expired_at?: true
    digunakan?: true
    created_at?: true
    _all?: true
  }

  export type Otp_codesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which otp_codes to aggregate.
     */
    where?: otp_codesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of otp_codes to fetch.
     */
    orderBy?: otp_codesOrderByWithRelationInput | otp_codesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: otp_codesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` otp_codes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` otp_codes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned otp_codes
    **/
    _count?: true | Otp_codesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Otp_codesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Otp_codesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Otp_codesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Otp_codesMaxAggregateInputType
  }

  export type GetOtp_codesAggregateType<T extends Otp_codesAggregateArgs> = {
        [P in keyof T & keyof AggregateOtp_codes]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOtp_codes[P]>
      : GetScalarType<T[P], AggregateOtp_codes[P]>
  }




  export type otp_codesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: otp_codesWhereInput
    orderBy?: otp_codesOrderByWithAggregationInput | otp_codesOrderByWithAggregationInput[]
    by: Otp_codesScalarFieldEnum[] | Otp_codesScalarFieldEnum
    having?: otp_codesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Otp_codesCountAggregateInputType | true
    _avg?: Otp_codesAvgAggregateInputType
    _sum?: Otp_codesSumAggregateInputType
    _min?: Otp_codesMinAggregateInputType
    _max?: Otp_codesMaxAggregateInputType
  }

  export type Otp_codesGroupByOutputType = {
    id: number
    user_email: string
    kode_otp: string
    expired_at: Date
    digunakan: boolean
    created_at: Date
    _count: Otp_codesCountAggregateOutputType | null
    _avg: Otp_codesAvgAggregateOutputType | null
    _sum: Otp_codesSumAggregateOutputType | null
    _min: Otp_codesMinAggregateOutputType | null
    _max: Otp_codesMaxAggregateOutputType | null
  }

  type GetOtp_codesGroupByPayload<T extends otp_codesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Otp_codesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Otp_codesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Otp_codesGroupByOutputType[P]>
            : GetScalarType<T[P], Otp_codesGroupByOutputType[P]>
        }
      >
    >


  export type otp_codesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_email?: boolean
    kode_otp?: boolean
    expired_at?: boolean
    digunakan?: boolean
    created_at?: boolean
  }, ExtArgs["result"]["otp_codes"]>


  export type otp_codesSelectScalar = {
    id?: boolean
    user_email?: boolean
    kode_otp?: boolean
    expired_at?: boolean
    digunakan?: boolean
    created_at?: boolean
  }


  export type $otp_codesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "otp_codes"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      user_email: string
      kode_otp: string
      expired_at: Date
      digunakan: boolean
      created_at: Date
    }, ExtArgs["result"]["otp_codes"]>
    composites: {}
  }

  type otp_codesGetPayload<S extends boolean | null | undefined | otp_codesDefaultArgs> = $Result.GetResult<Prisma.$otp_codesPayload, S>

  type otp_codesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<otp_codesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Otp_codesCountAggregateInputType | true
    }

  export interface otp_codesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['otp_codes'], meta: { name: 'otp_codes' } }
    /**
     * Find zero or one Otp_codes that matches the filter.
     * @param {otp_codesFindUniqueArgs} args - Arguments to find a Otp_codes
     * @example
     * // Get one Otp_codes
     * const otp_codes = await prisma.otp_codes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends otp_codesFindUniqueArgs>(args: SelectSubset<T, otp_codesFindUniqueArgs<ExtArgs>>): Prisma__otp_codesClient<$Result.GetResult<Prisma.$otp_codesPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Otp_codes that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {otp_codesFindUniqueOrThrowArgs} args - Arguments to find a Otp_codes
     * @example
     * // Get one Otp_codes
     * const otp_codes = await prisma.otp_codes.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends otp_codesFindUniqueOrThrowArgs>(args: SelectSubset<T, otp_codesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__otp_codesClient<$Result.GetResult<Prisma.$otp_codesPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Otp_codes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {otp_codesFindFirstArgs} args - Arguments to find a Otp_codes
     * @example
     * // Get one Otp_codes
     * const otp_codes = await prisma.otp_codes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends otp_codesFindFirstArgs>(args?: SelectSubset<T, otp_codesFindFirstArgs<ExtArgs>>): Prisma__otp_codesClient<$Result.GetResult<Prisma.$otp_codesPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Otp_codes that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {otp_codesFindFirstOrThrowArgs} args - Arguments to find a Otp_codes
     * @example
     * // Get one Otp_codes
     * const otp_codes = await prisma.otp_codes.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends otp_codesFindFirstOrThrowArgs>(args?: SelectSubset<T, otp_codesFindFirstOrThrowArgs<ExtArgs>>): Prisma__otp_codesClient<$Result.GetResult<Prisma.$otp_codesPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Otp_codes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {otp_codesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Otp_codes
     * const otp_codes = await prisma.otp_codes.findMany()
     * 
     * // Get first 10 Otp_codes
     * const otp_codes = await prisma.otp_codes.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const otp_codesWithIdOnly = await prisma.otp_codes.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends otp_codesFindManyArgs>(args?: SelectSubset<T, otp_codesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$otp_codesPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Otp_codes.
     * @param {otp_codesCreateArgs} args - Arguments to create a Otp_codes.
     * @example
     * // Create one Otp_codes
     * const Otp_codes = await prisma.otp_codes.create({
     *   data: {
     *     // ... data to create a Otp_codes
     *   }
     * })
     * 
     */
    create<T extends otp_codesCreateArgs>(args: SelectSubset<T, otp_codesCreateArgs<ExtArgs>>): Prisma__otp_codesClient<$Result.GetResult<Prisma.$otp_codesPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Otp_codes.
     * @param {otp_codesCreateManyArgs} args - Arguments to create many Otp_codes.
     * @example
     * // Create many Otp_codes
     * const otp_codes = await prisma.otp_codes.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends otp_codesCreateManyArgs>(args?: SelectSubset<T, otp_codesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Otp_codes.
     * @param {otp_codesDeleteArgs} args - Arguments to delete one Otp_codes.
     * @example
     * // Delete one Otp_codes
     * const Otp_codes = await prisma.otp_codes.delete({
     *   where: {
     *     // ... filter to delete one Otp_codes
     *   }
     * })
     * 
     */
    delete<T extends otp_codesDeleteArgs>(args: SelectSubset<T, otp_codesDeleteArgs<ExtArgs>>): Prisma__otp_codesClient<$Result.GetResult<Prisma.$otp_codesPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Otp_codes.
     * @param {otp_codesUpdateArgs} args - Arguments to update one Otp_codes.
     * @example
     * // Update one Otp_codes
     * const otp_codes = await prisma.otp_codes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends otp_codesUpdateArgs>(args: SelectSubset<T, otp_codesUpdateArgs<ExtArgs>>): Prisma__otp_codesClient<$Result.GetResult<Prisma.$otp_codesPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Otp_codes.
     * @param {otp_codesDeleteManyArgs} args - Arguments to filter Otp_codes to delete.
     * @example
     * // Delete a few Otp_codes
     * const { count } = await prisma.otp_codes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends otp_codesDeleteManyArgs>(args?: SelectSubset<T, otp_codesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Otp_codes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {otp_codesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Otp_codes
     * const otp_codes = await prisma.otp_codes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends otp_codesUpdateManyArgs>(args: SelectSubset<T, otp_codesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Otp_codes.
     * @param {otp_codesUpsertArgs} args - Arguments to update or create a Otp_codes.
     * @example
     * // Update or create a Otp_codes
     * const otp_codes = await prisma.otp_codes.upsert({
     *   create: {
     *     // ... data to create a Otp_codes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Otp_codes we want to update
     *   }
     * })
     */
    upsert<T extends otp_codesUpsertArgs>(args: SelectSubset<T, otp_codesUpsertArgs<ExtArgs>>): Prisma__otp_codesClient<$Result.GetResult<Prisma.$otp_codesPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Otp_codes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {otp_codesCountArgs} args - Arguments to filter Otp_codes to count.
     * @example
     * // Count the number of Otp_codes
     * const count = await prisma.otp_codes.count({
     *   where: {
     *     // ... the filter for the Otp_codes we want to count
     *   }
     * })
    **/
    count<T extends otp_codesCountArgs>(
      args?: Subset<T, otp_codesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Otp_codesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Otp_codes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Otp_codesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Otp_codesAggregateArgs>(args: Subset<T, Otp_codesAggregateArgs>): Prisma.PrismaPromise<GetOtp_codesAggregateType<T>>

    /**
     * Group by Otp_codes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {otp_codesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends otp_codesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: otp_codesGroupByArgs['orderBy'] }
        : { orderBy?: otp_codesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, otp_codesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOtp_codesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the otp_codes model
   */
  readonly fields: otp_codesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for otp_codes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__otp_codesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the otp_codes model
   */ 
  interface otp_codesFieldRefs {
    readonly id: FieldRef<"otp_codes", 'Int'>
    readonly user_email: FieldRef<"otp_codes", 'String'>
    readonly kode_otp: FieldRef<"otp_codes", 'String'>
    readonly expired_at: FieldRef<"otp_codes", 'DateTime'>
    readonly digunakan: FieldRef<"otp_codes", 'Boolean'>
    readonly created_at: FieldRef<"otp_codes", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * otp_codes findUnique
   */
  export type otp_codesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the otp_codes
     */
    select?: otp_codesSelect<ExtArgs> | null
    /**
     * Filter, which otp_codes to fetch.
     */
    where: otp_codesWhereUniqueInput
  }

  /**
   * otp_codes findUniqueOrThrow
   */
  export type otp_codesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the otp_codes
     */
    select?: otp_codesSelect<ExtArgs> | null
    /**
     * Filter, which otp_codes to fetch.
     */
    where: otp_codesWhereUniqueInput
  }

  /**
   * otp_codes findFirst
   */
  export type otp_codesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the otp_codes
     */
    select?: otp_codesSelect<ExtArgs> | null
    /**
     * Filter, which otp_codes to fetch.
     */
    where?: otp_codesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of otp_codes to fetch.
     */
    orderBy?: otp_codesOrderByWithRelationInput | otp_codesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for otp_codes.
     */
    cursor?: otp_codesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` otp_codes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` otp_codes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of otp_codes.
     */
    distinct?: Otp_codesScalarFieldEnum | Otp_codesScalarFieldEnum[]
  }

  /**
   * otp_codes findFirstOrThrow
   */
  export type otp_codesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the otp_codes
     */
    select?: otp_codesSelect<ExtArgs> | null
    /**
     * Filter, which otp_codes to fetch.
     */
    where?: otp_codesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of otp_codes to fetch.
     */
    orderBy?: otp_codesOrderByWithRelationInput | otp_codesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for otp_codes.
     */
    cursor?: otp_codesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` otp_codes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` otp_codes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of otp_codes.
     */
    distinct?: Otp_codesScalarFieldEnum | Otp_codesScalarFieldEnum[]
  }

  /**
   * otp_codes findMany
   */
  export type otp_codesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the otp_codes
     */
    select?: otp_codesSelect<ExtArgs> | null
    /**
     * Filter, which otp_codes to fetch.
     */
    where?: otp_codesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of otp_codes to fetch.
     */
    orderBy?: otp_codesOrderByWithRelationInput | otp_codesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing otp_codes.
     */
    cursor?: otp_codesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` otp_codes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` otp_codes.
     */
    skip?: number
    distinct?: Otp_codesScalarFieldEnum | Otp_codesScalarFieldEnum[]
  }

  /**
   * otp_codes create
   */
  export type otp_codesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the otp_codes
     */
    select?: otp_codesSelect<ExtArgs> | null
    /**
     * The data needed to create a otp_codes.
     */
    data: XOR<otp_codesCreateInput, otp_codesUncheckedCreateInput>
  }

  /**
   * otp_codes createMany
   */
  export type otp_codesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many otp_codes.
     */
    data: otp_codesCreateManyInput | otp_codesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * otp_codes update
   */
  export type otp_codesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the otp_codes
     */
    select?: otp_codesSelect<ExtArgs> | null
    /**
     * The data needed to update a otp_codes.
     */
    data: XOR<otp_codesUpdateInput, otp_codesUncheckedUpdateInput>
    /**
     * Choose, which otp_codes to update.
     */
    where: otp_codesWhereUniqueInput
  }

  /**
   * otp_codes updateMany
   */
  export type otp_codesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update otp_codes.
     */
    data: XOR<otp_codesUpdateManyMutationInput, otp_codesUncheckedUpdateManyInput>
    /**
     * Filter which otp_codes to update
     */
    where?: otp_codesWhereInput
  }

  /**
   * otp_codes upsert
   */
  export type otp_codesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the otp_codes
     */
    select?: otp_codesSelect<ExtArgs> | null
    /**
     * The filter to search for the otp_codes to update in case it exists.
     */
    where: otp_codesWhereUniqueInput
    /**
     * In case the otp_codes found by the `where` argument doesn't exist, create a new otp_codes with this data.
     */
    create: XOR<otp_codesCreateInput, otp_codesUncheckedCreateInput>
    /**
     * In case the otp_codes was found with the provided `where` argument, update it with this data.
     */
    update: XOR<otp_codesUpdateInput, otp_codesUncheckedUpdateInput>
  }

  /**
   * otp_codes delete
   */
  export type otp_codesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the otp_codes
     */
    select?: otp_codesSelect<ExtArgs> | null
    /**
     * Filter which otp_codes to delete.
     */
    where: otp_codesWhereUniqueInput
  }

  /**
   * otp_codes deleteMany
   */
  export type otp_codesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which otp_codes to delete
     */
    where?: otp_codesWhereInput
  }

  /**
   * otp_codes without action
   */
  export type otp_codesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the otp_codes
     */
    select?: otp_codesSelect<ExtArgs> | null
  }


  /**
   * Model Lapangan
   */

  export type AggregateLapangan = {
    _count: LapanganCountAggregateOutputType | null
    _avg: LapanganAvgAggregateOutputType | null
    _sum: LapanganSumAggregateOutputType | null
    _min: LapanganMinAggregateOutputType | null
    _max: LapanganMaxAggregateOutputType | null
  }

  export type LapanganAvgAggregateOutputType = {
    id: number | null
    mitra_id: number | null
    harga: Decimal | null
    rating: number | null
  }

  export type LapanganSumAggregateOutputType = {
    id: number | null
    mitra_id: number | null
    harga: Decimal | null
    rating: number | null
  }

  export type LapanganMinAggregateOutputType = {
    id: number | null
    mitra_id: number | null
    nama: string | null
    slug: string | null
    lokasi: string | null
    harga: Decimal | null
    gambar: string | null
    rating: number | null
    status: $Enums.lapangan_status | null
    created_at: Date | null
  }

  export type LapanganMaxAggregateOutputType = {
    id: number | null
    mitra_id: number | null
    nama: string | null
    slug: string | null
    lokasi: string | null
    harga: Decimal | null
    gambar: string | null
    rating: number | null
    status: $Enums.lapangan_status | null
    created_at: Date | null
  }

  export type LapanganCountAggregateOutputType = {
    id: number
    mitra_id: number
    nama: number
    slug: number
    lokasi: number
    harga: number
    gambar: number
    rating: number
    status: number
    created_at: number
    _all: number
  }


  export type LapanganAvgAggregateInputType = {
    id?: true
    mitra_id?: true
    harga?: true
    rating?: true
  }

  export type LapanganSumAggregateInputType = {
    id?: true
    mitra_id?: true
    harga?: true
    rating?: true
  }

  export type LapanganMinAggregateInputType = {
    id?: true
    mitra_id?: true
    nama?: true
    slug?: true
    lokasi?: true
    harga?: true
    gambar?: true
    rating?: true
    status?: true
    created_at?: true
  }

  export type LapanganMaxAggregateInputType = {
    id?: true
    mitra_id?: true
    nama?: true
    slug?: true
    lokasi?: true
    harga?: true
    gambar?: true
    rating?: true
    status?: true
    created_at?: true
  }

  export type LapanganCountAggregateInputType = {
    id?: true
    mitra_id?: true
    nama?: true
    slug?: true
    lokasi?: true
    harga?: true
    gambar?: true
    rating?: true
    status?: true
    created_at?: true
    _all?: true
  }

  export type LapanganAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Lapangan to aggregate.
     */
    where?: LapanganWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lapangans to fetch.
     */
    orderBy?: LapanganOrderByWithRelationInput | LapanganOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LapanganWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lapangans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lapangans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Lapangans
    **/
    _count?: true | LapanganCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LapanganAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LapanganSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LapanganMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LapanganMaxAggregateInputType
  }

  export type GetLapanganAggregateType<T extends LapanganAggregateArgs> = {
        [P in keyof T & keyof AggregateLapangan]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLapangan[P]>
      : GetScalarType<T[P], AggregateLapangan[P]>
  }




  export type LapanganGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LapanganWhereInput
    orderBy?: LapanganOrderByWithAggregationInput | LapanganOrderByWithAggregationInput[]
    by: LapanganScalarFieldEnum[] | LapanganScalarFieldEnum
    having?: LapanganScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LapanganCountAggregateInputType | true
    _avg?: LapanganAvgAggregateInputType
    _sum?: LapanganSumAggregateInputType
    _min?: LapanganMinAggregateInputType
    _max?: LapanganMaxAggregateInputType
  }

  export type LapanganGroupByOutputType = {
    id: number
    mitra_id: number
    nama: string
    slug: string
    lokasi: string | null
    harga: Decimal
    gambar: string | null
    rating: number | null
    status: $Enums.lapangan_status
    created_at: Date
    _count: LapanganCountAggregateOutputType | null
    _avg: LapanganAvgAggregateOutputType | null
    _sum: LapanganSumAggregateOutputType | null
    _min: LapanganMinAggregateOutputType | null
    _max: LapanganMaxAggregateOutputType | null
  }

  type GetLapanganGroupByPayload<T extends LapanganGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LapanganGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LapanganGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LapanganGroupByOutputType[P]>
            : GetScalarType<T[P], LapanganGroupByOutputType[P]>
        }
      >
    >


  export type LapanganSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    mitra_id?: boolean
    nama?: boolean
    slug?: boolean
    lokasi?: boolean
    harga?: boolean
    gambar?: boolean
    rating?: boolean
    status?: boolean
    created_at?: boolean
    mitra?: boolean | MitraDefaultArgs<ExtArgs>
    detail?: boolean | Lapangan$detailArgs<ExtArgs>
    gambarList?: boolean | Lapangan$gambarListArgs<ExtArgs>
    jadwal?: boolean | Lapangan$jadwalArgs<ExtArgs>
    orders?: boolean | Lapangan$ordersArgs<ExtArgs>
    transaksi?: boolean | Lapangan$transaksiArgs<ExtArgs>
    ulasan?: boolean | Lapangan$ulasanArgs<ExtArgs>
    _count?: boolean | LapanganCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lapangan"]>


  export type LapanganSelectScalar = {
    id?: boolean
    mitra_id?: boolean
    nama?: boolean
    slug?: boolean
    lokasi?: boolean
    harga?: boolean
    gambar?: boolean
    rating?: boolean
    status?: boolean
    created_at?: boolean
  }

  export type LapanganInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mitra?: boolean | MitraDefaultArgs<ExtArgs>
    detail?: boolean | Lapangan$detailArgs<ExtArgs>
    gambarList?: boolean | Lapangan$gambarListArgs<ExtArgs>
    jadwal?: boolean | Lapangan$jadwalArgs<ExtArgs>
    orders?: boolean | Lapangan$ordersArgs<ExtArgs>
    transaksi?: boolean | Lapangan$transaksiArgs<ExtArgs>
    ulasan?: boolean | Lapangan$ulasanArgs<ExtArgs>
    _count?: boolean | LapanganCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $LapanganPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Lapangan"
    objects: {
      mitra: Prisma.$MitraPayload<ExtArgs>
      detail: Prisma.$LapanganDetailPayload<ExtArgs> | null
      gambarList: Prisma.$LapanganGambarPayload<ExtArgs>[]
      jadwal: Prisma.$JadwalLapanganPayload<ExtArgs>[]
      orders: Prisma.$order_bookingPayload<ExtArgs>[]
      transaksi: Prisma.$transaksiPayload<ExtArgs>[]
      ulasan: Prisma.$ulasanPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      mitra_id: number
      nama: string
      slug: string
      lokasi: string | null
      harga: Prisma.Decimal
      gambar: string | null
      rating: number | null
      status: $Enums.lapangan_status
      created_at: Date
    }, ExtArgs["result"]["lapangan"]>
    composites: {}
  }

  type LapanganGetPayload<S extends boolean | null | undefined | LapanganDefaultArgs> = $Result.GetResult<Prisma.$LapanganPayload, S>

  type LapanganCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<LapanganFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: LapanganCountAggregateInputType | true
    }

  export interface LapanganDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Lapangan'], meta: { name: 'Lapangan' } }
    /**
     * Find zero or one Lapangan that matches the filter.
     * @param {LapanganFindUniqueArgs} args - Arguments to find a Lapangan
     * @example
     * // Get one Lapangan
     * const lapangan = await prisma.lapangan.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LapanganFindUniqueArgs>(args: SelectSubset<T, LapanganFindUniqueArgs<ExtArgs>>): Prisma__LapanganClient<$Result.GetResult<Prisma.$LapanganPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Lapangan that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {LapanganFindUniqueOrThrowArgs} args - Arguments to find a Lapangan
     * @example
     * // Get one Lapangan
     * const lapangan = await prisma.lapangan.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LapanganFindUniqueOrThrowArgs>(args: SelectSubset<T, LapanganFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LapanganClient<$Result.GetResult<Prisma.$LapanganPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Lapangan that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LapanganFindFirstArgs} args - Arguments to find a Lapangan
     * @example
     * // Get one Lapangan
     * const lapangan = await prisma.lapangan.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LapanganFindFirstArgs>(args?: SelectSubset<T, LapanganFindFirstArgs<ExtArgs>>): Prisma__LapanganClient<$Result.GetResult<Prisma.$LapanganPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Lapangan that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LapanganFindFirstOrThrowArgs} args - Arguments to find a Lapangan
     * @example
     * // Get one Lapangan
     * const lapangan = await prisma.lapangan.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LapanganFindFirstOrThrowArgs>(args?: SelectSubset<T, LapanganFindFirstOrThrowArgs<ExtArgs>>): Prisma__LapanganClient<$Result.GetResult<Prisma.$LapanganPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Lapangans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LapanganFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Lapangans
     * const lapangans = await prisma.lapangan.findMany()
     * 
     * // Get first 10 Lapangans
     * const lapangans = await prisma.lapangan.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const lapanganWithIdOnly = await prisma.lapangan.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LapanganFindManyArgs>(args?: SelectSubset<T, LapanganFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LapanganPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Lapangan.
     * @param {LapanganCreateArgs} args - Arguments to create a Lapangan.
     * @example
     * // Create one Lapangan
     * const Lapangan = await prisma.lapangan.create({
     *   data: {
     *     // ... data to create a Lapangan
     *   }
     * })
     * 
     */
    create<T extends LapanganCreateArgs>(args: SelectSubset<T, LapanganCreateArgs<ExtArgs>>): Prisma__LapanganClient<$Result.GetResult<Prisma.$LapanganPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Lapangans.
     * @param {LapanganCreateManyArgs} args - Arguments to create many Lapangans.
     * @example
     * // Create many Lapangans
     * const lapangan = await prisma.lapangan.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LapanganCreateManyArgs>(args?: SelectSubset<T, LapanganCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Lapangan.
     * @param {LapanganDeleteArgs} args - Arguments to delete one Lapangan.
     * @example
     * // Delete one Lapangan
     * const Lapangan = await prisma.lapangan.delete({
     *   where: {
     *     // ... filter to delete one Lapangan
     *   }
     * })
     * 
     */
    delete<T extends LapanganDeleteArgs>(args: SelectSubset<T, LapanganDeleteArgs<ExtArgs>>): Prisma__LapanganClient<$Result.GetResult<Prisma.$LapanganPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Lapangan.
     * @param {LapanganUpdateArgs} args - Arguments to update one Lapangan.
     * @example
     * // Update one Lapangan
     * const lapangan = await prisma.lapangan.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LapanganUpdateArgs>(args: SelectSubset<T, LapanganUpdateArgs<ExtArgs>>): Prisma__LapanganClient<$Result.GetResult<Prisma.$LapanganPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Lapangans.
     * @param {LapanganDeleteManyArgs} args - Arguments to filter Lapangans to delete.
     * @example
     * // Delete a few Lapangans
     * const { count } = await prisma.lapangan.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LapanganDeleteManyArgs>(args?: SelectSubset<T, LapanganDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Lapangans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LapanganUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Lapangans
     * const lapangan = await prisma.lapangan.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LapanganUpdateManyArgs>(args: SelectSubset<T, LapanganUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Lapangan.
     * @param {LapanganUpsertArgs} args - Arguments to update or create a Lapangan.
     * @example
     * // Update or create a Lapangan
     * const lapangan = await prisma.lapangan.upsert({
     *   create: {
     *     // ... data to create a Lapangan
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Lapangan we want to update
     *   }
     * })
     */
    upsert<T extends LapanganUpsertArgs>(args: SelectSubset<T, LapanganUpsertArgs<ExtArgs>>): Prisma__LapanganClient<$Result.GetResult<Prisma.$LapanganPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Lapangans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LapanganCountArgs} args - Arguments to filter Lapangans to count.
     * @example
     * // Count the number of Lapangans
     * const count = await prisma.lapangan.count({
     *   where: {
     *     // ... the filter for the Lapangans we want to count
     *   }
     * })
    **/
    count<T extends LapanganCountArgs>(
      args?: Subset<T, LapanganCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LapanganCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Lapangan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LapanganAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LapanganAggregateArgs>(args: Subset<T, LapanganAggregateArgs>): Prisma.PrismaPromise<GetLapanganAggregateType<T>>

    /**
     * Group by Lapangan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LapanganGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LapanganGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LapanganGroupByArgs['orderBy'] }
        : { orderBy?: LapanganGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LapanganGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLapanganGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Lapangan model
   */
  readonly fields: LapanganFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Lapangan.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LapanganClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    mitra<T extends MitraDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MitraDefaultArgs<ExtArgs>>): Prisma__MitraClient<$Result.GetResult<Prisma.$MitraPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    detail<T extends Lapangan$detailArgs<ExtArgs> = {}>(args?: Subset<T, Lapangan$detailArgs<ExtArgs>>): Prisma__LapanganDetailClient<$Result.GetResult<Prisma.$LapanganDetailPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    gambarList<T extends Lapangan$gambarListArgs<ExtArgs> = {}>(args?: Subset<T, Lapangan$gambarListArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LapanganGambarPayload<ExtArgs>, T, "findMany"> | Null>
    jadwal<T extends Lapangan$jadwalArgs<ExtArgs> = {}>(args?: Subset<T, Lapangan$jadwalArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JadwalLapanganPayload<ExtArgs>, T, "findMany"> | Null>
    orders<T extends Lapangan$ordersArgs<ExtArgs> = {}>(args?: Subset<T, Lapangan$ordersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$order_bookingPayload<ExtArgs>, T, "findMany"> | Null>
    transaksi<T extends Lapangan$transaksiArgs<ExtArgs> = {}>(args?: Subset<T, Lapangan$transaksiArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$transaksiPayload<ExtArgs>, T, "findMany"> | Null>
    ulasan<T extends Lapangan$ulasanArgs<ExtArgs> = {}>(args?: Subset<T, Lapangan$ulasanArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ulasanPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Lapangan model
   */ 
  interface LapanganFieldRefs {
    readonly id: FieldRef<"Lapangan", 'Int'>
    readonly mitra_id: FieldRef<"Lapangan", 'Int'>
    readonly nama: FieldRef<"Lapangan", 'String'>
    readonly slug: FieldRef<"Lapangan", 'String'>
    readonly lokasi: FieldRef<"Lapangan", 'String'>
    readonly harga: FieldRef<"Lapangan", 'Decimal'>
    readonly gambar: FieldRef<"Lapangan", 'String'>
    readonly rating: FieldRef<"Lapangan", 'Float'>
    readonly status: FieldRef<"Lapangan", 'lapangan_status'>
    readonly created_at: FieldRef<"Lapangan", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Lapangan findUnique
   */
  export type LapanganFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lapangan
     */
    select?: LapanganSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LapanganInclude<ExtArgs> | null
    /**
     * Filter, which Lapangan to fetch.
     */
    where: LapanganWhereUniqueInput
  }

  /**
   * Lapangan findUniqueOrThrow
   */
  export type LapanganFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lapangan
     */
    select?: LapanganSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LapanganInclude<ExtArgs> | null
    /**
     * Filter, which Lapangan to fetch.
     */
    where: LapanganWhereUniqueInput
  }

  /**
   * Lapangan findFirst
   */
  export type LapanganFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lapangan
     */
    select?: LapanganSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LapanganInclude<ExtArgs> | null
    /**
     * Filter, which Lapangan to fetch.
     */
    where?: LapanganWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lapangans to fetch.
     */
    orderBy?: LapanganOrderByWithRelationInput | LapanganOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Lapangans.
     */
    cursor?: LapanganWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lapangans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lapangans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Lapangans.
     */
    distinct?: LapanganScalarFieldEnum | LapanganScalarFieldEnum[]
  }

  /**
   * Lapangan findFirstOrThrow
   */
  export type LapanganFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lapangan
     */
    select?: LapanganSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LapanganInclude<ExtArgs> | null
    /**
     * Filter, which Lapangan to fetch.
     */
    where?: LapanganWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lapangans to fetch.
     */
    orderBy?: LapanganOrderByWithRelationInput | LapanganOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Lapangans.
     */
    cursor?: LapanganWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lapangans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lapangans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Lapangans.
     */
    distinct?: LapanganScalarFieldEnum | LapanganScalarFieldEnum[]
  }

  /**
   * Lapangan findMany
   */
  export type LapanganFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lapangan
     */
    select?: LapanganSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LapanganInclude<ExtArgs> | null
    /**
     * Filter, which Lapangans to fetch.
     */
    where?: LapanganWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lapangans to fetch.
     */
    orderBy?: LapanganOrderByWithRelationInput | LapanganOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Lapangans.
     */
    cursor?: LapanganWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lapangans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lapangans.
     */
    skip?: number
    distinct?: LapanganScalarFieldEnum | LapanganScalarFieldEnum[]
  }

  /**
   * Lapangan create
   */
  export type LapanganCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lapangan
     */
    select?: LapanganSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LapanganInclude<ExtArgs> | null
    /**
     * The data needed to create a Lapangan.
     */
    data: XOR<LapanganCreateInput, LapanganUncheckedCreateInput>
  }

  /**
   * Lapangan createMany
   */
  export type LapanganCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Lapangans.
     */
    data: LapanganCreateManyInput | LapanganCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Lapangan update
   */
  export type LapanganUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lapangan
     */
    select?: LapanganSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LapanganInclude<ExtArgs> | null
    /**
     * The data needed to update a Lapangan.
     */
    data: XOR<LapanganUpdateInput, LapanganUncheckedUpdateInput>
    /**
     * Choose, which Lapangan to update.
     */
    where: LapanganWhereUniqueInput
  }

  /**
   * Lapangan updateMany
   */
  export type LapanganUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Lapangans.
     */
    data: XOR<LapanganUpdateManyMutationInput, LapanganUncheckedUpdateManyInput>
    /**
     * Filter which Lapangans to update
     */
    where?: LapanganWhereInput
  }

  /**
   * Lapangan upsert
   */
  export type LapanganUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lapangan
     */
    select?: LapanganSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LapanganInclude<ExtArgs> | null
    /**
     * The filter to search for the Lapangan to update in case it exists.
     */
    where: LapanganWhereUniqueInput
    /**
     * In case the Lapangan found by the `where` argument doesn't exist, create a new Lapangan with this data.
     */
    create: XOR<LapanganCreateInput, LapanganUncheckedCreateInput>
    /**
     * In case the Lapangan was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LapanganUpdateInput, LapanganUncheckedUpdateInput>
  }

  /**
   * Lapangan delete
   */
  export type LapanganDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lapangan
     */
    select?: LapanganSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LapanganInclude<ExtArgs> | null
    /**
     * Filter which Lapangan to delete.
     */
    where: LapanganWhereUniqueInput
  }

  /**
   * Lapangan deleteMany
   */
  export type LapanganDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Lapangans to delete
     */
    where?: LapanganWhereInput
  }

  /**
   * Lapangan.detail
   */
  export type Lapangan$detailArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LapanganDetail
     */
    select?: LapanganDetailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LapanganDetailInclude<ExtArgs> | null
    where?: LapanganDetailWhereInput
  }

  /**
   * Lapangan.gambarList
   */
  export type Lapangan$gambarListArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LapanganGambar
     */
    select?: LapanganGambarSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LapanganGambarInclude<ExtArgs> | null
    where?: LapanganGambarWhereInput
    orderBy?: LapanganGambarOrderByWithRelationInput | LapanganGambarOrderByWithRelationInput[]
    cursor?: LapanganGambarWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LapanganGambarScalarFieldEnum | LapanganGambarScalarFieldEnum[]
  }

  /**
   * Lapangan.jadwal
   */
  export type Lapangan$jadwalArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JadwalLapangan
     */
    select?: JadwalLapanganSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JadwalLapanganInclude<ExtArgs> | null
    where?: JadwalLapanganWhereInput
    orderBy?: JadwalLapanganOrderByWithRelationInput | JadwalLapanganOrderByWithRelationInput[]
    cursor?: JadwalLapanganWhereUniqueInput
    take?: number
    skip?: number
    distinct?: JadwalLapanganScalarFieldEnum | JadwalLapanganScalarFieldEnum[]
  }

  /**
   * Lapangan.orders
   */
  export type Lapangan$ordersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order_booking
     */
    select?: order_bookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: order_bookingInclude<ExtArgs> | null
    where?: order_bookingWhereInput
    orderBy?: order_bookingOrderByWithRelationInput | order_bookingOrderByWithRelationInput[]
    cursor?: order_bookingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Order_bookingScalarFieldEnum | Order_bookingScalarFieldEnum[]
  }

  /**
   * Lapangan.transaksi
   */
  export type Lapangan$transaksiArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transaksi
     */
    select?: transaksiSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transaksiInclude<ExtArgs> | null
    where?: transaksiWhereInput
    orderBy?: transaksiOrderByWithRelationInput | transaksiOrderByWithRelationInput[]
    cursor?: transaksiWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransaksiScalarFieldEnum | TransaksiScalarFieldEnum[]
  }

  /**
   * Lapangan.ulasan
   */
  export type Lapangan$ulasanArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ulasan
     */
    select?: ulasanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ulasanInclude<ExtArgs> | null
    where?: ulasanWhereInput
    orderBy?: ulasanOrderByWithRelationInput | ulasanOrderByWithRelationInput[]
    cursor?: ulasanWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UlasanScalarFieldEnum | UlasanScalarFieldEnum[]
  }

  /**
   * Lapangan without action
   */
  export type LapanganDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lapangan
     */
    select?: LapanganSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LapanganInclude<ExtArgs> | null
  }


  /**
   * Model LapanganDetail
   */

  export type AggregateLapanganDetail = {
    _count: LapanganDetailCountAggregateOutputType | null
    _avg: LapanganDetailAvgAggregateOutputType | null
    _sum: LapanganDetailSumAggregateOutputType | null
    _min: LapanganDetailMinAggregateOutputType | null
    _max: LapanganDetailMaxAggregateOutputType | null
  }

  export type LapanganDetailAvgAggregateOutputType = {
    id: number | null
    lapangan_id: number | null
    interval: number | null
    breakTime: number | null
  }

  export type LapanganDetailSumAggregateOutputType = {
    id: number | null
    lapangan_id: number | null
    interval: number | null
    breakTime: number | null
  }

  export type LapanganDetailMinAggregateOutputType = {
    id: number | null
    lapangan_id: number | null
    alamat: string | null
    maps: string | null
    deskripsi: string | null
    type: string | null
    interval: number | null
    breakTime: number | null
  }

  export type LapanganDetailMaxAggregateOutputType = {
    id: number | null
    lapangan_id: number | null
    alamat: string | null
    maps: string | null
    deskripsi: string | null
    type: string | null
    interval: number | null
    breakTime: number | null
  }

  export type LapanganDetailCountAggregateOutputType = {
    id: number
    lapangan_id: number
    alamat: number
    maps: number
    deskripsi: number
    type: number
    fasilitas: number
    interval: number
    breakTime: number
    _all: number
  }


  export type LapanganDetailAvgAggregateInputType = {
    id?: true
    lapangan_id?: true
    interval?: true
    breakTime?: true
  }

  export type LapanganDetailSumAggregateInputType = {
    id?: true
    lapangan_id?: true
    interval?: true
    breakTime?: true
  }

  export type LapanganDetailMinAggregateInputType = {
    id?: true
    lapangan_id?: true
    alamat?: true
    maps?: true
    deskripsi?: true
    type?: true
    interval?: true
    breakTime?: true
  }

  export type LapanganDetailMaxAggregateInputType = {
    id?: true
    lapangan_id?: true
    alamat?: true
    maps?: true
    deskripsi?: true
    type?: true
    interval?: true
    breakTime?: true
  }

  export type LapanganDetailCountAggregateInputType = {
    id?: true
    lapangan_id?: true
    alamat?: true
    maps?: true
    deskripsi?: true
    type?: true
    fasilitas?: true
    interval?: true
    breakTime?: true
    _all?: true
  }

  export type LapanganDetailAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LapanganDetail to aggregate.
     */
    where?: LapanganDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LapanganDetails to fetch.
     */
    orderBy?: LapanganDetailOrderByWithRelationInput | LapanganDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LapanganDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LapanganDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LapanganDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LapanganDetails
    **/
    _count?: true | LapanganDetailCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LapanganDetailAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LapanganDetailSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LapanganDetailMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LapanganDetailMaxAggregateInputType
  }

  export type GetLapanganDetailAggregateType<T extends LapanganDetailAggregateArgs> = {
        [P in keyof T & keyof AggregateLapanganDetail]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLapanganDetail[P]>
      : GetScalarType<T[P], AggregateLapanganDetail[P]>
  }




  export type LapanganDetailGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LapanganDetailWhereInput
    orderBy?: LapanganDetailOrderByWithAggregationInput | LapanganDetailOrderByWithAggregationInput[]
    by: LapanganDetailScalarFieldEnum[] | LapanganDetailScalarFieldEnum
    having?: LapanganDetailScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LapanganDetailCountAggregateInputType | true
    _avg?: LapanganDetailAvgAggregateInputType
    _sum?: LapanganDetailSumAggregateInputType
    _min?: LapanganDetailMinAggregateInputType
    _max?: LapanganDetailMaxAggregateInputType
  }

  export type LapanganDetailGroupByOutputType = {
    id: number
    lapangan_id: number
    alamat: string
    maps: string
    deskripsi: string
    type: string
    fasilitas: JsonValue
    interval: number
    breakTime: number
    _count: LapanganDetailCountAggregateOutputType | null
    _avg: LapanganDetailAvgAggregateOutputType | null
    _sum: LapanganDetailSumAggregateOutputType | null
    _min: LapanganDetailMinAggregateOutputType | null
    _max: LapanganDetailMaxAggregateOutputType | null
  }

  type GetLapanganDetailGroupByPayload<T extends LapanganDetailGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LapanganDetailGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LapanganDetailGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LapanganDetailGroupByOutputType[P]>
            : GetScalarType<T[P], LapanganDetailGroupByOutputType[P]>
        }
      >
    >


  export type LapanganDetailSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    lapangan_id?: boolean
    alamat?: boolean
    maps?: boolean
    deskripsi?: boolean
    type?: boolean
    fasilitas?: boolean
    interval?: boolean
    breakTime?: boolean
    lapangan?: boolean | LapanganDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lapanganDetail"]>


  export type LapanganDetailSelectScalar = {
    id?: boolean
    lapangan_id?: boolean
    alamat?: boolean
    maps?: boolean
    deskripsi?: boolean
    type?: boolean
    fasilitas?: boolean
    interval?: boolean
    breakTime?: boolean
  }

  export type LapanganDetailInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lapangan?: boolean | LapanganDefaultArgs<ExtArgs>
  }

  export type $LapanganDetailPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LapanganDetail"
    objects: {
      lapangan: Prisma.$LapanganPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      lapangan_id: number
      alamat: string
      maps: string
      deskripsi: string
      type: string
      fasilitas: Prisma.JsonValue
      interval: number
      breakTime: number
    }, ExtArgs["result"]["lapanganDetail"]>
    composites: {}
  }

  type LapanganDetailGetPayload<S extends boolean | null | undefined | LapanganDetailDefaultArgs> = $Result.GetResult<Prisma.$LapanganDetailPayload, S>

  type LapanganDetailCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<LapanganDetailFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: LapanganDetailCountAggregateInputType | true
    }

  export interface LapanganDetailDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LapanganDetail'], meta: { name: 'LapanganDetail' } }
    /**
     * Find zero or one LapanganDetail that matches the filter.
     * @param {LapanganDetailFindUniqueArgs} args - Arguments to find a LapanganDetail
     * @example
     * // Get one LapanganDetail
     * const lapanganDetail = await prisma.lapanganDetail.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LapanganDetailFindUniqueArgs>(args: SelectSubset<T, LapanganDetailFindUniqueArgs<ExtArgs>>): Prisma__LapanganDetailClient<$Result.GetResult<Prisma.$LapanganDetailPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one LapanganDetail that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {LapanganDetailFindUniqueOrThrowArgs} args - Arguments to find a LapanganDetail
     * @example
     * // Get one LapanganDetail
     * const lapanganDetail = await prisma.lapanganDetail.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LapanganDetailFindUniqueOrThrowArgs>(args: SelectSubset<T, LapanganDetailFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LapanganDetailClient<$Result.GetResult<Prisma.$LapanganDetailPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first LapanganDetail that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LapanganDetailFindFirstArgs} args - Arguments to find a LapanganDetail
     * @example
     * // Get one LapanganDetail
     * const lapanganDetail = await prisma.lapanganDetail.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LapanganDetailFindFirstArgs>(args?: SelectSubset<T, LapanganDetailFindFirstArgs<ExtArgs>>): Prisma__LapanganDetailClient<$Result.GetResult<Prisma.$LapanganDetailPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first LapanganDetail that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LapanganDetailFindFirstOrThrowArgs} args - Arguments to find a LapanganDetail
     * @example
     * // Get one LapanganDetail
     * const lapanganDetail = await prisma.lapanganDetail.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LapanganDetailFindFirstOrThrowArgs>(args?: SelectSubset<T, LapanganDetailFindFirstOrThrowArgs<ExtArgs>>): Prisma__LapanganDetailClient<$Result.GetResult<Prisma.$LapanganDetailPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more LapanganDetails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LapanganDetailFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LapanganDetails
     * const lapanganDetails = await prisma.lapanganDetail.findMany()
     * 
     * // Get first 10 LapanganDetails
     * const lapanganDetails = await prisma.lapanganDetail.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const lapanganDetailWithIdOnly = await prisma.lapanganDetail.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LapanganDetailFindManyArgs>(args?: SelectSubset<T, LapanganDetailFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LapanganDetailPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a LapanganDetail.
     * @param {LapanganDetailCreateArgs} args - Arguments to create a LapanganDetail.
     * @example
     * // Create one LapanganDetail
     * const LapanganDetail = await prisma.lapanganDetail.create({
     *   data: {
     *     // ... data to create a LapanganDetail
     *   }
     * })
     * 
     */
    create<T extends LapanganDetailCreateArgs>(args: SelectSubset<T, LapanganDetailCreateArgs<ExtArgs>>): Prisma__LapanganDetailClient<$Result.GetResult<Prisma.$LapanganDetailPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many LapanganDetails.
     * @param {LapanganDetailCreateManyArgs} args - Arguments to create many LapanganDetails.
     * @example
     * // Create many LapanganDetails
     * const lapanganDetail = await prisma.lapanganDetail.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LapanganDetailCreateManyArgs>(args?: SelectSubset<T, LapanganDetailCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a LapanganDetail.
     * @param {LapanganDetailDeleteArgs} args - Arguments to delete one LapanganDetail.
     * @example
     * // Delete one LapanganDetail
     * const LapanganDetail = await prisma.lapanganDetail.delete({
     *   where: {
     *     // ... filter to delete one LapanganDetail
     *   }
     * })
     * 
     */
    delete<T extends LapanganDetailDeleteArgs>(args: SelectSubset<T, LapanganDetailDeleteArgs<ExtArgs>>): Prisma__LapanganDetailClient<$Result.GetResult<Prisma.$LapanganDetailPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one LapanganDetail.
     * @param {LapanganDetailUpdateArgs} args - Arguments to update one LapanganDetail.
     * @example
     * // Update one LapanganDetail
     * const lapanganDetail = await prisma.lapanganDetail.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LapanganDetailUpdateArgs>(args: SelectSubset<T, LapanganDetailUpdateArgs<ExtArgs>>): Prisma__LapanganDetailClient<$Result.GetResult<Prisma.$LapanganDetailPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more LapanganDetails.
     * @param {LapanganDetailDeleteManyArgs} args - Arguments to filter LapanganDetails to delete.
     * @example
     * // Delete a few LapanganDetails
     * const { count } = await prisma.lapanganDetail.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LapanganDetailDeleteManyArgs>(args?: SelectSubset<T, LapanganDetailDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LapanganDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LapanganDetailUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LapanganDetails
     * const lapanganDetail = await prisma.lapanganDetail.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LapanganDetailUpdateManyArgs>(args: SelectSubset<T, LapanganDetailUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one LapanganDetail.
     * @param {LapanganDetailUpsertArgs} args - Arguments to update or create a LapanganDetail.
     * @example
     * // Update or create a LapanganDetail
     * const lapanganDetail = await prisma.lapanganDetail.upsert({
     *   create: {
     *     // ... data to create a LapanganDetail
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LapanganDetail we want to update
     *   }
     * })
     */
    upsert<T extends LapanganDetailUpsertArgs>(args: SelectSubset<T, LapanganDetailUpsertArgs<ExtArgs>>): Prisma__LapanganDetailClient<$Result.GetResult<Prisma.$LapanganDetailPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of LapanganDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LapanganDetailCountArgs} args - Arguments to filter LapanganDetails to count.
     * @example
     * // Count the number of LapanganDetails
     * const count = await prisma.lapanganDetail.count({
     *   where: {
     *     // ... the filter for the LapanganDetails we want to count
     *   }
     * })
    **/
    count<T extends LapanganDetailCountArgs>(
      args?: Subset<T, LapanganDetailCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LapanganDetailCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LapanganDetail.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LapanganDetailAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LapanganDetailAggregateArgs>(args: Subset<T, LapanganDetailAggregateArgs>): Prisma.PrismaPromise<GetLapanganDetailAggregateType<T>>

    /**
     * Group by LapanganDetail.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LapanganDetailGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LapanganDetailGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LapanganDetailGroupByArgs['orderBy'] }
        : { orderBy?: LapanganDetailGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LapanganDetailGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLapanganDetailGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LapanganDetail model
   */
  readonly fields: LapanganDetailFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LapanganDetail.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LapanganDetailClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    lapangan<T extends LapanganDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LapanganDefaultArgs<ExtArgs>>): Prisma__LapanganClient<$Result.GetResult<Prisma.$LapanganPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LapanganDetail model
   */ 
  interface LapanganDetailFieldRefs {
    readonly id: FieldRef<"LapanganDetail", 'Int'>
    readonly lapangan_id: FieldRef<"LapanganDetail", 'Int'>
    readonly alamat: FieldRef<"LapanganDetail", 'String'>
    readonly maps: FieldRef<"LapanganDetail", 'String'>
    readonly deskripsi: FieldRef<"LapanganDetail", 'String'>
    readonly type: FieldRef<"LapanganDetail", 'String'>
    readonly fasilitas: FieldRef<"LapanganDetail", 'Json'>
    readonly interval: FieldRef<"LapanganDetail", 'Int'>
    readonly breakTime: FieldRef<"LapanganDetail", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * LapanganDetail findUnique
   */
  export type LapanganDetailFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LapanganDetail
     */
    select?: LapanganDetailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LapanganDetailInclude<ExtArgs> | null
    /**
     * Filter, which LapanganDetail to fetch.
     */
    where: LapanganDetailWhereUniqueInput
  }

  /**
   * LapanganDetail findUniqueOrThrow
   */
  export type LapanganDetailFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LapanganDetail
     */
    select?: LapanganDetailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LapanganDetailInclude<ExtArgs> | null
    /**
     * Filter, which LapanganDetail to fetch.
     */
    where: LapanganDetailWhereUniqueInput
  }

  /**
   * LapanganDetail findFirst
   */
  export type LapanganDetailFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LapanganDetail
     */
    select?: LapanganDetailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LapanganDetailInclude<ExtArgs> | null
    /**
     * Filter, which LapanganDetail to fetch.
     */
    where?: LapanganDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LapanganDetails to fetch.
     */
    orderBy?: LapanganDetailOrderByWithRelationInput | LapanganDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LapanganDetails.
     */
    cursor?: LapanganDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LapanganDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LapanganDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LapanganDetails.
     */
    distinct?: LapanganDetailScalarFieldEnum | LapanganDetailScalarFieldEnum[]
  }

  /**
   * LapanganDetail findFirstOrThrow
   */
  export type LapanganDetailFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LapanganDetail
     */
    select?: LapanganDetailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LapanganDetailInclude<ExtArgs> | null
    /**
     * Filter, which LapanganDetail to fetch.
     */
    where?: LapanganDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LapanganDetails to fetch.
     */
    orderBy?: LapanganDetailOrderByWithRelationInput | LapanganDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LapanganDetails.
     */
    cursor?: LapanganDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LapanganDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LapanganDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LapanganDetails.
     */
    distinct?: LapanganDetailScalarFieldEnum | LapanganDetailScalarFieldEnum[]
  }

  /**
   * LapanganDetail findMany
   */
  export type LapanganDetailFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LapanganDetail
     */
    select?: LapanganDetailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LapanganDetailInclude<ExtArgs> | null
    /**
     * Filter, which LapanganDetails to fetch.
     */
    where?: LapanganDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LapanganDetails to fetch.
     */
    orderBy?: LapanganDetailOrderByWithRelationInput | LapanganDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LapanganDetails.
     */
    cursor?: LapanganDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LapanganDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LapanganDetails.
     */
    skip?: number
    distinct?: LapanganDetailScalarFieldEnum | LapanganDetailScalarFieldEnum[]
  }

  /**
   * LapanganDetail create
   */
  export type LapanganDetailCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LapanganDetail
     */
    select?: LapanganDetailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LapanganDetailInclude<ExtArgs> | null
    /**
     * The data needed to create a LapanganDetail.
     */
    data: XOR<LapanganDetailCreateInput, LapanganDetailUncheckedCreateInput>
  }

  /**
   * LapanganDetail createMany
   */
  export type LapanganDetailCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LapanganDetails.
     */
    data: LapanganDetailCreateManyInput | LapanganDetailCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LapanganDetail update
   */
  export type LapanganDetailUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LapanganDetail
     */
    select?: LapanganDetailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LapanganDetailInclude<ExtArgs> | null
    /**
     * The data needed to update a LapanganDetail.
     */
    data: XOR<LapanganDetailUpdateInput, LapanganDetailUncheckedUpdateInput>
    /**
     * Choose, which LapanganDetail to update.
     */
    where: LapanganDetailWhereUniqueInput
  }

  /**
   * LapanganDetail updateMany
   */
  export type LapanganDetailUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LapanganDetails.
     */
    data: XOR<LapanganDetailUpdateManyMutationInput, LapanganDetailUncheckedUpdateManyInput>
    /**
     * Filter which LapanganDetails to update
     */
    where?: LapanganDetailWhereInput
  }

  /**
   * LapanganDetail upsert
   */
  export type LapanganDetailUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LapanganDetail
     */
    select?: LapanganDetailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LapanganDetailInclude<ExtArgs> | null
    /**
     * The filter to search for the LapanganDetail to update in case it exists.
     */
    where: LapanganDetailWhereUniqueInput
    /**
     * In case the LapanganDetail found by the `where` argument doesn't exist, create a new LapanganDetail with this data.
     */
    create: XOR<LapanganDetailCreateInput, LapanganDetailUncheckedCreateInput>
    /**
     * In case the LapanganDetail was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LapanganDetailUpdateInput, LapanganDetailUncheckedUpdateInput>
  }

  /**
   * LapanganDetail delete
   */
  export type LapanganDetailDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LapanganDetail
     */
    select?: LapanganDetailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LapanganDetailInclude<ExtArgs> | null
    /**
     * Filter which LapanganDetail to delete.
     */
    where: LapanganDetailWhereUniqueInput
  }

  /**
   * LapanganDetail deleteMany
   */
  export type LapanganDetailDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LapanganDetails to delete
     */
    where?: LapanganDetailWhereInput
  }

  /**
   * LapanganDetail without action
   */
  export type LapanganDetailDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LapanganDetail
     */
    select?: LapanganDetailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LapanganDetailInclude<ExtArgs> | null
  }


  /**
   * Model LapanganGambar
   */

  export type AggregateLapanganGambar = {
    _count: LapanganGambarCountAggregateOutputType | null
    _avg: LapanganGambarAvgAggregateOutputType | null
    _sum: LapanganGambarSumAggregateOutputType | null
    _min: LapanganGambarMinAggregateOutputType | null
    _max: LapanganGambarMaxAggregateOutputType | null
  }

  export type LapanganGambarAvgAggregateOutputType = {
    id: number | null
    lapangan_id: number | null
  }

  export type LapanganGambarSumAggregateOutputType = {
    id: number | null
    lapangan_id: number | null
  }

  export type LapanganGambarMinAggregateOutputType = {
    id: number | null
    lapangan_id: number | null
    file_name: string | null
    created_at: Date | null
  }

  export type LapanganGambarMaxAggregateOutputType = {
    id: number | null
    lapangan_id: number | null
    file_name: string | null
    created_at: Date | null
  }

  export type LapanganGambarCountAggregateOutputType = {
    id: number
    lapangan_id: number
    file_name: number
    created_at: number
    _all: number
  }


  export type LapanganGambarAvgAggregateInputType = {
    id?: true
    lapangan_id?: true
  }

  export type LapanganGambarSumAggregateInputType = {
    id?: true
    lapangan_id?: true
  }

  export type LapanganGambarMinAggregateInputType = {
    id?: true
    lapangan_id?: true
    file_name?: true
    created_at?: true
  }

  export type LapanganGambarMaxAggregateInputType = {
    id?: true
    lapangan_id?: true
    file_name?: true
    created_at?: true
  }

  export type LapanganGambarCountAggregateInputType = {
    id?: true
    lapangan_id?: true
    file_name?: true
    created_at?: true
    _all?: true
  }

  export type LapanganGambarAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LapanganGambar to aggregate.
     */
    where?: LapanganGambarWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LapanganGambars to fetch.
     */
    orderBy?: LapanganGambarOrderByWithRelationInput | LapanganGambarOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LapanganGambarWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LapanganGambars from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LapanganGambars.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LapanganGambars
    **/
    _count?: true | LapanganGambarCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LapanganGambarAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LapanganGambarSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LapanganGambarMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LapanganGambarMaxAggregateInputType
  }

  export type GetLapanganGambarAggregateType<T extends LapanganGambarAggregateArgs> = {
        [P in keyof T & keyof AggregateLapanganGambar]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLapanganGambar[P]>
      : GetScalarType<T[P], AggregateLapanganGambar[P]>
  }




  export type LapanganGambarGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LapanganGambarWhereInput
    orderBy?: LapanganGambarOrderByWithAggregationInput | LapanganGambarOrderByWithAggregationInput[]
    by: LapanganGambarScalarFieldEnum[] | LapanganGambarScalarFieldEnum
    having?: LapanganGambarScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LapanganGambarCountAggregateInputType | true
    _avg?: LapanganGambarAvgAggregateInputType
    _sum?: LapanganGambarSumAggregateInputType
    _min?: LapanganGambarMinAggregateInputType
    _max?: LapanganGambarMaxAggregateInputType
  }

  export type LapanganGambarGroupByOutputType = {
    id: number
    lapangan_id: number
    file_name: string
    created_at: Date
    _count: LapanganGambarCountAggregateOutputType | null
    _avg: LapanganGambarAvgAggregateOutputType | null
    _sum: LapanganGambarSumAggregateOutputType | null
    _min: LapanganGambarMinAggregateOutputType | null
    _max: LapanganGambarMaxAggregateOutputType | null
  }

  type GetLapanganGambarGroupByPayload<T extends LapanganGambarGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LapanganGambarGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LapanganGambarGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LapanganGambarGroupByOutputType[P]>
            : GetScalarType<T[P], LapanganGambarGroupByOutputType[P]>
        }
      >
    >


  export type LapanganGambarSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    lapangan_id?: boolean
    file_name?: boolean
    created_at?: boolean
    lapangan?: boolean | LapanganDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lapanganGambar"]>


  export type LapanganGambarSelectScalar = {
    id?: boolean
    lapangan_id?: boolean
    file_name?: boolean
    created_at?: boolean
  }

  export type LapanganGambarInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lapangan?: boolean | LapanganDefaultArgs<ExtArgs>
  }

  export type $LapanganGambarPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LapanganGambar"
    objects: {
      lapangan: Prisma.$LapanganPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      lapangan_id: number
      file_name: string
      created_at: Date
    }, ExtArgs["result"]["lapanganGambar"]>
    composites: {}
  }

  type LapanganGambarGetPayload<S extends boolean | null | undefined | LapanganGambarDefaultArgs> = $Result.GetResult<Prisma.$LapanganGambarPayload, S>

  type LapanganGambarCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<LapanganGambarFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: LapanganGambarCountAggregateInputType | true
    }

  export interface LapanganGambarDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LapanganGambar'], meta: { name: 'LapanganGambar' } }
    /**
     * Find zero or one LapanganGambar that matches the filter.
     * @param {LapanganGambarFindUniqueArgs} args - Arguments to find a LapanganGambar
     * @example
     * // Get one LapanganGambar
     * const lapanganGambar = await prisma.lapanganGambar.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LapanganGambarFindUniqueArgs>(args: SelectSubset<T, LapanganGambarFindUniqueArgs<ExtArgs>>): Prisma__LapanganGambarClient<$Result.GetResult<Prisma.$LapanganGambarPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one LapanganGambar that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {LapanganGambarFindUniqueOrThrowArgs} args - Arguments to find a LapanganGambar
     * @example
     * // Get one LapanganGambar
     * const lapanganGambar = await prisma.lapanganGambar.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LapanganGambarFindUniqueOrThrowArgs>(args: SelectSubset<T, LapanganGambarFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LapanganGambarClient<$Result.GetResult<Prisma.$LapanganGambarPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first LapanganGambar that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LapanganGambarFindFirstArgs} args - Arguments to find a LapanganGambar
     * @example
     * // Get one LapanganGambar
     * const lapanganGambar = await prisma.lapanganGambar.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LapanganGambarFindFirstArgs>(args?: SelectSubset<T, LapanganGambarFindFirstArgs<ExtArgs>>): Prisma__LapanganGambarClient<$Result.GetResult<Prisma.$LapanganGambarPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first LapanganGambar that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LapanganGambarFindFirstOrThrowArgs} args - Arguments to find a LapanganGambar
     * @example
     * // Get one LapanganGambar
     * const lapanganGambar = await prisma.lapanganGambar.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LapanganGambarFindFirstOrThrowArgs>(args?: SelectSubset<T, LapanganGambarFindFirstOrThrowArgs<ExtArgs>>): Prisma__LapanganGambarClient<$Result.GetResult<Prisma.$LapanganGambarPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more LapanganGambars that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LapanganGambarFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LapanganGambars
     * const lapanganGambars = await prisma.lapanganGambar.findMany()
     * 
     * // Get first 10 LapanganGambars
     * const lapanganGambars = await prisma.lapanganGambar.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const lapanganGambarWithIdOnly = await prisma.lapanganGambar.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LapanganGambarFindManyArgs>(args?: SelectSubset<T, LapanganGambarFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LapanganGambarPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a LapanganGambar.
     * @param {LapanganGambarCreateArgs} args - Arguments to create a LapanganGambar.
     * @example
     * // Create one LapanganGambar
     * const LapanganGambar = await prisma.lapanganGambar.create({
     *   data: {
     *     // ... data to create a LapanganGambar
     *   }
     * })
     * 
     */
    create<T extends LapanganGambarCreateArgs>(args: SelectSubset<T, LapanganGambarCreateArgs<ExtArgs>>): Prisma__LapanganGambarClient<$Result.GetResult<Prisma.$LapanganGambarPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many LapanganGambars.
     * @param {LapanganGambarCreateManyArgs} args - Arguments to create many LapanganGambars.
     * @example
     * // Create many LapanganGambars
     * const lapanganGambar = await prisma.lapanganGambar.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LapanganGambarCreateManyArgs>(args?: SelectSubset<T, LapanganGambarCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a LapanganGambar.
     * @param {LapanganGambarDeleteArgs} args - Arguments to delete one LapanganGambar.
     * @example
     * // Delete one LapanganGambar
     * const LapanganGambar = await prisma.lapanganGambar.delete({
     *   where: {
     *     // ... filter to delete one LapanganGambar
     *   }
     * })
     * 
     */
    delete<T extends LapanganGambarDeleteArgs>(args: SelectSubset<T, LapanganGambarDeleteArgs<ExtArgs>>): Prisma__LapanganGambarClient<$Result.GetResult<Prisma.$LapanganGambarPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one LapanganGambar.
     * @param {LapanganGambarUpdateArgs} args - Arguments to update one LapanganGambar.
     * @example
     * // Update one LapanganGambar
     * const lapanganGambar = await prisma.lapanganGambar.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LapanganGambarUpdateArgs>(args: SelectSubset<T, LapanganGambarUpdateArgs<ExtArgs>>): Prisma__LapanganGambarClient<$Result.GetResult<Prisma.$LapanganGambarPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more LapanganGambars.
     * @param {LapanganGambarDeleteManyArgs} args - Arguments to filter LapanganGambars to delete.
     * @example
     * // Delete a few LapanganGambars
     * const { count } = await prisma.lapanganGambar.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LapanganGambarDeleteManyArgs>(args?: SelectSubset<T, LapanganGambarDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LapanganGambars.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LapanganGambarUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LapanganGambars
     * const lapanganGambar = await prisma.lapanganGambar.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LapanganGambarUpdateManyArgs>(args: SelectSubset<T, LapanganGambarUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one LapanganGambar.
     * @param {LapanganGambarUpsertArgs} args - Arguments to update or create a LapanganGambar.
     * @example
     * // Update or create a LapanganGambar
     * const lapanganGambar = await prisma.lapanganGambar.upsert({
     *   create: {
     *     // ... data to create a LapanganGambar
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LapanganGambar we want to update
     *   }
     * })
     */
    upsert<T extends LapanganGambarUpsertArgs>(args: SelectSubset<T, LapanganGambarUpsertArgs<ExtArgs>>): Prisma__LapanganGambarClient<$Result.GetResult<Prisma.$LapanganGambarPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of LapanganGambars.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LapanganGambarCountArgs} args - Arguments to filter LapanganGambars to count.
     * @example
     * // Count the number of LapanganGambars
     * const count = await prisma.lapanganGambar.count({
     *   where: {
     *     // ... the filter for the LapanganGambars we want to count
     *   }
     * })
    **/
    count<T extends LapanganGambarCountArgs>(
      args?: Subset<T, LapanganGambarCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LapanganGambarCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LapanganGambar.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LapanganGambarAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LapanganGambarAggregateArgs>(args: Subset<T, LapanganGambarAggregateArgs>): Prisma.PrismaPromise<GetLapanganGambarAggregateType<T>>

    /**
     * Group by LapanganGambar.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LapanganGambarGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LapanganGambarGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LapanganGambarGroupByArgs['orderBy'] }
        : { orderBy?: LapanganGambarGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LapanganGambarGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLapanganGambarGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LapanganGambar model
   */
  readonly fields: LapanganGambarFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LapanganGambar.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LapanganGambarClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    lapangan<T extends LapanganDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LapanganDefaultArgs<ExtArgs>>): Prisma__LapanganClient<$Result.GetResult<Prisma.$LapanganPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LapanganGambar model
   */ 
  interface LapanganGambarFieldRefs {
    readonly id: FieldRef<"LapanganGambar", 'Int'>
    readonly lapangan_id: FieldRef<"LapanganGambar", 'Int'>
    readonly file_name: FieldRef<"LapanganGambar", 'String'>
    readonly created_at: FieldRef<"LapanganGambar", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * LapanganGambar findUnique
   */
  export type LapanganGambarFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LapanganGambar
     */
    select?: LapanganGambarSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LapanganGambarInclude<ExtArgs> | null
    /**
     * Filter, which LapanganGambar to fetch.
     */
    where: LapanganGambarWhereUniqueInput
  }

  /**
   * LapanganGambar findUniqueOrThrow
   */
  export type LapanganGambarFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LapanganGambar
     */
    select?: LapanganGambarSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LapanganGambarInclude<ExtArgs> | null
    /**
     * Filter, which LapanganGambar to fetch.
     */
    where: LapanganGambarWhereUniqueInput
  }

  /**
   * LapanganGambar findFirst
   */
  export type LapanganGambarFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LapanganGambar
     */
    select?: LapanganGambarSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LapanganGambarInclude<ExtArgs> | null
    /**
     * Filter, which LapanganGambar to fetch.
     */
    where?: LapanganGambarWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LapanganGambars to fetch.
     */
    orderBy?: LapanganGambarOrderByWithRelationInput | LapanganGambarOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LapanganGambars.
     */
    cursor?: LapanganGambarWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LapanganGambars from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LapanganGambars.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LapanganGambars.
     */
    distinct?: LapanganGambarScalarFieldEnum | LapanganGambarScalarFieldEnum[]
  }

  /**
   * LapanganGambar findFirstOrThrow
   */
  export type LapanganGambarFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LapanganGambar
     */
    select?: LapanganGambarSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LapanganGambarInclude<ExtArgs> | null
    /**
     * Filter, which LapanganGambar to fetch.
     */
    where?: LapanganGambarWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LapanganGambars to fetch.
     */
    orderBy?: LapanganGambarOrderByWithRelationInput | LapanganGambarOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LapanganGambars.
     */
    cursor?: LapanganGambarWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LapanganGambars from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LapanganGambars.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LapanganGambars.
     */
    distinct?: LapanganGambarScalarFieldEnum | LapanganGambarScalarFieldEnum[]
  }

  /**
   * LapanganGambar findMany
   */
  export type LapanganGambarFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LapanganGambar
     */
    select?: LapanganGambarSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LapanganGambarInclude<ExtArgs> | null
    /**
     * Filter, which LapanganGambars to fetch.
     */
    where?: LapanganGambarWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LapanganGambars to fetch.
     */
    orderBy?: LapanganGambarOrderByWithRelationInput | LapanganGambarOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LapanganGambars.
     */
    cursor?: LapanganGambarWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LapanganGambars from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LapanganGambars.
     */
    skip?: number
    distinct?: LapanganGambarScalarFieldEnum | LapanganGambarScalarFieldEnum[]
  }

  /**
   * LapanganGambar create
   */
  export type LapanganGambarCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LapanganGambar
     */
    select?: LapanganGambarSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LapanganGambarInclude<ExtArgs> | null
    /**
     * The data needed to create a LapanganGambar.
     */
    data: XOR<LapanganGambarCreateInput, LapanganGambarUncheckedCreateInput>
  }

  /**
   * LapanganGambar createMany
   */
  export type LapanganGambarCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LapanganGambars.
     */
    data: LapanganGambarCreateManyInput | LapanganGambarCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LapanganGambar update
   */
  export type LapanganGambarUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LapanganGambar
     */
    select?: LapanganGambarSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LapanganGambarInclude<ExtArgs> | null
    /**
     * The data needed to update a LapanganGambar.
     */
    data: XOR<LapanganGambarUpdateInput, LapanganGambarUncheckedUpdateInput>
    /**
     * Choose, which LapanganGambar to update.
     */
    where: LapanganGambarWhereUniqueInput
  }

  /**
   * LapanganGambar updateMany
   */
  export type LapanganGambarUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LapanganGambars.
     */
    data: XOR<LapanganGambarUpdateManyMutationInput, LapanganGambarUncheckedUpdateManyInput>
    /**
     * Filter which LapanganGambars to update
     */
    where?: LapanganGambarWhereInput
  }

  /**
   * LapanganGambar upsert
   */
  export type LapanganGambarUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LapanganGambar
     */
    select?: LapanganGambarSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LapanganGambarInclude<ExtArgs> | null
    /**
     * The filter to search for the LapanganGambar to update in case it exists.
     */
    where: LapanganGambarWhereUniqueInput
    /**
     * In case the LapanganGambar found by the `where` argument doesn't exist, create a new LapanganGambar with this data.
     */
    create: XOR<LapanganGambarCreateInput, LapanganGambarUncheckedCreateInput>
    /**
     * In case the LapanganGambar was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LapanganGambarUpdateInput, LapanganGambarUncheckedUpdateInput>
  }

  /**
   * LapanganGambar delete
   */
  export type LapanganGambarDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LapanganGambar
     */
    select?: LapanganGambarSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LapanganGambarInclude<ExtArgs> | null
    /**
     * Filter which LapanganGambar to delete.
     */
    where: LapanganGambarWhereUniqueInput
  }

  /**
   * LapanganGambar deleteMany
   */
  export type LapanganGambarDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LapanganGambars to delete
     */
    where?: LapanganGambarWhereInput
  }

  /**
   * LapanganGambar without action
   */
  export type LapanganGambarDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LapanganGambar
     */
    select?: LapanganGambarSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LapanganGambarInclude<ExtArgs> | null
  }


  /**
   * Model JadwalLapangan
   */

  export type AggregateJadwalLapangan = {
    _count: JadwalLapanganCountAggregateOutputType | null
    _avg: JadwalLapanganAvgAggregateOutputType | null
    _sum: JadwalLapanganSumAggregateOutputType | null
    _min: JadwalLapanganMinAggregateOutputType | null
    _max: JadwalLapanganMaxAggregateOutputType | null
  }

  export type JadwalLapanganAvgAggregateOutputType = {
    id: number | null
    lapangan_id: number | null
  }

  export type JadwalLapanganSumAggregateOutputType = {
    id: number | null
    lapangan_id: number | null
  }

  export type JadwalLapanganMinAggregateOutputType = {
    id: number | null
    lapangan_id: number | null
    tanggal: Date | null
    slot: string | null
    status: $Enums.jadwal_status | null
    locked_until: Date | null
  }

  export type JadwalLapanganMaxAggregateOutputType = {
    id: number | null
    lapangan_id: number | null
    tanggal: Date | null
    slot: string | null
    status: $Enums.jadwal_status | null
    locked_until: Date | null
  }

  export type JadwalLapanganCountAggregateOutputType = {
    id: number
    lapangan_id: number
    tanggal: number
    slot: number
    status: number
    locked_until: number
    _all: number
  }


  export type JadwalLapanganAvgAggregateInputType = {
    id?: true
    lapangan_id?: true
  }

  export type JadwalLapanganSumAggregateInputType = {
    id?: true
    lapangan_id?: true
  }

  export type JadwalLapanganMinAggregateInputType = {
    id?: true
    lapangan_id?: true
    tanggal?: true
    slot?: true
    status?: true
    locked_until?: true
  }

  export type JadwalLapanganMaxAggregateInputType = {
    id?: true
    lapangan_id?: true
    tanggal?: true
    slot?: true
    status?: true
    locked_until?: true
  }

  export type JadwalLapanganCountAggregateInputType = {
    id?: true
    lapangan_id?: true
    tanggal?: true
    slot?: true
    status?: true
    locked_until?: true
    _all?: true
  }

  export type JadwalLapanganAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which JadwalLapangan to aggregate.
     */
    where?: JadwalLapanganWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JadwalLapangans to fetch.
     */
    orderBy?: JadwalLapanganOrderByWithRelationInput | JadwalLapanganOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: JadwalLapanganWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JadwalLapangans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JadwalLapangans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned JadwalLapangans
    **/
    _count?: true | JadwalLapanganCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: JadwalLapanganAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: JadwalLapanganSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: JadwalLapanganMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: JadwalLapanganMaxAggregateInputType
  }

  export type GetJadwalLapanganAggregateType<T extends JadwalLapanganAggregateArgs> = {
        [P in keyof T & keyof AggregateJadwalLapangan]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateJadwalLapangan[P]>
      : GetScalarType<T[P], AggregateJadwalLapangan[P]>
  }




  export type JadwalLapanganGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JadwalLapanganWhereInput
    orderBy?: JadwalLapanganOrderByWithAggregationInput | JadwalLapanganOrderByWithAggregationInput[]
    by: JadwalLapanganScalarFieldEnum[] | JadwalLapanganScalarFieldEnum
    having?: JadwalLapanganScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: JadwalLapanganCountAggregateInputType | true
    _avg?: JadwalLapanganAvgAggregateInputType
    _sum?: JadwalLapanganSumAggregateInputType
    _min?: JadwalLapanganMinAggregateInputType
    _max?: JadwalLapanganMaxAggregateInputType
  }

  export type JadwalLapanganGroupByOutputType = {
    id: number
    lapangan_id: number
    tanggal: Date
    slot: string
    status: $Enums.jadwal_status
    locked_until: Date | null
    _count: JadwalLapanganCountAggregateOutputType | null
    _avg: JadwalLapanganAvgAggregateOutputType | null
    _sum: JadwalLapanganSumAggregateOutputType | null
    _min: JadwalLapanganMinAggregateOutputType | null
    _max: JadwalLapanganMaxAggregateOutputType | null
  }

  type GetJadwalLapanganGroupByPayload<T extends JadwalLapanganGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<JadwalLapanganGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof JadwalLapanganGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], JadwalLapanganGroupByOutputType[P]>
            : GetScalarType<T[P], JadwalLapanganGroupByOutputType[P]>
        }
      >
    >


  export type JadwalLapanganSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    lapangan_id?: boolean
    tanggal?: boolean
    slot?: boolean
    status?: boolean
    locked_until?: boolean
    lapangan?: boolean | LapanganDefaultArgs<ExtArgs>
    orders?: boolean | JadwalLapangan$ordersArgs<ExtArgs>
    transaksi?: boolean | JadwalLapangan$transaksiArgs<ExtArgs>
    _count?: boolean | JadwalLapanganCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["jadwalLapangan"]>


  export type JadwalLapanganSelectScalar = {
    id?: boolean
    lapangan_id?: boolean
    tanggal?: boolean
    slot?: boolean
    status?: boolean
    locked_until?: boolean
  }

  export type JadwalLapanganInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lapangan?: boolean | LapanganDefaultArgs<ExtArgs>
    orders?: boolean | JadwalLapangan$ordersArgs<ExtArgs>
    transaksi?: boolean | JadwalLapangan$transaksiArgs<ExtArgs>
    _count?: boolean | JadwalLapanganCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $JadwalLapanganPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "JadwalLapangan"
    objects: {
      lapangan: Prisma.$LapanganPayload<ExtArgs>
      orders: Prisma.$order_bookingPayload<ExtArgs>[]
      transaksi: Prisma.$transaksiPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      lapangan_id: number
      tanggal: Date
      slot: string
      status: $Enums.jadwal_status
      locked_until: Date | null
    }, ExtArgs["result"]["jadwalLapangan"]>
    composites: {}
  }

  type JadwalLapanganGetPayload<S extends boolean | null | undefined | JadwalLapanganDefaultArgs> = $Result.GetResult<Prisma.$JadwalLapanganPayload, S>

  type JadwalLapanganCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<JadwalLapanganFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: JadwalLapanganCountAggregateInputType | true
    }

  export interface JadwalLapanganDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['JadwalLapangan'], meta: { name: 'JadwalLapangan' } }
    /**
     * Find zero or one JadwalLapangan that matches the filter.
     * @param {JadwalLapanganFindUniqueArgs} args - Arguments to find a JadwalLapangan
     * @example
     * // Get one JadwalLapangan
     * const jadwalLapangan = await prisma.jadwalLapangan.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends JadwalLapanganFindUniqueArgs>(args: SelectSubset<T, JadwalLapanganFindUniqueArgs<ExtArgs>>): Prisma__JadwalLapanganClient<$Result.GetResult<Prisma.$JadwalLapanganPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one JadwalLapangan that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {JadwalLapanganFindUniqueOrThrowArgs} args - Arguments to find a JadwalLapangan
     * @example
     * // Get one JadwalLapangan
     * const jadwalLapangan = await prisma.jadwalLapangan.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends JadwalLapanganFindUniqueOrThrowArgs>(args: SelectSubset<T, JadwalLapanganFindUniqueOrThrowArgs<ExtArgs>>): Prisma__JadwalLapanganClient<$Result.GetResult<Prisma.$JadwalLapanganPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first JadwalLapangan that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JadwalLapanganFindFirstArgs} args - Arguments to find a JadwalLapangan
     * @example
     * // Get one JadwalLapangan
     * const jadwalLapangan = await prisma.jadwalLapangan.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends JadwalLapanganFindFirstArgs>(args?: SelectSubset<T, JadwalLapanganFindFirstArgs<ExtArgs>>): Prisma__JadwalLapanganClient<$Result.GetResult<Prisma.$JadwalLapanganPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first JadwalLapangan that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JadwalLapanganFindFirstOrThrowArgs} args - Arguments to find a JadwalLapangan
     * @example
     * // Get one JadwalLapangan
     * const jadwalLapangan = await prisma.jadwalLapangan.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends JadwalLapanganFindFirstOrThrowArgs>(args?: SelectSubset<T, JadwalLapanganFindFirstOrThrowArgs<ExtArgs>>): Prisma__JadwalLapanganClient<$Result.GetResult<Prisma.$JadwalLapanganPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more JadwalLapangans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JadwalLapanganFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all JadwalLapangans
     * const jadwalLapangans = await prisma.jadwalLapangan.findMany()
     * 
     * // Get first 10 JadwalLapangans
     * const jadwalLapangans = await prisma.jadwalLapangan.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const jadwalLapanganWithIdOnly = await prisma.jadwalLapangan.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends JadwalLapanganFindManyArgs>(args?: SelectSubset<T, JadwalLapanganFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JadwalLapanganPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a JadwalLapangan.
     * @param {JadwalLapanganCreateArgs} args - Arguments to create a JadwalLapangan.
     * @example
     * // Create one JadwalLapangan
     * const JadwalLapangan = await prisma.jadwalLapangan.create({
     *   data: {
     *     // ... data to create a JadwalLapangan
     *   }
     * })
     * 
     */
    create<T extends JadwalLapanganCreateArgs>(args: SelectSubset<T, JadwalLapanganCreateArgs<ExtArgs>>): Prisma__JadwalLapanganClient<$Result.GetResult<Prisma.$JadwalLapanganPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many JadwalLapangans.
     * @param {JadwalLapanganCreateManyArgs} args - Arguments to create many JadwalLapangans.
     * @example
     * // Create many JadwalLapangans
     * const jadwalLapangan = await prisma.jadwalLapangan.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends JadwalLapanganCreateManyArgs>(args?: SelectSubset<T, JadwalLapanganCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a JadwalLapangan.
     * @param {JadwalLapanganDeleteArgs} args - Arguments to delete one JadwalLapangan.
     * @example
     * // Delete one JadwalLapangan
     * const JadwalLapangan = await prisma.jadwalLapangan.delete({
     *   where: {
     *     // ... filter to delete one JadwalLapangan
     *   }
     * })
     * 
     */
    delete<T extends JadwalLapanganDeleteArgs>(args: SelectSubset<T, JadwalLapanganDeleteArgs<ExtArgs>>): Prisma__JadwalLapanganClient<$Result.GetResult<Prisma.$JadwalLapanganPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one JadwalLapangan.
     * @param {JadwalLapanganUpdateArgs} args - Arguments to update one JadwalLapangan.
     * @example
     * // Update one JadwalLapangan
     * const jadwalLapangan = await prisma.jadwalLapangan.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends JadwalLapanganUpdateArgs>(args: SelectSubset<T, JadwalLapanganUpdateArgs<ExtArgs>>): Prisma__JadwalLapanganClient<$Result.GetResult<Prisma.$JadwalLapanganPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more JadwalLapangans.
     * @param {JadwalLapanganDeleteManyArgs} args - Arguments to filter JadwalLapangans to delete.
     * @example
     * // Delete a few JadwalLapangans
     * const { count } = await prisma.jadwalLapangan.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends JadwalLapanganDeleteManyArgs>(args?: SelectSubset<T, JadwalLapanganDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more JadwalLapangans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JadwalLapanganUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many JadwalLapangans
     * const jadwalLapangan = await prisma.jadwalLapangan.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends JadwalLapanganUpdateManyArgs>(args: SelectSubset<T, JadwalLapanganUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one JadwalLapangan.
     * @param {JadwalLapanganUpsertArgs} args - Arguments to update or create a JadwalLapangan.
     * @example
     * // Update or create a JadwalLapangan
     * const jadwalLapangan = await prisma.jadwalLapangan.upsert({
     *   create: {
     *     // ... data to create a JadwalLapangan
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the JadwalLapangan we want to update
     *   }
     * })
     */
    upsert<T extends JadwalLapanganUpsertArgs>(args: SelectSubset<T, JadwalLapanganUpsertArgs<ExtArgs>>): Prisma__JadwalLapanganClient<$Result.GetResult<Prisma.$JadwalLapanganPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of JadwalLapangans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JadwalLapanganCountArgs} args - Arguments to filter JadwalLapangans to count.
     * @example
     * // Count the number of JadwalLapangans
     * const count = await prisma.jadwalLapangan.count({
     *   where: {
     *     // ... the filter for the JadwalLapangans we want to count
     *   }
     * })
    **/
    count<T extends JadwalLapanganCountArgs>(
      args?: Subset<T, JadwalLapanganCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], JadwalLapanganCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a JadwalLapangan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JadwalLapanganAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends JadwalLapanganAggregateArgs>(args: Subset<T, JadwalLapanganAggregateArgs>): Prisma.PrismaPromise<GetJadwalLapanganAggregateType<T>>

    /**
     * Group by JadwalLapangan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JadwalLapanganGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends JadwalLapanganGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: JadwalLapanganGroupByArgs['orderBy'] }
        : { orderBy?: JadwalLapanganGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, JadwalLapanganGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetJadwalLapanganGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the JadwalLapangan model
   */
  readonly fields: JadwalLapanganFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for JadwalLapangan.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__JadwalLapanganClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    lapangan<T extends LapanganDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LapanganDefaultArgs<ExtArgs>>): Prisma__LapanganClient<$Result.GetResult<Prisma.$LapanganPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    orders<T extends JadwalLapangan$ordersArgs<ExtArgs> = {}>(args?: Subset<T, JadwalLapangan$ordersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$order_bookingPayload<ExtArgs>, T, "findMany"> | Null>
    transaksi<T extends JadwalLapangan$transaksiArgs<ExtArgs> = {}>(args?: Subset<T, JadwalLapangan$transaksiArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$transaksiPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the JadwalLapangan model
   */ 
  interface JadwalLapanganFieldRefs {
    readonly id: FieldRef<"JadwalLapangan", 'Int'>
    readonly lapangan_id: FieldRef<"JadwalLapangan", 'Int'>
    readonly tanggal: FieldRef<"JadwalLapangan", 'DateTime'>
    readonly slot: FieldRef<"JadwalLapangan", 'String'>
    readonly status: FieldRef<"JadwalLapangan", 'jadwal_status'>
    readonly locked_until: FieldRef<"JadwalLapangan", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * JadwalLapangan findUnique
   */
  export type JadwalLapanganFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JadwalLapangan
     */
    select?: JadwalLapanganSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JadwalLapanganInclude<ExtArgs> | null
    /**
     * Filter, which JadwalLapangan to fetch.
     */
    where: JadwalLapanganWhereUniqueInput
  }

  /**
   * JadwalLapangan findUniqueOrThrow
   */
  export type JadwalLapanganFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JadwalLapangan
     */
    select?: JadwalLapanganSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JadwalLapanganInclude<ExtArgs> | null
    /**
     * Filter, which JadwalLapangan to fetch.
     */
    where: JadwalLapanganWhereUniqueInput
  }

  /**
   * JadwalLapangan findFirst
   */
  export type JadwalLapanganFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JadwalLapangan
     */
    select?: JadwalLapanganSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JadwalLapanganInclude<ExtArgs> | null
    /**
     * Filter, which JadwalLapangan to fetch.
     */
    where?: JadwalLapanganWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JadwalLapangans to fetch.
     */
    orderBy?: JadwalLapanganOrderByWithRelationInput | JadwalLapanganOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JadwalLapangans.
     */
    cursor?: JadwalLapanganWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JadwalLapangans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JadwalLapangans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JadwalLapangans.
     */
    distinct?: JadwalLapanganScalarFieldEnum | JadwalLapanganScalarFieldEnum[]
  }

  /**
   * JadwalLapangan findFirstOrThrow
   */
  export type JadwalLapanganFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JadwalLapangan
     */
    select?: JadwalLapanganSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JadwalLapanganInclude<ExtArgs> | null
    /**
     * Filter, which JadwalLapangan to fetch.
     */
    where?: JadwalLapanganWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JadwalLapangans to fetch.
     */
    orderBy?: JadwalLapanganOrderByWithRelationInput | JadwalLapanganOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JadwalLapangans.
     */
    cursor?: JadwalLapanganWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JadwalLapangans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JadwalLapangans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JadwalLapangans.
     */
    distinct?: JadwalLapanganScalarFieldEnum | JadwalLapanganScalarFieldEnum[]
  }

  /**
   * JadwalLapangan findMany
   */
  export type JadwalLapanganFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JadwalLapangan
     */
    select?: JadwalLapanganSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JadwalLapanganInclude<ExtArgs> | null
    /**
     * Filter, which JadwalLapangans to fetch.
     */
    where?: JadwalLapanganWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JadwalLapangans to fetch.
     */
    orderBy?: JadwalLapanganOrderByWithRelationInput | JadwalLapanganOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing JadwalLapangans.
     */
    cursor?: JadwalLapanganWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JadwalLapangans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JadwalLapangans.
     */
    skip?: number
    distinct?: JadwalLapanganScalarFieldEnum | JadwalLapanganScalarFieldEnum[]
  }

  /**
   * JadwalLapangan create
   */
  export type JadwalLapanganCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JadwalLapangan
     */
    select?: JadwalLapanganSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JadwalLapanganInclude<ExtArgs> | null
    /**
     * The data needed to create a JadwalLapangan.
     */
    data: XOR<JadwalLapanganCreateInput, JadwalLapanganUncheckedCreateInput>
  }

  /**
   * JadwalLapangan createMany
   */
  export type JadwalLapanganCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many JadwalLapangans.
     */
    data: JadwalLapanganCreateManyInput | JadwalLapanganCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * JadwalLapangan update
   */
  export type JadwalLapanganUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JadwalLapangan
     */
    select?: JadwalLapanganSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JadwalLapanganInclude<ExtArgs> | null
    /**
     * The data needed to update a JadwalLapangan.
     */
    data: XOR<JadwalLapanganUpdateInput, JadwalLapanganUncheckedUpdateInput>
    /**
     * Choose, which JadwalLapangan to update.
     */
    where: JadwalLapanganWhereUniqueInput
  }

  /**
   * JadwalLapangan updateMany
   */
  export type JadwalLapanganUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update JadwalLapangans.
     */
    data: XOR<JadwalLapanganUpdateManyMutationInput, JadwalLapanganUncheckedUpdateManyInput>
    /**
     * Filter which JadwalLapangans to update
     */
    where?: JadwalLapanganWhereInput
  }

  /**
   * JadwalLapangan upsert
   */
  export type JadwalLapanganUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JadwalLapangan
     */
    select?: JadwalLapanganSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JadwalLapanganInclude<ExtArgs> | null
    /**
     * The filter to search for the JadwalLapangan to update in case it exists.
     */
    where: JadwalLapanganWhereUniqueInput
    /**
     * In case the JadwalLapangan found by the `where` argument doesn't exist, create a new JadwalLapangan with this data.
     */
    create: XOR<JadwalLapanganCreateInput, JadwalLapanganUncheckedCreateInput>
    /**
     * In case the JadwalLapangan was found with the provided `where` argument, update it with this data.
     */
    update: XOR<JadwalLapanganUpdateInput, JadwalLapanganUncheckedUpdateInput>
  }

  /**
   * JadwalLapangan delete
   */
  export type JadwalLapanganDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JadwalLapangan
     */
    select?: JadwalLapanganSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JadwalLapanganInclude<ExtArgs> | null
    /**
     * Filter which JadwalLapangan to delete.
     */
    where: JadwalLapanganWhereUniqueInput
  }

  /**
   * JadwalLapangan deleteMany
   */
  export type JadwalLapanganDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which JadwalLapangans to delete
     */
    where?: JadwalLapanganWhereInput
  }

  /**
   * JadwalLapangan.orders
   */
  export type JadwalLapangan$ordersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order_booking
     */
    select?: order_bookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: order_bookingInclude<ExtArgs> | null
    where?: order_bookingWhereInput
    orderBy?: order_bookingOrderByWithRelationInput | order_bookingOrderByWithRelationInput[]
    cursor?: order_bookingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Order_bookingScalarFieldEnum | Order_bookingScalarFieldEnum[]
  }

  /**
   * JadwalLapangan.transaksi
   */
  export type JadwalLapangan$transaksiArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transaksi
     */
    select?: transaksiSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transaksiInclude<ExtArgs> | null
    where?: transaksiWhereInput
    orderBy?: transaksiOrderByWithRelationInput | transaksiOrderByWithRelationInput[]
    cursor?: transaksiWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransaksiScalarFieldEnum | TransaksiScalarFieldEnum[]
  }

  /**
   * JadwalLapangan without action
   */
  export type JadwalLapanganDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JadwalLapangan
     */
    select?: JadwalLapanganSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JadwalLapanganInclude<ExtArgs> | null
  }


  /**
   * Model order_booking
   */

  export type AggregateOrder_booking = {
    _count: Order_bookingCountAggregateOutputType | null
    _avg: Order_bookingAvgAggregateOutputType | null
    _sum: Order_bookingSumAggregateOutputType | null
    _min: Order_bookingMinAggregateOutputType | null
    _max: Order_bookingMaxAggregateOutputType | null
  }

  export type Order_bookingAvgAggregateOutputType = {
    id: number | null
    user_id: number | null
    lapangan_id: number | null
    jadwalLapanganId: number | null
    total_harga: Decimal | null
    biaya_raket: number | null
  }

  export type Order_bookingSumAggregateOutputType = {
    id: number | null
    user_id: number | null
    lapangan_id: number | null
    jadwalLapanganId: number | null
    total_harga: Decimal | null
    biaya_raket: number | null
  }

  export type Order_bookingMinAggregateOutputType = {
    id: number | null
    user_id: number | null
    lapangan_id: number | null
    jadwalLapanganId: number | null
    tanggal: Date | null
    jam_mulai: string | null
    jam_selesai: string | null
    total_harga: Decimal | null
    status: string | null
    sewa_raket: boolean | null
    biaya_raket: number | null
    created_at: Date | null
    expired_at: Date | null
  }

  export type Order_bookingMaxAggregateOutputType = {
    id: number | null
    user_id: number | null
    lapangan_id: number | null
    jadwalLapanganId: number | null
    tanggal: Date | null
    jam_mulai: string | null
    jam_selesai: string | null
    total_harga: Decimal | null
    status: string | null
    sewa_raket: boolean | null
    biaya_raket: number | null
    created_at: Date | null
    expired_at: Date | null
  }

  export type Order_bookingCountAggregateOutputType = {
    id: number
    user_id: number
    lapangan_id: number
    jadwalLapanganId: number
    tanggal: number
    jam_mulai: number
    jam_selesai: number
    total_harga: number
    status: number
    sewa_raket: number
    biaya_raket: number
    created_at: number
    expired_at: number
    _all: number
  }


  export type Order_bookingAvgAggregateInputType = {
    id?: true
    user_id?: true
    lapangan_id?: true
    jadwalLapanganId?: true
    total_harga?: true
    biaya_raket?: true
  }

  export type Order_bookingSumAggregateInputType = {
    id?: true
    user_id?: true
    lapangan_id?: true
    jadwalLapanganId?: true
    total_harga?: true
    biaya_raket?: true
  }

  export type Order_bookingMinAggregateInputType = {
    id?: true
    user_id?: true
    lapangan_id?: true
    jadwalLapanganId?: true
    tanggal?: true
    jam_mulai?: true
    jam_selesai?: true
    total_harga?: true
    status?: true
    sewa_raket?: true
    biaya_raket?: true
    created_at?: true
    expired_at?: true
  }

  export type Order_bookingMaxAggregateInputType = {
    id?: true
    user_id?: true
    lapangan_id?: true
    jadwalLapanganId?: true
    tanggal?: true
    jam_mulai?: true
    jam_selesai?: true
    total_harga?: true
    status?: true
    sewa_raket?: true
    biaya_raket?: true
    created_at?: true
    expired_at?: true
  }

  export type Order_bookingCountAggregateInputType = {
    id?: true
    user_id?: true
    lapangan_id?: true
    jadwalLapanganId?: true
    tanggal?: true
    jam_mulai?: true
    jam_selesai?: true
    total_harga?: true
    status?: true
    sewa_raket?: true
    biaya_raket?: true
    created_at?: true
    expired_at?: true
    _all?: true
  }

  export type Order_bookingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which order_booking to aggregate.
     */
    where?: order_bookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of order_bookings to fetch.
     */
    orderBy?: order_bookingOrderByWithRelationInput | order_bookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: order_bookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` order_bookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` order_bookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned order_bookings
    **/
    _count?: true | Order_bookingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Order_bookingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Order_bookingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Order_bookingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Order_bookingMaxAggregateInputType
  }

  export type GetOrder_bookingAggregateType<T extends Order_bookingAggregateArgs> = {
        [P in keyof T & keyof AggregateOrder_booking]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrder_booking[P]>
      : GetScalarType<T[P], AggregateOrder_booking[P]>
  }




  export type order_bookingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: order_bookingWhereInput
    orderBy?: order_bookingOrderByWithAggregationInput | order_bookingOrderByWithAggregationInput[]
    by: Order_bookingScalarFieldEnum[] | Order_bookingScalarFieldEnum
    having?: order_bookingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Order_bookingCountAggregateInputType | true
    _avg?: Order_bookingAvgAggregateInputType
    _sum?: Order_bookingSumAggregateInputType
    _min?: Order_bookingMinAggregateInputType
    _max?: Order_bookingMaxAggregateInputType
  }

  export type Order_bookingGroupByOutputType = {
    id: number
    user_id: number
    lapangan_id: number
    jadwalLapanganId: number
    tanggal: Date
    jam_mulai: string
    jam_selesai: string
    total_harga: Decimal
    status: string
    sewa_raket: boolean
    biaya_raket: number
    created_at: Date
    expired_at: Date | null
    _count: Order_bookingCountAggregateOutputType | null
    _avg: Order_bookingAvgAggregateOutputType | null
    _sum: Order_bookingSumAggregateOutputType | null
    _min: Order_bookingMinAggregateOutputType | null
    _max: Order_bookingMaxAggregateOutputType | null
  }

  type GetOrder_bookingGroupByPayload<T extends order_bookingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Order_bookingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Order_bookingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Order_bookingGroupByOutputType[P]>
            : GetScalarType<T[P], Order_bookingGroupByOutputType[P]>
        }
      >
    >


  export type order_bookingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    lapangan_id?: boolean
    jadwalLapanganId?: boolean
    tanggal?: boolean
    jam_mulai?: boolean
    jam_selesai?: boolean
    total_harga?: boolean
    status?: boolean
    sewa_raket?: boolean
    biaya_raket?: boolean
    created_at?: boolean
    expired_at?: boolean
    user?: boolean | usersDefaultArgs<ExtArgs>
    lapangan?: boolean | LapanganDefaultArgs<ExtArgs>
    jadwalLapangan?: boolean | JadwalLapanganDefaultArgs<ExtArgs>
    transaksi?: boolean | order_booking$transaksiArgs<ExtArgs>
    refund?: boolean | order_booking$refundArgs<ExtArgs>
    wallet_histories?: boolean | order_booking$wallet_historiesArgs<ExtArgs>
    _count?: boolean | Order_bookingCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["order_booking"]>


  export type order_bookingSelectScalar = {
    id?: boolean
    user_id?: boolean
    lapangan_id?: boolean
    jadwalLapanganId?: boolean
    tanggal?: boolean
    jam_mulai?: boolean
    jam_selesai?: boolean
    total_harga?: boolean
    status?: boolean
    sewa_raket?: boolean
    biaya_raket?: boolean
    created_at?: boolean
    expired_at?: boolean
  }

  export type order_bookingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | usersDefaultArgs<ExtArgs>
    lapangan?: boolean | LapanganDefaultArgs<ExtArgs>
    jadwalLapangan?: boolean | JadwalLapanganDefaultArgs<ExtArgs>
    transaksi?: boolean | order_booking$transaksiArgs<ExtArgs>
    refund?: boolean | order_booking$refundArgs<ExtArgs>
    wallet_histories?: boolean | order_booking$wallet_historiesArgs<ExtArgs>
    _count?: boolean | Order_bookingCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $order_bookingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "order_booking"
    objects: {
      user: Prisma.$usersPayload<ExtArgs>
      lapangan: Prisma.$LapanganPayload<ExtArgs>
      jadwalLapangan: Prisma.$JadwalLapanganPayload<ExtArgs>
      transaksi: Prisma.$transaksiPayload<ExtArgs> | null
      refund: Prisma.$refundPayload<ExtArgs> | null
      wallet_histories: Prisma.$wallet_historyPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      user_id: number
      lapangan_id: number
      jadwalLapanganId: number
      tanggal: Date
      jam_mulai: string
      jam_selesai: string
      total_harga: Prisma.Decimal
      status: string
      sewa_raket: boolean
      biaya_raket: number
      created_at: Date
      expired_at: Date | null
    }, ExtArgs["result"]["order_booking"]>
    composites: {}
  }

  type order_bookingGetPayload<S extends boolean | null | undefined | order_bookingDefaultArgs> = $Result.GetResult<Prisma.$order_bookingPayload, S>

  type order_bookingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<order_bookingFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Order_bookingCountAggregateInputType | true
    }

  export interface order_bookingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['order_booking'], meta: { name: 'order_booking' } }
    /**
     * Find zero or one Order_booking that matches the filter.
     * @param {order_bookingFindUniqueArgs} args - Arguments to find a Order_booking
     * @example
     * // Get one Order_booking
     * const order_booking = await prisma.order_booking.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends order_bookingFindUniqueArgs>(args: SelectSubset<T, order_bookingFindUniqueArgs<ExtArgs>>): Prisma__order_bookingClient<$Result.GetResult<Prisma.$order_bookingPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Order_booking that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {order_bookingFindUniqueOrThrowArgs} args - Arguments to find a Order_booking
     * @example
     * // Get one Order_booking
     * const order_booking = await prisma.order_booking.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends order_bookingFindUniqueOrThrowArgs>(args: SelectSubset<T, order_bookingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__order_bookingClient<$Result.GetResult<Prisma.$order_bookingPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Order_booking that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {order_bookingFindFirstArgs} args - Arguments to find a Order_booking
     * @example
     * // Get one Order_booking
     * const order_booking = await prisma.order_booking.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends order_bookingFindFirstArgs>(args?: SelectSubset<T, order_bookingFindFirstArgs<ExtArgs>>): Prisma__order_bookingClient<$Result.GetResult<Prisma.$order_bookingPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Order_booking that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {order_bookingFindFirstOrThrowArgs} args - Arguments to find a Order_booking
     * @example
     * // Get one Order_booking
     * const order_booking = await prisma.order_booking.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends order_bookingFindFirstOrThrowArgs>(args?: SelectSubset<T, order_bookingFindFirstOrThrowArgs<ExtArgs>>): Prisma__order_bookingClient<$Result.GetResult<Prisma.$order_bookingPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Order_bookings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {order_bookingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Order_bookings
     * const order_bookings = await prisma.order_booking.findMany()
     * 
     * // Get first 10 Order_bookings
     * const order_bookings = await prisma.order_booking.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const order_bookingWithIdOnly = await prisma.order_booking.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends order_bookingFindManyArgs>(args?: SelectSubset<T, order_bookingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$order_bookingPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Order_booking.
     * @param {order_bookingCreateArgs} args - Arguments to create a Order_booking.
     * @example
     * // Create one Order_booking
     * const Order_booking = await prisma.order_booking.create({
     *   data: {
     *     // ... data to create a Order_booking
     *   }
     * })
     * 
     */
    create<T extends order_bookingCreateArgs>(args: SelectSubset<T, order_bookingCreateArgs<ExtArgs>>): Prisma__order_bookingClient<$Result.GetResult<Prisma.$order_bookingPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Order_bookings.
     * @param {order_bookingCreateManyArgs} args - Arguments to create many Order_bookings.
     * @example
     * // Create many Order_bookings
     * const order_booking = await prisma.order_booking.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends order_bookingCreateManyArgs>(args?: SelectSubset<T, order_bookingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Order_booking.
     * @param {order_bookingDeleteArgs} args - Arguments to delete one Order_booking.
     * @example
     * // Delete one Order_booking
     * const Order_booking = await prisma.order_booking.delete({
     *   where: {
     *     // ... filter to delete one Order_booking
     *   }
     * })
     * 
     */
    delete<T extends order_bookingDeleteArgs>(args: SelectSubset<T, order_bookingDeleteArgs<ExtArgs>>): Prisma__order_bookingClient<$Result.GetResult<Prisma.$order_bookingPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Order_booking.
     * @param {order_bookingUpdateArgs} args - Arguments to update one Order_booking.
     * @example
     * // Update one Order_booking
     * const order_booking = await prisma.order_booking.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends order_bookingUpdateArgs>(args: SelectSubset<T, order_bookingUpdateArgs<ExtArgs>>): Prisma__order_bookingClient<$Result.GetResult<Prisma.$order_bookingPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Order_bookings.
     * @param {order_bookingDeleteManyArgs} args - Arguments to filter Order_bookings to delete.
     * @example
     * // Delete a few Order_bookings
     * const { count } = await prisma.order_booking.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends order_bookingDeleteManyArgs>(args?: SelectSubset<T, order_bookingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Order_bookings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {order_bookingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Order_bookings
     * const order_booking = await prisma.order_booking.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends order_bookingUpdateManyArgs>(args: SelectSubset<T, order_bookingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Order_booking.
     * @param {order_bookingUpsertArgs} args - Arguments to update or create a Order_booking.
     * @example
     * // Update or create a Order_booking
     * const order_booking = await prisma.order_booking.upsert({
     *   create: {
     *     // ... data to create a Order_booking
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Order_booking we want to update
     *   }
     * })
     */
    upsert<T extends order_bookingUpsertArgs>(args: SelectSubset<T, order_bookingUpsertArgs<ExtArgs>>): Prisma__order_bookingClient<$Result.GetResult<Prisma.$order_bookingPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Order_bookings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {order_bookingCountArgs} args - Arguments to filter Order_bookings to count.
     * @example
     * // Count the number of Order_bookings
     * const count = await prisma.order_booking.count({
     *   where: {
     *     // ... the filter for the Order_bookings we want to count
     *   }
     * })
    **/
    count<T extends order_bookingCountArgs>(
      args?: Subset<T, order_bookingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Order_bookingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Order_booking.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Order_bookingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Order_bookingAggregateArgs>(args: Subset<T, Order_bookingAggregateArgs>): Prisma.PrismaPromise<GetOrder_bookingAggregateType<T>>

    /**
     * Group by Order_booking.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {order_bookingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends order_bookingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: order_bookingGroupByArgs['orderBy'] }
        : { orderBy?: order_bookingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, order_bookingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrder_bookingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the order_booking model
   */
  readonly fields: order_bookingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for order_booking.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__order_bookingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    lapangan<T extends LapanganDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LapanganDefaultArgs<ExtArgs>>): Prisma__LapanganClient<$Result.GetResult<Prisma.$LapanganPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    jadwalLapangan<T extends JadwalLapanganDefaultArgs<ExtArgs> = {}>(args?: Subset<T, JadwalLapanganDefaultArgs<ExtArgs>>): Prisma__JadwalLapanganClient<$Result.GetResult<Prisma.$JadwalLapanganPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    transaksi<T extends order_booking$transaksiArgs<ExtArgs> = {}>(args?: Subset<T, order_booking$transaksiArgs<ExtArgs>>): Prisma__transaksiClient<$Result.GetResult<Prisma.$transaksiPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    refund<T extends order_booking$refundArgs<ExtArgs> = {}>(args?: Subset<T, order_booking$refundArgs<ExtArgs>>): Prisma__refundClient<$Result.GetResult<Prisma.$refundPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    wallet_histories<T extends order_booking$wallet_historiesArgs<ExtArgs> = {}>(args?: Subset<T, order_booking$wallet_historiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$wallet_historyPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the order_booking model
   */ 
  interface order_bookingFieldRefs {
    readonly id: FieldRef<"order_booking", 'Int'>
    readonly user_id: FieldRef<"order_booking", 'Int'>
    readonly lapangan_id: FieldRef<"order_booking", 'Int'>
    readonly jadwalLapanganId: FieldRef<"order_booking", 'Int'>
    readonly tanggal: FieldRef<"order_booking", 'DateTime'>
    readonly jam_mulai: FieldRef<"order_booking", 'String'>
    readonly jam_selesai: FieldRef<"order_booking", 'String'>
    readonly total_harga: FieldRef<"order_booking", 'Decimal'>
    readonly status: FieldRef<"order_booking", 'String'>
    readonly sewa_raket: FieldRef<"order_booking", 'Boolean'>
    readonly biaya_raket: FieldRef<"order_booking", 'Int'>
    readonly created_at: FieldRef<"order_booking", 'DateTime'>
    readonly expired_at: FieldRef<"order_booking", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * order_booking findUnique
   */
  export type order_bookingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order_booking
     */
    select?: order_bookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: order_bookingInclude<ExtArgs> | null
    /**
     * Filter, which order_booking to fetch.
     */
    where: order_bookingWhereUniqueInput
  }

  /**
   * order_booking findUniqueOrThrow
   */
  export type order_bookingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order_booking
     */
    select?: order_bookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: order_bookingInclude<ExtArgs> | null
    /**
     * Filter, which order_booking to fetch.
     */
    where: order_bookingWhereUniqueInput
  }

  /**
   * order_booking findFirst
   */
  export type order_bookingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order_booking
     */
    select?: order_bookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: order_bookingInclude<ExtArgs> | null
    /**
     * Filter, which order_booking to fetch.
     */
    where?: order_bookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of order_bookings to fetch.
     */
    orderBy?: order_bookingOrderByWithRelationInput | order_bookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for order_bookings.
     */
    cursor?: order_bookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` order_bookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` order_bookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of order_bookings.
     */
    distinct?: Order_bookingScalarFieldEnum | Order_bookingScalarFieldEnum[]
  }

  /**
   * order_booking findFirstOrThrow
   */
  export type order_bookingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order_booking
     */
    select?: order_bookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: order_bookingInclude<ExtArgs> | null
    /**
     * Filter, which order_booking to fetch.
     */
    where?: order_bookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of order_bookings to fetch.
     */
    orderBy?: order_bookingOrderByWithRelationInput | order_bookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for order_bookings.
     */
    cursor?: order_bookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` order_bookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` order_bookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of order_bookings.
     */
    distinct?: Order_bookingScalarFieldEnum | Order_bookingScalarFieldEnum[]
  }

  /**
   * order_booking findMany
   */
  export type order_bookingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order_booking
     */
    select?: order_bookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: order_bookingInclude<ExtArgs> | null
    /**
     * Filter, which order_bookings to fetch.
     */
    where?: order_bookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of order_bookings to fetch.
     */
    orderBy?: order_bookingOrderByWithRelationInput | order_bookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing order_bookings.
     */
    cursor?: order_bookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` order_bookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` order_bookings.
     */
    skip?: number
    distinct?: Order_bookingScalarFieldEnum | Order_bookingScalarFieldEnum[]
  }

  /**
   * order_booking create
   */
  export type order_bookingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order_booking
     */
    select?: order_bookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: order_bookingInclude<ExtArgs> | null
    /**
     * The data needed to create a order_booking.
     */
    data: XOR<order_bookingCreateInput, order_bookingUncheckedCreateInput>
  }

  /**
   * order_booking createMany
   */
  export type order_bookingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many order_bookings.
     */
    data: order_bookingCreateManyInput | order_bookingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * order_booking update
   */
  export type order_bookingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order_booking
     */
    select?: order_bookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: order_bookingInclude<ExtArgs> | null
    /**
     * The data needed to update a order_booking.
     */
    data: XOR<order_bookingUpdateInput, order_bookingUncheckedUpdateInput>
    /**
     * Choose, which order_booking to update.
     */
    where: order_bookingWhereUniqueInput
  }

  /**
   * order_booking updateMany
   */
  export type order_bookingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update order_bookings.
     */
    data: XOR<order_bookingUpdateManyMutationInput, order_bookingUncheckedUpdateManyInput>
    /**
     * Filter which order_bookings to update
     */
    where?: order_bookingWhereInput
  }

  /**
   * order_booking upsert
   */
  export type order_bookingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order_booking
     */
    select?: order_bookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: order_bookingInclude<ExtArgs> | null
    /**
     * The filter to search for the order_booking to update in case it exists.
     */
    where: order_bookingWhereUniqueInput
    /**
     * In case the order_booking found by the `where` argument doesn't exist, create a new order_booking with this data.
     */
    create: XOR<order_bookingCreateInput, order_bookingUncheckedCreateInput>
    /**
     * In case the order_booking was found with the provided `where` argument, update it with this data.
     */
    update: XOR<order_bookingUpdateInput, order_bookingUncheckedUpdateInput>
  }

  /**
   * order_booking delete
   */
  export type order_bookingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order_booking
     */
    select?: order_bookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: order_bookingInclude<ExtArgs> | null
    /**
     * Filter which order_booking to delete.
     */
    where: order_bookingWhereUniqueInput
  }

  /**
   * order_booking deleteMany
   */
  export type order_bookingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which order_bookings to delete
     */
    where?: order_bookingWhereInput
  }

  /**
   * order_booking.transaksi
   */
  export type order_booking$transaksiArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transaksi
     */
    select?: transaksiSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transaksiInclude<ExtArgs> | null
    where?: transaksiWhereInput
  }

  /**
   * order_booking.refund
   */
  export type order_booking$refundArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the refund
     */
    select?: refundSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: refundInclude<ExtArgs> | null
    where?: refundWhereInput
  }

  /**
   * order_booking.wallet_histories
   */
  export type order_booking$wallet_historiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wallet_history
     */
    select?: wallet_historySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: wallet_historyInclude<ExtArgs> | null
    where?: wallet_historyWhereInput
    orderBy?: wallet_historyOrderByWithRelationInput | wallet_historyOrderByWithRelationInput[]
    cursor?: wallet_historyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Wallet_historyScalarFieldEnum | Wallet_historyScalarFieldEnum[]
  }

  /**
   * order_booking without action
   */
  export type order_bookingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order_booking
     */
    select?: order_bookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: order_bookingInclude<ExtArgs> | null
  }


  /**
   * Model transaksi
   */

  export type AggregateTransaksi = {
    _count: TransaksiCountAggregateOutputType | null
    _avg: TransaksiAvgAggregateOutputType | null
    _sum: TransaksiSumAggregateOutputType | null
    _min: TransaksiMinAggregateOutputType | null
    _max: TransaksiMaxAggregateOutputType | null
  }

  export type TransaksiAvgAggregateOutputType = {
    id: number | null
    user_id: number | null
    lapangan_id: number | null
    jadwal_id: number | null
    order_id: number | null
    total_harga: Decimal | null
  }

  export type TransaksiSumAggregateOutputType = {
    id: number | null
    user_id: number | null
    lapangan_id: number | null
    jadwal_id: number | null
    order_id: number | null
    total_harga: Decimal | null
  }

  export type TransaksiMinAggregateOutputType = {
    id: number | null
    user_id: number | null
    lapangan_id: number | null
    jadwal_id: number | null
    order_id: number | null
    total_harga: Decimal | null
    status_pembayaran: $Enums.transaksi_status_pembayaran | null
    created_at: Date | null
  }

  export type TransaksiMaxAggregateOutputType = {
    id: number | null
    user_id: number | null
    lapangan_id: number | null
    jadwal_id: number | null
    order_id: number | null
    total_harga: Decimal | null
    status_pembayaran: $Enums.transaksi_status_pembayaran | null
    created_at: Date | null
  }

  export type TransaksiCountAggregateOutputType = {
    id: number
    user_id: number
    lapangan_id: number
    jadwal_id: number
    order_id: number
    total_harga: number
    status_pembayaran: number
    created_at: number
    _all: number
  }


  export type TransaksiAvgAggregateInputType = {
    id?: true
    user_id?: true
    lapangan_id?: true
    jadwal_id?: true
    order_id?: true
    total_harga?: true
  }

  export type TransaksiSumAggregateInputType = {
    id?: true
    user_id?: true
    lapangan_id?: true
    jadwal_id?: true
    order_id?: true
    total_harga?: true
  }

  export type TransaksiMinAggregateInputType = {
    id?: true
    user_id?: true
    lapangan_id?: true
    jadwal_id?: true
    order_id?: true
    total_harga?: true
    status_pembayaran?: true
    created_at?: true
  }

  export type TransaksiMaxAggregateInputType = {
    id?: true
    user_id?: true
    lapangan_id?: true
    jadwal_id?: true
    order_id?: true
    total_harga?: true
    status_pembayaran?: true
    created_at?: true
  }

  export type TransaksiCountAggregateInputType = {
    id?: true
    user_id?: true
    lapangan_id?: true
    jadwal_id?: true
    order_id?: true
    total_harga?: true
    status_pembayaran?: true
    created_at?: true
    _all?: true
  }

  export type TransaksiAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which transaksi to aggregate.
     */
    where?: transaksiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of transaksis to fetch.
     */
    orderBy?: transaksiOrderByWithRelationInput | transaksiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: transaksiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` transaksis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` transaksis.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned transaksis
    **/
    _count?: true | TransaksiCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TransaksiAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TransaksiSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TransaksiMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TransaksiMaxAggregateInputType
  }

  export type GetTransaksiAggregateType<T extends TransaksiAggregateArgs> = {
        [P in keyof T & keyof AggregateTransaksi]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTransaksi[P]>
      : GetScalarType<T[P], AggregateTransaksi[P]>
  }




  export type transaksiGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: transaksiWhereInput
    orderBy?: transaksiOrderByWithAggregationInput | transaksiOrderByWithAggregationInput[]
    by: TransaksiScalarFieldEnum[] | TransaksiScalarFieldEnum
    having?: transaksiScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TransaksiCountAggregateInputType | true
    _avg?: TransaksiAvgAggregateInputType
    _sum?: TransaksiSumAggregateInputType
    _min?: TransaksiMinAggregateInputType
    _max?: TransaksiMaxAggregateInputType
  }

  export type TransaksiGroupByOutputType = {
    id: number
    user_id: number
    lapangan_id: number
    jadwal_id: number
    order_id: number | null
    total_harga: Decimal
    status_pembayaran: $Enums.transaksi_status_pembayaran
    created_at: Date
    _count: TransaksiCountAggregateOutputType | null
    _avg: TransaksiAvgAggregateOutputType | null
    _sum: TransaksiSumAggregateOutputType | null
    _min: TransaksiMinAggregateOutputType | null
    _max: TransaksiMaxAggregateOutputType | null
  }

  type GetTransaksiGroupByPayload<T extends transaksiGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TransaksiGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TransaksiGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TransaksiGroupByOutputType[P]>
            : GetScalarType<T[P], TransaksiGroupByOutputType[P]>
        }
      >
    >


  export type transaksiSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    lapangan_id?: boolean
    jadwal_id?: boolean
    order_id?: boolean
    total_harga?: boolean
    status_pembayaran?: boolean
    created_at?: boolean
    user?: boolean | usersDefaultArgs<ExtArgs>
    lapangan?: boolean | LapanganDefaultArgs<ExtArgs>
    jadwal?: boolean | JadwalLapanganDefaultArgs<ExtArgs>
    order?: boolean | transaksi$orderArgs<ExtArgs>
    refund?: boolean | transaksi$refundArgs<ExtArgs>
    sewa_raket?: boolean | transaksi$sewa_raketArgs<ExtArgs>
    _count?: boolean | TransaksiCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transaksi"]>


  export type transaksiSelectScalar = {
    id?: boolean
    user_id?: boolean
    lapangan_id?: boolean
    jadwal_id?: boolean
    order_id?: boolean
    total_harga?: boolean
    status_pembayaran?: boolean
    created_at?: boolean
  }

  export type transaksiInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | usersDefaultArgs<ExtArgs>
    lapangan?: boolean | LapanganDefaultArgs<ExtArgs>
    jadwal?: boolean | JadwalLapanganDefaultArgs<ExtArgs>
    order?: boolean | transaksi$orderArgs<ExtArgs>
    refund?: boolean | transaksi$refundArgs<ExtArgs>
    sewa_raket?: boolean | transaksi$sewa_raketArgs<ExtArgs>
    _count?: boolean | TransaksiCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $transaksiPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "transaksi"
    objects: {
      user: Prisma.$usersPayload<ExtArgs>
      lapangan: Prisma.$LapanganPayload<ExtArgs>
      jadwal: Prisma.$JadwalLapanganPayload<ExtArgs>
      order: Prisma.$order_bookingPayload<ExtArgs> | null
      refund: Prisma.$refundPayload<ExtArgs> | null
      sewa_raket: Prisma.$sewa_raketPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      user_id: number
      lapangan_id: number
      jadwal_id: number
      order_id: number | null
      total_harga: Prisma.Decimal
      status_pembayaran: $Enums.transaksi_status_pembayaran
      created_at: Date
    }, ExtArgs["result"]["transaksi"]>
    composites: {}
  }

  type transaksiGetPayload<S extends boolean | null | undefined | transaksiDefaultArgs> = $Result.GetResult<Prisma.$transaksiPayload, S>

  type transaksiCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<transaksiFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TransaksiCountAggregateInputType | true
    }

  export interface transaksiDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['transaksi'], meta: { name: 'transaksi' } }
    /**
     * Find zero or one Transaksi that matches the filter.
     * @param {transaksiFindUniqueArgs} args - Arguments to find a Transaksi
     * @example
     * // Get one Transaksi
     * const transaksi = await prisma.transaksi.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends transaksiFindUniqueArgs>(args: SelectSubset<T, transaksiFindUniqueArgs<ExtArgs>>): Prisma__transaksiClient<$Result.GetResult<Prisma.$transaksiPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Transaksi that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {transaksiFindUniqueOrThrowArgs} args - Arguments to find a Transaksi
     * @example
     * // Get one Transaksi
     * const transaksi = await prisma.transaksi.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends transaksiFindUniqueOrThrowArgs>(args: SelectSubset<T, transaksiFindUniqueOrThrowArgs<ExtArgs>>): Prisma__transaksiClient<$Result.GetResult<Prisma.$transaksiPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Transaksi that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {transaksiFindFirstArgs} args - Arguments to find a Transaksi
     * @example
     * // Get one Transaksi
     * const transaksi = await prisma.transaksi.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends transaksiFindFirstArgs>(args?: SelectSubset<T, transaksiFindFirstArgs<ExtArgs>>): Prisma__transaksiClient<$Result.GetResult<Prisma.$transaksiPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Transaksi that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {transaksiFindFirstOrThrowArgs} args - Arguments to find a Transaksi
     * @example
     * // Get one Transaksi
     * const transaksi = await prisma.transaksi.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends transaksiFindFirstOrThrowArgs>(args?: SelectSubset<T, transaksiFindFirstOrThrowArgs<ExtArgs>>): Prisma__transaksiClient<$Result.GetResult<Prisma.$transaksiPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Transaksis that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {transaksiFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Transaksis
     * const transaksis = await prisma.transaksi.findMany()
     * 
     * // Get first 10 Transaksis
     * const transaksis = await prisma.transaksi.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const transaksiWithIdOnly = await prisma.transaksi.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends transaksiFindManyArgs>(args?: SelectSubset<T, transaksiFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$transaksiPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Transaksi.
     * @param {transaksiCreateArgs} args - Arguments to create a Transaksi.
     * @example
     * // Create one Transaksi
     * const Transaksi = await prisma.transaksi.create({
     *   data: {
     *     // ... data to create a Transaksi
     *   }
     * })
     * 
     */
    create<T extends transaksiCreateArgs>(args: SelectSubset<T, transaksiCreateArgs<ExtArgs>>): Prisma__transaksiClient<$Result.GetResult<Prisma.$transaksiPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Transaksis.
     * @param {transaksiCreateManyArgs} args - Arguments to create many Transaksis.
     * @example
     * // Create many Transaksis
     * const transaksi = await prisma.transaksi.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends transaksiCreateManyArgs>(args?: SelectSubset<T, transaksiCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Transaksi.
     * @param {transaksiDeleteArgs} args - Arguments to delete one Transaksi.
     * @example
     * // Delete one Transaksi
     * const Transaksi = await prisma.transaksi.delete({
     *   where: {
     *     // ... filter to delete one Transaksi
     *   }
     * })
     * 
     */
    delete<T extends transaksiDeleteArgs>(args: SelectSubset<T, transaksiDeleteArgs<ExtArgs>>): Prisma__transaksiClient<$Result.GetResult<Prisma.$transaksiPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Transaksi.
     * @param {transaksiUpdateArgs} args - Arguments to update one Transaksi.
     * @example
     * // Update one Transaksi
     * const transaksi = await prisma.transaksi.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends transaksiUpdateArgs>(args: SelectSubset<T, transaksiUpdateArgs<ExtArgs>>): Prisma__transaksiClient<$Result.GetResult<Prisma.$transaksiPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Transaksis.
     * @param {transaksiDeleteManyArgs} args - Arguments to filter Transaksis to delete.
     * @example
     * // Delete a few Transaksis
     * const { count } = await prisma.transaksi.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends transaksiDeleteManyArgs>(args?: SelectSubset<T, transaksiDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Transaksis.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {transaksiUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Transaksis
     * const transaksi = await prisma.transaksi.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends transaksiUpdateManyArgs>(args: SelectSubset<T, transaksiUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Transaksi.
     * @param {transaksiUpsertArgs} args - Arguments to update or create a Transaksi.
     * @example
     * // Update or create a Transaksi
     * const transaksi = await prisma.transaksi.upsert({
     *   create: {
     *     // ... data to create a Transaksi
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Transaksi we want to update
     *   }
     * })
     */
    upsert<T extends transaksiUpsertArgs>(args: SelectSubset<T, transaksiUpsertArgs<ExtArgs>>): Prisma__transaksiClient<$Result.GetResult<Prisma.$transaksiPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Transaksis.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {transaksiCountArgs} args - Arguments to filter Transaksis to count.
     * @example
     * // Count the number of Transaksis
     * const count = await prisma.transaksi.count({
     *   where: {
     *     // ... the filter for the Transaksis we want to count
     *   }
     * })
    **/
    count<T extends transaksiCountArgs>(
      args?: Subset<T, transaksiCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TransaksiCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Transaksi.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransaksiAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TransaksiAggregateArgs>(args: Subset<T, TransaksiAggregateArgs>): Prisma.PrismaPromise<GetTransaksiAggregateType<T>>

    /**
     * Group by Transaksi.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {transaksiGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends transaksiGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: transaksiGroupByArgs['orderBy'] }
        : { orderBy?: transaksiGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, transaksiGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTransaksiGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the transaksi model
   */
  readonly fields: transaksiFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for transaksi.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__transaksiClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    lapangan<T extends LapanganDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LapanganDefaultArgs<ExtArgs>>): Prisma__LapanganClient<$Result.GetResult<Prisma.$LapanganPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    jadwal<T extends JadwalLapanganDefaultArgs<ExtArgs> = {}>(args?: Subset<T, JadwalLapanganDefaultArgs<ExtArgs>>): Prisma__JadwalLapanganClient<$Result.GetResult<Prisma.$JadwalLapanganPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    order<T extends transaksi$orderArgs<ExtArgs> = {}>(args?: Subset<T, transaksi$orderArgs<ExtArgs>>): Prisma__order_bookingClient<$Result.GetResult<Prisma.$order_bookingPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    refund<T extends transaksi$refundArgs<ExtArgs> = {}>(args?: Subset<T, transaksi$refundArgs<ExtArgs>>): Prisma__refundClient<$Result.GetResult<Prisma.$refundPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    sewa_raket<T extends transaksi$sewa_raketArgs<ExtArgs> = {}>(args?: Subset<T, transaksi$sewa_raketArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$sewa_raketPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the transaksi model
   */ 
  interface transaksiFieldRefs {
    readonly id: FieldRef<"transaksi", 'Int'>
    readonly user_id: FieldRef<"transaksi", 'Int'>
    readonly lapangan_id: FieldRef<"transaksi", 'Int'>
    readonly jadwal_id: FieldRef<"transaksi", 'Int'>
    readonly order_id: FieldRef<"transaksi", 'Int'>
    readonly total_harga: FieldRef<"transaksi", 'Decimal'>
    readonly status_pembayaran: FieldRef<"transaksi", 'transaksi_status_pembayaran'>
    readonly created_at: FieldRef<"transaksi", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * transaksi findUnique
   */
  export type transaksiFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transaksi
     */
    select?: transaksiSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transaksiInclude<ExtArgs> | null
    /**
     * Filter, which transaksi to fetch.
     */
    where: transaksiWhereUniqueInput
  }

  /**
   * transaksi findUniqueOrThrow
   */
  export type transaksiFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transaksi
     */
    select?: transaksiSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transaksiInclude<ExtArgs> | null
    /**
     * Filter, which transaksi to fetch.
     */
    where: transaksiWhereUniqueInput
  }

  /**
   * transaksi findFirst
   */
  export type transaksiFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transaksi
     */
    select?: transaksiSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transaksiInclude<ExtArgs> | null
    /**
     * Filter, which transaksi to fetch.
     */
    where?: transaksiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of transaksis to fetch.
     */
    orderBy?: transaksiOrderByWithRelationInput | transaksiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for transaksis.
     */
    cursor?: transaksiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` transaksis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` transaksis.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of transaksis.
     */
    distinct?: TransaksiScalarFieldEnum | TransaksiScalarFieldEnum[]
  }

  /**
   * transaksi findFirstOrThrow
   */
  export type transaksiFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transaksi
     */
    select?: transaksiSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transaksiInclude<ExtArgs> | null
    /**
     * Filter, which transaksi to fetch.
     */
    where?: transaksiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of transaksis to fetch.
     */
    orderBy?: transaksiOrderByWithRelationInput | transaksiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for transaksis.
     */
    cursor?: transaksiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` transaksis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` transaksis.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of transaksis.
     */
    distinct?: TransaksiScalarFieldEnum | TransaksiScalarFieldEnum[]
  }

  /**
   * transaksi findMany
   */
  export type transaksiFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transaksi
     */
    select?: transaksiSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transaksiInclude<ExtArgs> | null
    /**
     * Filter, which transaksis to fetch.
     */
    where?: transaksiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of transaksis to fetch.
     */
    orderBy?: transaksiOrderByWithRelationInput | transaksiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing transaksis.
     */
    cursor?: transaksiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` transaksis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` transaksis.
     */
    skip?: number
    distinct?: TransaksiScalarFieldEnum | TransaksiScalarFieldEnum[]
  }

  /**
   * transaksi create
   */
  export type transaksiCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transaksi
     */
    select?: transaksiSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transaksiInclude<ExtArgs> | null
    /**
     * The data needed to create a transaksi.
     */
    data: XOR<transaksiCreateInput, transaksiUncheckedCreateInput>
  }

  /**
   * transaksi createMany
   */
  export type transaksiCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many transaksis.
     */
    data: transaksiCreateManyInput | transaksiCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * transaksi update
   */
  export type transaksiUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transaksi
     */
    select?: transaksiSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transaksiInclude<ExtArgs> | null
    /**
     * The data needed to update a transaksi.
     */
    data: XOR<transaksiUpdateInput, transaksiUncheckedUpdateInput>
    /**
     * Choose, which transaksi to update.
     */
    where: transaksiWhereUniqueInput
  }

  /**
   * transaksi updateMany
   */
  export type transaksiUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update transaksis.
     */
    data: XOR<transaksiUpdateManyMutationInput, transaksiUncheckedUpdateManyInput>
    /**
     * Filter which transaksis to update
     */
    where?: transaksiWhereInput
  }

  /**
   * transaksi upsert
   */
  export type transaksiUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transaksi
     */
    select?: transaksiSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transaksiInclude<ExtArgs> | null
    /**
     * The filter to search for the transaksi to update in case it exists.
     */
    where: transaksiWhereUniqueInput
    /**
     * In case the transaksi found by the `where` argument doesn't exist, create a new transaksi with this data.
     */
    create: XOR<transaksiCreateInput, transaksiUncheckedCreateInput>
    /**
     * In case the transaksi was found with the provided `where` argument, update it with this data.
     */
    update: XOR<transaksiUpdateInput, transaksiUncheckedUpdateInput>
  }

  /**
   * transaksi delete
   */
  export type transaksiDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transaksi
     */
    select?: transaksiSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transaksiInclude<ExtArgs> | null
    /**
     * Filter which transaksi to delete.
     */
    where: transaksiWhereUniqueInput
  }

  /**
   * transaksi deleteMany
   */
  export type transaksiDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which transaksis to delete
     */
    where?: transaksiWhereInput
  }

  /**
   * transaksi.order
   */
  export type transaksi$orderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order_booking
     */
    select?: order_bookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: order_bookingInclude<ExtArgs> | null
    where?: order_bookingWhereInput
  }

  /**
   * transaksi.refund
   */
  export type transaksi$refundArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the refund
     */
    select?: refundSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: refundInclude<ExtArgs> | null
    where?: refundWhereInput
  }

  /**
   * transaksi.sewa_raket
   */
  export type transaksi$sewa_raketArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sewa_raket
     */
    select?: sewa_raketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sewa_raketInclude<ExtArgs> | null
    where?: sewa_raketWhereInput
    orderBy?: sewa_raketOrderByWithRelationInput | sewa_raketOrderByWithRelationInput[]
    cursor?: sewa_raketWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Sewa_raketScalarFieldEnum | Sewa_raketScalarFieldEnum[]
  }

  /**
   * transaksi without action
   */
  export type transaksiDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transaksi
     */
    select?: transaksiSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transaksiInclude<ExtArgs> | null
  }


  /**
   * Model raket_padel
   */

  export type AggregateRaket_padel = {
    _count: Raket_padelCountAggregateOutputType | null
    _avg: Raket_padelAvgAggregateOutputType | null
    _sum: Raket_padelSumAggregateOutputType | null
    _min: Raket_padelMinAggregateOutputType | null
    _max: Raket_padelMaxAggregateOutputType | null
  }

  export type Raket_padelAvgAggregateOutputType = {
    id: number | null
    harga: Decimal | null
  }

  export type Raket_padelSumAggregateOutputType = {
    id: number | null
    harga: Decimal | null
  }

  export type Raket_padelMinAggregateOutputType = {
    id: number | null
    nama: string | null
    harga: Decimal | null
  }

  export type Raket_padelMaxAggregateOutputType = {
    id: number | null
    nama: string | null
    harga: Decimal | null
  }

  export type Raket_padelCountAggregateOutputType = {
    id: number
    nama: number
    harga: number
    _all: number
  }


  export type Raket_padelAvgAggregateInputType = {
    id?: true
    harga?: true
  }

  export type Raket_padelSumAggregateInputType = {
    id?: true
    harga?: true
  }

  export type Raket_padelMinAggregateInputType = {
    id?: true
    nama?: true
    harga?: true
  }

  export type Raket_padelMaxAggregateInputType = {
    id?: true
    nama?: true
    harga?: true
  }

  export type Raket_padelCountAggregateInputType = {
    id?: true
    nama?: true
    harga?: true
    _all?: true
  }

  export type Raket_padelAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which raket_padel to aggregate.
     */
    where?: raket_padelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of raket_padels to fetch.
     */
    orderBy?: raket_padelOrderByWithRelationInput | raket_padelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: raket_padelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` raket_padels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` raket_padels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned raket_padels
    **/
    _count?: true | Raket_padelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Raket_padelAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Raket_padelSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Raket_padelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Raket_padelMaxAggregateInputType
  }

  export type GetRaket_padelAggregateType<T extends Raket_padelAggregateArgs> = {
        [P in keyof T & keyof AggregateRaket_padel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRaket_padel[P]>
      : GetScalarType<T[P], AggregateRaket_padel[P]>
  }




  export type raket_padelGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: raket_padelWhereInput
    orderBy?: raket_padelOrderByWithAggregationInput | raket_padelOrderByWithAggregationInput[]
    by: Raket_padelScalarFieldEnum[] | Raket_padelScalarFieldEnum
    having?: raket_padelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Raket_padelCountAggregateInputType | true
    _avg?: Raket_padelAvgAggregateInputType
    _sum?: Raket_padelSumAggregateInputType
    _min?: Raket_padelMinAggregateInputType
    _max?: Raket_padelMaxAggregateInputType
  }

  export type Raket_padelGroupByOutputType = {
    id: number
    nama: string
    harga: Decimal
    _count: Raket_padelCountAggregateOutputType | null
    _avg: Raket_padelAvgAggregateOutputType | null
    _sum: Raket_padelSumAggregateOutputType | null
    _min: Raket_padelMinAggregateOutputType | null
    _max: Raket_padelMaxAggregateOutputType | null
  }

  type GetRaket_padelGroupByPayload<T extends raket_padelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Raket_padelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Raket_padelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Raket_padelGroupByOutputType[P]>
            : GetScalarType<T[P], Raket_padelGroupByOutputType[P]>
        }
      >
    >


  export type raket_padelSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nama?: boolean
    harga?: boolean
    sewa_raket?: boolean | raket_padel$sewa_raketArgs<ExtArgs>
    _count?: boolean | Raket_padelCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["raket_padel"]>


  export type raket_padelSelectScalar = {
    id?: boolean
    nama?: boolean
    harga?: boolean
  }

  export type raket_padelInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sewa_raket?: boolean | raket_padel$sewa_raketArgs<ExtArgs>
    _count?: boolean | Raket_padelCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $raket_padelPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "raket_padel"
    objects: {
      sewa_raket: Prisma.$sewa_raketPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nama: string
      harga: Prisma.Decimal
    }, ExtArgs["result"]["raket_padel"]>
    composites: {}
  }

  type raket_padelGetPayload<S extends boolean | null | undefined | raket_padelDefaultArgs> = $Result.GetResult<Prisma.$raket_padelPayload, S>

  type raket_padelCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<raket_padelFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Raket_padelCountAggregateInputType | true
    }

  export interface raket_padelDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['raket_padel'], meta: { name: 'raket_padel' } }
    /**
     * Find zero or one Raket_padel that matches the filter.
     * @param {raket_padelFindUniqueArgs} args - Arguments to find a Raket_padel
     * @example
     * // Get one Raket_padel
     * const raket_padel = await prisma.raket_padel.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends raket_padelFindUniqueArgs>(args: SelectSubset<T, raket_padelFindUniqueArgs<ExtArgs>>): Prisma__raket_padelClient<$Result.GetResult<Prisma.$raket_padelPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Raket_padel that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {raket_padelFindUniqueOrThrowArgs} args - Arguments to find a Raket_padel
     * @example
     * // Get one Raket_padel
     * const raket_padel = await prisma.raket_padel.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends raket_padelFindUniqueOrThrowArgs>(args: SelectSubset<T, raket_padelFindUniqueOrThrowArgs<ExtArgs>>): Prisma__raket_padelClient<$Result.GetResult<Prisma.$raket_padelPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Raket_padel that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {raket_padelFindFirstArgs} args - Arguments to find a Raket_padel
     * @example
     * // Get one Raket_padel
     * const raket_padel = await prisma.raket_padel.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends raket_padelFindFirstArgs>(args?: SelectSubset<T, raket_padelFindFirstArgs<ExtArgs>>): Prisma__raket_padelClient<$Result.GetResult<Prisma.$raket_padelPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Raket_padel that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {raket_padelFindFirstOrThrowArgs} args - Arguments to find a Raket_padel
     * @example
     * // Get one Raket_padel
     * const raket_padel = await prisma.raket_padel.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends raket_padelFindFirstOrThrowArgs>(args?: SelectSubset<T, raket_padelFindFirstOrThrowArgs<ExtArgs>>): Prisma__raket_padelClient<$Result.GetResult<Prisma.$raket_padelPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Raket_padels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {raket_padelFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Raket_padels
     * const raket_padels = await prisma.raket_padel.findMany()
     * 
     * // Get first 10 Raket_padels
     * const raket_padels = await prisma.raket_padel.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const raket_padelWithIdOnly = await prisma.raket_padel.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends raket_padelFindManyArgs>(args?: SelectSubset<T, raket_padelFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$raket_padelPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Raket_padel.
     * @param {raket_padelCreateArgs} args - Arguments to create a Raket_padel.
     * @example
     * // Create one Raket_padel
     * const Raket_padel = await prisma.raket_padel.create({
     *   data: {
     *     // ... data to create a Raket_padel
     *   }
     * })
     * 
     */
    create<T extends raket_padelCreateArgs>(args: SelectSubset<T, raket_padelCreateArgs<ExtArgs>>): Prisma__raket_padelClient<$Result.GetResult<Prisma.$raket_padelPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Raket_padels.
     * @param {raket_padelCreateManyArgs} args - Arguments to create many Raket_padels.
     * @example
     * // Create many Raket_padels
     * const raket_padel = await prisma.raket_padel.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends raket_padelCreateManyArgs>(args?: SelectSubset<T, raket_padelCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Raket_padel.
     * @param {raket_padelDeleteArgs} args - Arguments to delete one Raket_padel.
     * @example
     * // Delete one Raket_padel
     * const Raket_padel = await prisma.raket_padel.delete({
     *   where: {
     *     // ... filter to delete one Raket_padel
     *   }
     * })
     * 
     */
    delete<T extends raket_padelDeleteArgs>(args: SelectSubset<T, raket_padelDeleteArgs<ExtArgs>>): Prisma__raket_padelClient<$Result.GetResult<Prisma.$raket_padelPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Raket_padel.
     * @param {raket_padelUpdateArgs} args - Arguments to update one Raket_padel.
     * @example
     * // Update one Raket_padel
     * const raket_padel = await prisma.raket_padel.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends raket_padelUpdateArgs>(args: SelectSubset<T, raket_padelUpdateArgs<ExtArgs>>): Prisma__raket_padelClient<$Result.GetResult<Prisma.$raket_padelPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Raket_padels.
     * @param {raket_padelDeleteManyArgs} args - Arguments to filter Raket_padels to delete.
     * @example
     * // Delete a few Raket_padels
     * const { count } = await prisma.raket_padel.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends raket_padelDeleteManyArgs>(args?: SelectSubset<T, raket_padelDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Raket_padels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {raket_padelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Raket_padels
     * const raket_padel = await prisma.raket_padel.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends raket_padelUpdateManyArgs>(args: SelectSubset<T, raket_padelUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Raket_padel.
     * @param {raket_padelUpsertArgs} args - Arguments to update or create a Raket_padel.
     * @example
     * // Update or create a Raket_padel
     * const raket_padel = await prisma.raket_padel.upsert({
     *   create: {
     *     // ... data to create a Raket_padel
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Raket_padel we want to update
     *   }
     * })
     */
    upsert<T extends raket_padelUpsertArgs>(args: SelectSubset<T, raket_padelUpsertArgs<ExtArgs>>): Prisma__raket_padelClient<$Result.GetResult<Prisma.$raket_padelPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Raket_padels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {raket_padelCountArgs} args - Arguments to filter Raket_padels to count.
     * @example
     * // Count the number of Raket_padels
     * const count = await prisma.raket_padel.count({
     *   where: {
     *     // ... the filter for the Raket_padels we want to count
     *   }
     * })
    **/
    count<T extends raket_padelCountArgs>(
      args?: Subset<T, raket_padelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Raket_padelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Raket_padel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Raket_padelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Raket_padelAggregateArgs>(args: Subset<T, Raket_padelAggregateArgs>): Prisma.PrismaPromise<GetRaket_padelAggregateType<T>>

    /**
     * Group by Raket_padel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {raket_padelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends raket_padelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: raket_padelGroupByArgs['orderBy'] }
        : { orderBy?: raket_padelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, raket_padelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRaket_padelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the raket_padel model
   */
  readonly fields: raket_padelFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for raket_padel.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__raket_padelClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sewa_raket<T extends raket_padel$sewa_raketArgs<ExtArgs> = {}>(args?: Subset<T, raket_padel$sewa_raketArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$sewa_raketPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the raket_padel model
   */ 
  interface raket_padelFieldRefs {
    readonly id: FieldRef<"raket_padel", 'Int'>
    readonly nama: FieldRef<"raket_padel", 'String'>
    readonly harga: FieldRef<"raket_padel", 'Decimal'>
  }
    

  // Custom InputTypes
  /**
   * raket_padel findUnique
   */
  export type raket_padelFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the raket_padel
     */
    select?: raket_padelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: raket_padelInclude<ExtArgs> | null
    /**
     * Filter, which raket_padel to fetch.
     */
    where: raket_padelWhereUniqueInput
  }

  /**
   * raket_padel findUniqueOrThrow
   */
  export type raket_padelFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the raket_padel
     */
    select?: raket_padelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: raket_padelInclude<ExtArgs> | null
    /**
     * Filter, which raket_padel to fetch.
     */
    where: raket_padelWhereUniqueInput
  }

  /**
   * raket_padel findFirst
   */
  export type raket_padelFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the raket_padel
     */
    select?: raket_padelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: raket_padelInclude<ExtArgs> | null
    /**
     * Filter, which raket_padel to fetch.
     */
    where?: raket_padelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of raket_padels to fetch.
     */
    orderBy?: raket_padelOrderByWithRelationInput | raket_padelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for raket_padels.
     */
    cursor?: raket_padelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` raket_padels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` raket_padels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of raket_padels.
     */
    distinct?: Raket_padelScalarFieldEnum | Raket_padelScalarFieldEnum[]
  }

  /**
   * raket_padel findFirstOrThrow
   */
  export type raket_padelFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the raket_padel
     */
    select?: raket_padelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: raket_padelInclude<ExtArgs> | null
    /**
     * Filter, which raket_padel to fetch.
     */
    where?: raket_padelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of raket_padels to fetch.
     */
    orderBy?: raket_padelOrderByWithRelationInput | raket_padelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for raket_padels.
     */
    cursor?: raket_padelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` raket_padels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` raket_padels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of raket_padels.
     */
    distinct?: Raket_padelScalarFieldEnum | Raket_padelScalarFieldEnum[]
  }

  /**
   * raket_padel findMany
   */
  export type raket_padelFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the raket_padel
     */
    select?: raket_padelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: raket_padelInclude<ExtArgs> | null
    /**
     * Filter, which raket_padels to fetch.
     */
    where?: raket_padelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of raket_padels to fetch.
     */
    orderBy?: raket_padelOrderByWithRelationInput | raket_padelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing raket_padels.
     */
    cursor?: raket_padelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` raket_padels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` raket_padels.
     */
    skip?: number
    distinct?: Raket_padelScalarFieldEnum | Raket_padelScalarFieldEnum[]
  }

  /**
   * raket_padel create
   */
  export type raket_padelCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the raket_padel
     */
    select?: raket_padelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: raket_padelInclude<ExtArgs> | null
    /**
     * The data needed to create a raket_padel.
     */
    data: XOR<raket_padelCreateInput, raket_padelUncheckedCreateInput>
  }

  /**
   * raket_padel createMany
   */
  export type raket_padelCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many raket_padels.
     */
    data: raket_padelCreateManyInput | raket_padelCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * raket_padel update
   */
  export type raket_padelUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the raket_padel
     */
    select?: raket_padelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: raket_padelInclude<ExtArgs> | null
    /**
     * The data needed to update a raket_padel.
     */
    data: XOR<raket_padelUpdateInput, raket_padelUncheckedUpdateInput>
    /**
     * Choose, which raket_padel to update.
     */
    where: raket_padelWhereUniqueInput
  }

  /**
   * raket_padel updateMany
   */
  export type raket_padelUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update raket_padels.
     */
    data: XOR<raket_padelUpdateManyMutationInput, raket_padelUncheckedUpdateManyInput>
    /**
     * Filter which raket_padels to update
     */
    where?: raket_padelWhereInput
  }

  /**
   * raket_padel upsert
   */
  export type raket_padelUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the raket_padel
     */
    select?: raket_padelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: raket_padelInclude<ExtArgs> | null
    /**
     * The filter to search for the raket_padel to update in case it exists.
     */
    where: raket_padelWhereUniqueInput
    /**
     * In case the raket_padel found by the `where` argument doesn't exist, create a new raket_padel with this data.
     */
    create: XOR<raket_padelCreateInput, raket_padelUncheckedCreateInput>
    /**
     * In case the raket_padel was found with the provided `where` argument, update it with this data.
     */
    update: XOR<raket_padelUpdateInput, raket_padelUncheckedUpdateInput>
  }

  /**
   * raket_padel delete
   */
  export type raket_padelDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the raket_padel
     */
    select?: raket_padelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: raket_padelInclude<ExtArgs> | null
    /**
     * Filter which raket_padel to delete.
     */
    where: raket_padelWhereUniqueInput
  }

  /**
   * raket_padel deleteMany
   */
  export type raket_padelDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which raket_padels to delete
     */
    where?: raket_padelWhereInput
  }

  /**
   * raket_padel.sewa_raket
   */
  export type raket_padel$sewa_raketArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sewa_raket
     */
    select?: sewa_raketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sewa_raketInclude<ExtArgs> | null
    where?: sewa_raketWhereInput
    orderBy?: sewa_raketOrderByWithRelationInput | sewa_raketOrderByWithRelationInput[]
    cursor?: sewa_raketWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Sewa_raketScalarFieldEnum | Sewa_raketScalarFieldEnum[]
  }

  /**
   * raket_padel without action
   */
  export type raket_padelDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the raket_padel
     */
    select?: raket_padelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: raket_padelInclude<ExtArgs> | null
  }


  /**
   * Model sewa_raket
   */

  export type AggregateSewa_raket = {
    _count: Sewa_raketCountAggregateOutputType | null
    _avg: Sewa_raketAvgAggregateOutputType | null
    _sum: Sewa_raketSumAggregateOutputType | null
    _min: Sewa_raketMinAggregateOutputType | null
    _max: Sewa_raketMaxAggregateOutputType | null
  }

  export type Sewa_raketAvgAggregateOutputType = {
    id: number | null
    transaksi_id: number | null
    raket_id: number | null
    jumlah: number | null
    total_harga: Decimal | null
  }

  export type Sewa_raketSumAggregateOutputType = {
    id: number | null
    transaksi_id: number | null
    raket_id: number | null
    jumlah: number | null
    total_harga: Decimal | null
  }

  export type Sewa_raketMinAggregateOutputType = {
    id: number | null
    transaksi_id: number | null
    raket_id: number | null
    jumlah: number | null
    total_harga: Decimal | null
  }

  export type Sewa_raketMaxAggregateOutputType = {
    id: number | null
    transaksi_id: number | null
    raket_id: number | null
    jumlah: number | null
    total_harga: Decimal | null
  }

  export type Sewa_raketCountAggregateOutputType = {
    id: number
    transaksi_id: number
    raket_id: number
    jumlah: number
    total_harga: number
    _all: number
  }


  export type Sewa_raketAvgAggregateInputType = {
    id?: true
    transaksi_id?: true
    raket_id?: true
    jumlah?: true
    total_harga?: true
  }

  export type Sewa_raketSumAggregateInputType = {
    id?: true
    transaksi_id?: true
    raket_id?: true
    jumlah?: true
    total_harga?: true
  }

  export type Sewa_raketMinAggregateInputType = {
    id?: true
    transaksi_id?: true
    raket_id?: true
    jumlah?: true
    total_harga?: true
  }

  export type Sewa_raketMaxAggregateInputType = {
    id?: true
    transaksi_id?: true
    raket_id?: true
    jumlah?: true
    total_harga?: true
  }

  export type Sewa_raketCountAggregateInputType = {
    id?: true
    transaksi_id?: true
    raket_id?: true
    jumlah?: true
    total_harga?: true
    _all?: true
  }

  export type Sewa_raketAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which sewa_raket to aggregate.
     */
    where?: sewa_raketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sewa_rakets to fetch.
     */
    orderBy?: sewa_raketOrderByWithRelationInput | sewa_raketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: sewa_raketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sewa_rakets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sewa_rakets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned sewa_rakets
    **/
    _count?: true | Sewa_raketCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Sewa_raketAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Sewa_raketSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Sewa_raketMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Sewa_raketMaxAggregateInputType
  }

  export type GetSewa_raketAggregateType<T extends Sewa_raketAggregateArgs> = {
        [P in keyof T & keyof AggregateSewa_raket]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSewa_raket[P]>
      : GetScalarType<T[P], AggregateSewa_raket[P]>
  }




  export type sewa_raketGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: sewa_raketWhereInput
    orderBy?: sewa_raketOrderByWithAggregationInput | sewa_raketOrderByWithAggregationInput[]
    by: Sewa_raketScalarFieldEnum[] | Sewa_raketScalarFieldEnum
    having?: sewa_raketScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Sewa_raketCountAggregateInputType | true
    _avg?: Sewa_raketAvgAggregateInputType
    _sum?: Sewa_raketSumAggregateInputType
    _min?: Sewa_raketMinAggregateInputType
    _max?: Sewa_raketMaxAggregateInputType
  }

  export type Sewa_raketGroupByOutputType = {
    id: number
    transaksi_id: number
    raket_id: number
    jumlah: number
    total_harga: Decimal
    _count: Sewa_raketCountAggregateOutputType | null
    _avg: Sewa_raketAvgAggregateOutputType | null
    _sum: Sewa_raketSumAggregateOutputType | null
    _min: Sewa_raketMinAggregateOutputType | null
    _max: Sewa_raketMaxAggregateOutputType | null
  }

  type GetSewa_raketGroupByPayload<T extends sewa_raketGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Sewa_raketGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Sewa_raketGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Sewa_raketGroupByOutputType[P]>
            : GetScalarType<T[P], Sewa_raketGroupByOutputType[P]>
        }
      >
    >


  export type sewa_raketSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    transaksi_id?: boolean
    raket_id?: boolean
    jumlah?: boolean
    total_harga?: boolean
    transaksi?: boolean | transaksiDefaultArgs<ExtArgs>
    raket?: boolean | raket_padelDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sewa_raket"]>


  export type sewa_raketSelectScalar = {
    id?: boolean
    transaksi_id?: boolean
    raket_id?: boolean
    jumlah?: boolean
    total_harga?: boolean
  }

  export type sewa_raketInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transaksi?: boolean | transaksiDefaultArgs<ExtArgs>
    raket?: boolean | raket_padelDefaultArgs<ExtArgs>
  }

  export type $sewa_raketPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "sewa_raket"
    objects: {
      transaksi: Prisma.$transaksiPayload<ExtArgs>
      raket: Prisma.$raket_padelPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      transaksi_id: number
      raket_id: number
      jumlah: number
      total_harga: Prisma.Decimal
    }, ExtArgs["result"]["sewa_raket"]>
    composites: {}
  }

  type sewa_raketGetPayload<S extends boolean | null | undefined | sewa_raketDefaultArgs> = $Result.GetResult<Prisma.$sewa_raketPayload, S>

  type sewa_raketCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<sewa_raketFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Sewa_raketCountAggregateInputType | true
    }

  export interface sewa_raketDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['sewa_raket'], meta: { name: 'sewa_raket' } }
    /**
     * Find zero or one Sewa_raket that matches the filter.
     * @param {sewa_raketFindUniqueArgs} args - Arguments to find a Sewa_raket
     * @example
     * // Get one Sewa_raket
     * const sewa_raket = await prisma.sewa_raket.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends sewa_raketFindUniqueArgs>(args: SelectSubset<T, sewa_raketFindUniqueArgs<ExtArgs>>): Prisma__sewa_raketClient<$Result.GetResult<Prisma.$sewa_raketPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Sewa_raket that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {sewa_raketFindUniqueOrThrowArgs} args - Arguments to find a Sewa_raket
     * @example
     * // Get one Sewa_raket
     * const sewa_raket = await prisma.sewa_raket.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends sewa_raketFindUniqueOrThrowArgs>(args: SelectSubset<T, sewa_raketFindUniqueOrThrowArgs<ExtArgs>>): Prisma__sewa_raketClient<$Result.GetResult<Prisma.$sewa_raketPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Sewa_raket that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sewa_raketFindFirstArgs} args - Arguments to find a Sewa_raket
     * @example
     * // Get one Sewa_raket
     * const sewa_raket = await prisma.sewa_raket.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends sewa_raketFindFirstArgs>(args?: SelectSubset<T, sewa_raketFindFirstArgs<ExtArgs>>): Prisma__sewa_raketClient<$Result.GetResult<Prisma.$sewa_raketPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Sewa_raket that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sewa_raketFindFirstOrThrowArgs} args - Arguments to find a Sewa_raket
     * @example
     * // Get one Sewa_raket
     * const sewa_raket = await prisma.sewa_raket.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends sewa_raketFindFirstOrThrowArgs>(args?: SelectSubset<T, sewa_raketFindFirstOrThrowArgs<ExtArgs>>): Prisma__sewa_raketClient<$Result.GetResult<Prisma.$sewa_raketPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Sewa_rakets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sewa_raketFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sewa_rakets
     * const sewa_rakets = await prisma.sewa_raket.findMany()
     * 
     * // Get first 10 Sewa_rakets
     * const sewa_rakets = await prisma.sewa_raket.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sewa_raketWithIdOnly = await prisma.sewa_raket.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends sewa_raketFindManyArgs>(args?: SelectSubset<T, sewa_raketFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$sewa_raketPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Sewa_raket.
     * @param {sewa_raketCreateArgs} args - Arguments to create a Sewa_raket.
     * @example
     * // Create one Sewa_raket
     * const Sewa_raket = await prisma.sewa_raket.create({
     *   data: {
     *     // ... data to create a Sewa_raket
     *   }
     * })
     * 
     */
    create<T extends sewa_raketCreateArgs>(args: SelectSubset<T, sewa_raketCreateArgs<ExtArgs>>): Prisma__sewa_raketClient<$Result.GetResult<Prisma.$sewa_raketPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Sewa_rakets.
     * @param {sewa_raketCreateManyArgs} args - Arguments to create many Sewa_rakets.
     * @example
     * // Create many Sewa_rakets
     * const sewa_raket = await prisma.sewa_raket.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends sewa_raketCreateManyArgs>(args?: SelectSubset<T, sewa_raketCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Sewa_raket.
     * @param {sewa_raketDeleteArgs} args - Arguments to delete one Sewa_raket.
     * @example
     * // Delete one Sewa_raket
     * const Sewa_raket = await prisma.sewa_raket.delete({
     *   where: {
     *     // ... filter to delete one Sewa_raket
     *   }
     * })
     * 
     */
    delete<T extends sewa_raketDeleteArgs>(args: SelectSubset<T, sewa_raketDeleteArgs<ExtArgs>>): Prisma__sewa_raketClient<$Result.GetResult<Prisma.$sewa_raketPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Sewa_raket.
     * @param {sewa_raketUpdateArgs} args - Arguments to update one Sewa_raket.
     * @example
     * // Update one Sewa_raket
     * const sewa_raket = await prisma.sewa_raket.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends sewa_raketUpdateArgs>(args: SelectSubset<T, sewa_raketUpdateArgs<ExtArgs>>): Prisma__sewa_raketClient<$Result.GetResult<Prisma.$sewa_raketPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Sewa_rakets.
     * @param {sewa_raketDeleteManyArgs} args - Arguments to filter Sewa_rakets to delete.
     * @example
     * // Delete a few Sewa_rakets
     * const { count } = await prisma.sewa_raket.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends sewa_raketDeleteManyArgs>(args?: SelectSubset<T, sewa_raketDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sewa_rakets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sewa_raketUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sewa_rakets
     * const sewa_raket = await prisma.sewa_raket.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends sewa_raketUpdateManyArgs>(args: SelectSubset<T, sewa_raketUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Sewa_raket.
     * @param {sewa_raketUpsertArgs} args - Arguments to update or create a Sewa_raket.
     * @example
     * // Update or create a Sewa_raket
     * const sewa_raket = await prisma.sewa_raket.upsert({
     *   create: {
     *     // ... data to create a Sewa_raket
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Sewa_raket we want to update
     *   }
     * })
     */
    upsert<T extends sewa_raketUpsertArgs>(args: SelectSubset<T, sewa_raketUpsertArgs<ExtArgs>>): Prisma__sewa_raketClient<$Result.GetResult<Prisma.$sewa_raketPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Sewa_rakets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sewa_raketCountArgs} args - Arguments to filter Sewa_rakets to count.
     * @example
     * // Count the number of Sewa_rakets
     * const count = await prisma.sewa_raket.count({
     *   where: {
     *     // ... the filter for the Sewa_rakets we want to count
     *   }
     * })
    **/
    count<T extends sewa_raketCountArgs>(
      args?: Subset<T, sewa_raketCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Sewa_raketCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Sewa_raket.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Sewa_raketAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Sewa_raketAggregateArgs>(args: Subset<T, Sewa_raketAggregateArgs>): Prisma.PrismaPromise<GetSewa_raketAggregateType<T>>

    /**
     * Group by Sewa_raket.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sewa_raketGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends sewa_raketGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: sewa_raketGroupByArgs['orderBy'] }
        : { orderBy?: sewa_raketGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, sewa_raketGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSewa_raketGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the sewa_raket model
   */
  readonly fields: sewa_raketFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for sewa_raket.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__sewa_raketClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    transaksi<T extends transaksiDefaultArgs<ExtArgs> = {}>(args?: Subset<T, transaksiDefaultArgs<ExtArgs>>): Prisma__transaksiClient<$Result.GetResult<Prisma.$transaksiPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    raket<T extends raket_padelDefaultArgs<ExtArgs> = {}>(args?: Subset<T, raket_padelDefaultArgs<ExtArgs>>): Prisma__raket_padelClient<$Result.GetResult<Prisma.$raket_padelPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the sewa_raket model
   */ 
  interface sewa_raketFieldRefs {
    readonly id: FieldRef<"sewa_raket", 'Int'>
    readonly transaksi_id: FieldRef<"sewa_raket", 'Int'>
    readonly raket_id: FieldRef<"sewa_raket", 'Int'>
    readonly jumlah: FieldRef<"sewa_raket", 'Int'>
    readonly total_harga: FieldRef<"sewa_raket", 'Decimal'>
  }
    

  // Custom InputTypes
  /**
   * sewa_raket findUnique
   */
  export type sewa_raketFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sewa_raket
     */
    select?: sewa_raketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sewa_raketInclude<ExtArgs> | null
    /**
     * Filter, which sewa_raket to fetch.
     */
    where: sewa_raketWhereUniqueInput
  }

  /**
   * sewa_raket findUniqueOrThrow
   */
  export type sewa_raketFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sewa_raket
     */
    select?: sewa_raketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sewa_raketInclude<ExtArgs> | null
    /**
     * Filter, which sewa_raket to fetch.
     */
    where: sewa_raketWhereUniqueInput
  }

  /**
   * sewa_raket findFirst
   */
  export type sewa_raketFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sewa_raket
     */
    select?: sewa_raketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sewa_raketInclude<ExtArgs> | null
    /**
     * Filter, which sewa_raket to fetch.
     */
    where?: sewa_raketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sewa_rakets to fetch.
     */
    orderBy?: sewa_raketOrderByWithRelationInput | sewa_raketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for sewa_rakets.
     */
    cursor?: sewa_raketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sewa_rakets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sewa_rakets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of sewa_rakets.
     */
    distinct?: Sewa_raketScalarFieldEnum | Sewa_raketScalarFieldEnum[]
  }

  /**
   * sewa_raket findFirstOrThrow
   */
  export type sewa_raketFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sewa_raket
     */
    select?: sewa_raketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sewa_raketInclude<ExtArgs> | null
    /**
     * Filter, which sewa_raket to fetch.
     */
    where?: sewa_raketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sewa_rakets to fetch.
     */
    orderBy?: sewa_raketOrderByWithRelationInput | sewa_raketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for sewa_rakets.
     */
    cursor?: sewa_raketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sewa_rakets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sewa_rakets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of sewa_rakets.
     */
    distinct?: Sewa_raketScalarFieldEnum | Sewa_raketScalarFieldEnum[]
  }

  /**
   * sewa_raket findMany
   */
  export type sewa_raketFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sewa_raket
     */
    select?: sewa_raketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sewa_raketInclude<ExtArgs> | null
    /**
     * Filter, which sewa_rakets to fetch.
     */
    where?: sewa_raketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sewa_rakets to fetch.
     */
    orderBy?: sewa_raketOrderByWithRelationInput | sewa_raketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing sewa_rakets.
     */
    cursor?: sewa_raketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sewa_rakets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sewa_rakets.
     */
    skip?: number
    distinct?: Sewa_raketScalarFieldEnum | Sewa_raketScalarFieldEnum[]
  }

  /**
   * sewa_raket create
   */
  export type sewa_raketCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sewa_raket
     */
    select?: sewa_raketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sewa_raketInclude<ExtArgs> | null
    /**
     * The data needed to create a sewa_raket.
     */
    data: XOR<sewa_raketCreateInput, sewa_raketUncheckedCreateInput>
  }

  /**
   * sewa_raket createMany
   */
  export type sewa_raketCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many sewa_rakets.
     */
    data: sewa_raketCreateManyInput | sewa_raketCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * sewa_raket update
   */
  export type sewa_raketUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sewa_raket
     */
    select?: sewa_raketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sewa_raketInclude<ExtArgs> | null
    /**
     * The data needed to update a sewa_raket.
     */
    data: XOR<sewa_raketUpdateInput, sewa_raketUncheckedUpdateInput>
    /**
     * Choose, which sewa_raket to update.
     */
    where: sewa_raketWhereUniqueInput
  }

  /**
   * sewa_raket updateMany
   */
  export type sewa_raketUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update sewa_rakets.
     */
    data: XOR<sewa_raketUpdateManyMutationInput, sewa_raketUncheckedUpdateManyInput>
    /**
     * Filter which sewa_rakets to update
     */
    where?: sewa_raketWhereInput
  }

  /**
   * sewa_raket upsert
   */
  export type sewa_raketUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sewa_raket
     */
    select?: sewa_raketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sewa_raketInclude<ExtArgs> | null
    /**
     * The filter to search for the sewa_raket to update in case it exists.
     */
    where: sewa_raketWhereUniqueInput
    /**
     * In case the sewa_raket found by the `where` argument doesn't exist, create a new sewa_raket with this data.
     */
    create: XOR<sewa_raketCreateInput, sewa_raketUncheckedCreateInput>
    /**
     * In case the sewa_raket was found with the provided `where` argument, update it with this data.
     */
    update: XOR<sewa_raketUpdateInput, sewa_raketUncheckedUpdateInput>
  }

  /**
   * sewa_raket delete
   */
  export type sewa_raketDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sewa_raket
     */
    select?: sewa_raketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sewa_raketInclude<ExtArgs> | null
    /**
     * Filter which sewa_raket to delete.
     */
    where: sewa_raketWhereUniqueInput
  }

  /**
   * sewa_raket deleteMany
   */
  export type sewa_raketDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which sewa_rakets to delete
     */
    where?: sewa_raketWhereInput
  }

  /**
   * sewa_raket without action
   */
  export type sewa_raketDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sewa_raket
     */
    select?: sewa_raketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sewa_raketInclude<ExtArgs> | null
  }


  /**
   * Model wallet_user
   */

  export type AggregateWallet_user = {
    _count: Wallet_userCountAggregateOutputType | null
    _avg: Wallet_userAvgAggregateOutputType | null
    _sum: Wallet_userSumAggregateOutputType | null
    _min: Wallet_userMinAggregateOutputType | null
    _max: Wallet_userMaxAggregateOutputType | null
  }

  export type Wallet_userAvgAggregateOutputType = {
    id: number | null
    user_id: number | null
    saldo: number | null
  }

  export type Wallet_userSumAggregateOutputType = {
    id: number | null
    user_id: number | null
    saldo: number | null
  }

  export type Wallet_userMinAggregateOutputType = {
    id: number | null
    user_id: number | null
    saldo: number | null
    updated_at: Date | null
  }

  export type Wallet_userMaxAggregateOutputType = {
    id: number | null
    user_id: number | null
    saldo: number | null
    updated_at: Date | null
  }

  export type Wallet_userCountAggregateOutputType = {
    id: number
    user_id: number
    saldo: number
    updated_at: number
    _all: number
  }


  export type Wallet_userAvgAggregateInputType = {
    id?: true
    user_id?: true
    saldo?: true
  }

  export type Wallet_userSumAggregateInputType = {
    id?: true
    user_id?: true
    saldo?: true
  }

  export type Wallet_userMinAggregateInputType = {
    id?: true
    user_id?: true
    saldo?: true
    updated_at?: true
  }

  export type Wallet_userMaxAggregateInputType = {
    id?: true
    user_id?: true
    saldo?: true
    updated_at?: true
  }

  export type Wallet_userCountAggregateInputType = {
    id?: true
    user_id?: true
    saldo?: true
    updated_at?: true
    _all?: true
  }

  export type Wallet_userAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which wallet_user to aggregate.
     */
    where?: wallet_userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of wallet_users to fetch.
     */
    orderBy?: wallet_userOrderByWithRelationInput | wallet_userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: wallet_userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` wallet_users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` wallet_users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned wallet_users
    **/
    _count?: true | Wallet_userCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Wallet_userAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Wallet_userSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Wallet_userMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Wallet_userMaxAggregateInputType
  }

  export type GetWallet_userAggregateType<T extends Wallet_userAggregateArgs> = {
        [P in keyof T & keyof AggregateWallet_user]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWallet_user[P]>
      : GetScalarType<T[P], AggregateWallet_user[P]>
  }




  export type wallet_userGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: wallet_userWhereInput
    orderBy?: wallet_userOrderByWithAggregationInput | wallet_userOrderByWithAggregationInput[]
    by: Wallet_userScalarFieldEnum[] | Wallet_userScalarFieldEnum
    having?: wallet_userScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Wallet_userCountAggregateInputType | true
    _avg?: Wallet_userAvgAggregateInputType
    _sum?: Wallet_userSumAggregateInputType
    _min?: Wallet_userMinAggregateInputType
    _max?: Wallet_userMaxAggregateInputType
  }

  export type Wallet_userGroupByOutputType = {
    id: number
    user_id: number
    saldo: number
    updated_at: Date
    _count: Wallet_userCountAggregateOutputType | null
    _avg: Wallet_userAvgAggregateOutputType | null
    _sum: Wallet_userSumAggregateOutputType | null
    _min: Wallet_userMinAggregateOutputType | null
    _max: Wallet_userMaxAggregateOutputType | null
  }

  type GetWallet_userGroupByPayload<T extends wallet_userGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Wallet_userGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Wallet_userGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Wallet_userGroupByOutputType[P]>
            : GetScalarType<T[P], Wallet_userGroupByOutputType[P]>
        }
      >
    >


  export type wallet_userSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    saldo?: boolean
    updated_at?: boolean
    user?: boolean | usersDefaultArgs<ExtArgs>
    history?: boolean | wallet_user$historyArgs<ExtArgs>
    _count?: boolean | Wallet_userCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["wallet_user"]>


  export type wallet_userSelectScalar = {
    id?: boolean
    user_id?: boolean
    saldo?: boolean
    updated_at?: boolean
  }

  export type wallet_userInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | usersDefaultArgs<ExtArgs>
    history?: boolean | wallet_user$historyArgs<ExtArgs>
    _count?: boolean | Wallet_userCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $wallet_userPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "wallet_user"
    objects: {
      user: Prisma.$usersPayload<ExtArgs>
      history: Prisma.$wallet_historyPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      user_id: number
      saldo: number
      updated_at: Date
    }, ExtArgs["result"]["wallet_user"]>
    composites: {}
  }

  type wallet_userGetPayload<S extends boolean | null | undefined | wallet_userDefaultArgs> = $Result.GetResult<Prisma.$wallet_userPayload, S>

  type wallet_userCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<wallet_userFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Wallet_userCountAggregateInputType | true
    }

  export interface wallet_userDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['wallet_user'], meta: { name: 'wallet_user' } }
    /**
     * Find zero or one Wallet_user that matches the filter.
     * @param {wallet_userFindUniqueArgs} args - Arguments to find a Wallet_user
     * @example
     * // Get one Wallet_user
     * const wallet_user = await prisma.wallet_user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends wallet_userFindUniqueArgs>(args: SelectSubset<T, wallet_userFindUniqueArgs<ExtArgs>>): Prisma__wallet_userClient<$Result.GetResult<Prisma.$wallet_userPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Wallet_user that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {wallet_userFindUniqueOrThrowArgs} args - Arguments to find a Wallet_user
     * @example
     * // Get one Wallet_user
     * const wallet_user = await prisma.wallet_user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends wallet_userFindUniqueOrThrowArgs>(args: SelectSubset<T, wallet_userFindUniqueOrThrowArgs<ExtArgs>>): Prisma__wallet_userClient<$Result.GetResult<Prisma.$wallet_userPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Wallet_user that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {wallet_userFindFirstArgs} args - Arguments to find a Wallet_user
     * @example
     * // Get one Wallet_user
     * const wallet_user = await prisma.wallet_user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends wallet_userFindFirstArgs>(args?: SelectSubset<T, wallet_userFindFirstArgs<ExtArgs>>): Prisma__wallet_userClient<$Result.GetResult<Prisma.$wallet_userPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Wallet_user that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {wallet_userFindFirstOrThrowArgs} args - Arguments to find a Wallet_user
     * @example
     * // Get one Wallet_user
     * const wallet_user = await prisma.wallet_user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends wallet_userFindFirstOrThrowArgs>(args?: SelectSubset<T, wallet_userFindFirstOrThrowArgs<ExtArgs>>): Prisma__wallet_userClient<$Result.GetResult<Prisma.$wallet_userPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Wallet_users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {wallet_userFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Wallet_users
     * const wallet_users = await prisma.wallet_user.findMany()
     * 
     * // Get first 10 Wallet_users
     * const wallet_users = await prisma.wallet_user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const wallet_userWithIdOnly = await prisma.wallet_user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends wallet_userFindManyArgs>(args?: SelectSubset<T, wallet_userFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$wallet_userPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Wallet_user.
     * @param {wallet_userCreateArgs} args - Arguments to create a Wallet_user.
     * @example
     * // Create one Wallet_user
     * const Wallet_user = await prisma.wallet_user.create({
     *   data: {
     *     // ... data to create a Wallet_user
     *   }
     * })
     * 
     */
    create<T extends wallet_userCreateArgs>(args: SelectSubset<T, wallet_userCreateArgs<ExtArgs>>): Prisma__wallet_userClient<$Result.GetResult<Prisma.$wallet_userPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Wallet_users.
     * @param {wallet_userCreateManyArgs} args - Arguments to create many Wallet_users.
     * @example
     * // Create many Wallet_users
     * const wallet_user = await prisma.wallet_user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends wallet_userCreateManyArgs>(args?: SelectSubset<T, wallet_userCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Wallet_user.
     * @param {wallet_userDeleteArgs} args - Arguments to delete one Wallet_user.
     * @example
     * // Delete one Wallet_user
     * const Wallet_user = await prisma.wallet_user.delete({
     *   where: {
     *     // ... filter to delete one Wallet_user
     *   }
     * })
     * 
     */
    delete<T extends wallet_userDeleteArgs>(args: SelectSubset<T, wallet_userDeleteArgs<ExtArgs>>): Prisma__wallet_userClient<$Result.GetResult<Prisma.$wallet_userPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Wallet_user.
     * @param {wallet_userUpdateArgs} args - Arguments to update one Wallet_user.
     * @example
     * // Update one Wallet_user
     * const wallet_user = await prisma.wallet_user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends wallet_userUpdateArgs>(args: SelectSubset<T, wallet_userUpdateArgs<ExtArgs>>): Prisma__wallet_userClient<$Result.GetResult<Prisma.$wallet_userPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Wallet_users.
     * @param {wallet_userDeleteManyArgs} args - Arguments to filter Wallet_users to delete.
     * @example
     * // Delete a few Wallet_users
     * const { count } = await prisma.wallet_user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends wallet_userDeleteManyArgs>(args?: SelectSubset<T, wallet_userDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Wallet_users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {wallet_userUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Wallet_users
     * const wallet_user = await prisma.wallet_user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends wallet_userUpdateManyArgs>(args: SelectSubset<T, wallet_userUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Wallet_user.
     * @param {wallet_userUpsertArgs} args - Arguments to update or create a Wallet_user.
     * @example
     * // Update or create a Wallet_user
     * const wallet_user = await prisma.wallet_user.upsert({
     *   create: {
     *     // ... data to create a Wallet_user
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Wallet_user we want to update
     *   }
     * })
     */
    upsert<T extends wallet_userUpsertArgs>(args: SelectSubset<T, wallet_userUpsertArgs<ExtArgs>>): Prisma__wallet_userClient<$Result.GetResult<Prisma.$wallet_userPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Wallet_users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {wallet_userCountArgs} args - Arguments to filter Wallet_users to count.
     * @example
     * // Count the number of Wallet_users
     * const count = await prisma.wallet_user.count({
     *   where: {
     *     // ... the filter for the Wallet_users we want to count
     *   }
     * })
    **/
    count<T extends wallet_userCountArgs>(
      args?: Subset<T, wallet_userCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Wallet_userCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Wallet_user.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Wallet_userAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Wallet_userAggregateArgs>(args: Subset<T, Wallet_userAggregateArgs>): Prisma.PrismaPromise<GetWallet_userAggregateType<T>>

    /**
     * Group by Wallet_user.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {wallet_userGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends wallet_userGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: wallet_userGroupByArgs['orderBy'] }
        : { orderBy?: wallet_userGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, wallet_userGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWallet_userGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the wallet_user model
   */
  readonly fields: wallet_userFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for wallet_user.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__wallet_userClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    history<T extends wallet_user$historyArgs<ExtArgs> = {}>(args?: Subset<T, wallet_user$historyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$wallet_historyPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the wallet_user model
   */ 
  interface wallet_userFieldRefs {
    readonly id: FieldRef<"wallet_user", 'Int'>
    readonly user_id: FieldRef<"wallet_user", 'Int'>
    readonly saldo: FieldRef<"wallet_user", 'Int'>
    readonly updated_at: FieldRef<"wallet_user", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * wallet_user findUnique
   */
  export type wallet_userFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wallet_user
     */
    select?: wallet_userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: wallet_userInclude<ExtArgs> | null
    /**
     * Filter, which wallet_user to fetch.
     */
    where: wallet_userWhereUniqueInput
  }

  /**
   * wallet_user findUniqueOrThrow
   */
  export type wallet_userFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wallet_user
     */
    select?: wallet_userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: wallet_userInclude<ExtArgs> | null
    /**
     * Filter, which wallet_user to fetch.
     */
    where: wallet_userWhereUniqueInput
  }

  /**
   * wallet_user findFirst
   */
  export type wallet_userFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wallet_user
     */
    select?: wallet_userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: wallet_userInclude<ExtArgs> | null
    /**
     * Filter, which wallet_user to fetch.
     */
    where?: wallet_userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of wallet_users to fetch.
     */
    orderBy?: wallet_userOrderByWithRelationInput | wallet_userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for wallet_users.
     */
    cursor?: wallet_userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` wallet_users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` wallet_users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of wallet_users.
     */
    distinct?: Wallet_userScalarFieldEnum | Wallet_userScalarFieldEnum[]
  }

  /**
   * wallet_user findFirstOrThrow
   */
  export type wallet_userFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wallet_user
     */
    select?: wallet_userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: wallet_userInclude<ExtArgs> | null
    /**
     * Filter, which wallet_user to fetch.
     */
    where?: wallet_userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of wallet_users to fetch.
     */
    orderBy?: wallet_userOrderByWithRelationInput | wallet_userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for wallet_users.
     */
    cursor?: wallet_userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` wallet_users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` wallet_users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of wallet_users.
     */
    distinct?: Wallet_userScalarFieldEnum | Wallet_userScalarFieldEnum[]
  }

  /**
   * wallet_user findMany
   */
  export type wallet_userFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wallet_user
     */
    select?: wallet_userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: wallet_userInclude<ExtArgs> | null
    /**
     * Filter, which wallet_users to fetch.
     */
    where?: wallet_userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of wallet_users to fetch.
     */
    orderBy?: wallet_userOrderByWithRelationInput | wallet_userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing wallet_users.
     */
    cursor?: wallet_userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` wallet_users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` wallet_users.
     */
    skip?: number
    distinct?: Wallet_userScalarFieldEnum | Wallet_userScalarFieldEnum[]
  }

  /**
   * wallet_user create
   */
  export type wallet_userCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wallet_user
     */
    select?: wallet_userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: wallet_userInclude<ExtArgs> | null
    /**
     * The data needed to create a wallet_user.
     */
    data: XOR<wallet_userCreateInput, wallet_userUncheckedCreateInput>
  }

  /**
   * wallet_user createMany
   */
  export type wallet_userCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many wallet_users.
     */
    data: wallet_userCreateManyInput | wallet_userCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * wallet_user update
   */
  export type wallet_userUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wallet_user
     */
    select?: wallet_userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: wallet_userInclude<ExtArgs> | null
    /**
     * The data needed to update a wallet_user.
     */
    data: XOR<wallet_userUpdateInput, wallet_userUncheckedUpdateInput>
    /**
     * Choose, which wallet_user to update.
     */
    where: wallet_userWhereUniqueInput
  }

  /**
   * wallet_user updateMany
   */
  export type wallet_userUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update wallet_users.
     */
    data: XOR<wallet_userUpdateManyMutationInput, wallet_userUncheckedUpdateManyInput>
    /**
     * Filter which wallet_users to update
     */
    where?: wallet_userWhereInput
  }

  /**
   * wallet_user upsert
   */
  export type wallet_userUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wallet_user
     */
    select?: wallet_userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: wallet_userInclude<ExtArgs> | null
    /**
     * The filter to search for the wallet_user to update in case it exists.
     */
    where: wallet_userWhereUniqueInput
    /**
     * In case the wallet_user found by the `where` argument doesn't exist, create a new wallet_user with this data.
     */
    create: XOR<wallet_userCreateInput, wallet_userUncheckedCreateInput>
    /**
     * In case the wallet_user was found with the provided `where` argument, update it with this data.
     */
    update: XOR<wallet_userUpdateInput, wallet_userUncheckedUpdateInput>
  }

  /**
   * wallet_user delete
   */
  export type wallet_userDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wallet_user
     */
    select?: wallet_userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: wallet_userInclude<ExtArgs> | null
    /**
     * Filter which wallet_user to delete.
     */
    where: wallet_userWhereUniqueInput
  }

  /**
   * wallet_user deleteMany
   */
  export type wallet_userDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which wallet_users to delete
     */
    where?: wallet_userWhereInput
  }

  /**
   * wallet_user.history
   */
  export type wallet_user$historyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wallet_history
     */
    select?: wallet_historySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: wallet_historyInclude<ExtArgs> | null
    where?: wallet_historyWhereInput
    orderBy?: wallet_historyOrderByWithRelationInput | wallet_historyOrderByWithRelationInput[]
    cursor?: wallet_historyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Wallet_historyScalarFieldEnum | Wallet_historyScalarFieldEnum[]
  }

  /**
   * wallet_user without action
   */
  export type wallet_userDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wallet_user
     */
    select?: wallet_userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: wallet_userInclude<ExtArgs> | null
  }


  /**
   * Model wallet_history
   */

  export type AggregateWallet_history = {
    _count: Wallet_historyCountAggregateOutputType | null
    _avg: Wallet_historyAvgAggregateOutputType | null
    _sum: Wallet_historySumAggregateOutputType | null
    _min: Wallet_historyMinAggregateOutputType | null
    _max: Wallet_historyMaxAggregateOutputType | null
  }

  export type Wallet_historyAvgAggregateOutputType = {
    id: number | null
    wallet_id: number | null
    jumlah: number | null
    saldo_akhir: number | null
    transaksi_id: number | null
    order_id: number | null
  }

  export type Wallet_historySumAggregateOutputType = {
    id: number | null
    wallet_id: number | null
    jumlah: number | null
    saldo_akhir: number | null
    transaksi_id: number | null
    order_id: number | null
  }

  export type Wallet_historyMinAggregateOutputType = {
    id: number | null
    wallet_id: number | null
    jumlah: number | null
    saldo_akhir: number | null
    tipe: $Enums.wallet_tipe | null
    transaksi_id: number | null
    order_id: number | null
    created_at: Date | null
  }

  export type Wallet_historyMaxAggregateOutputType = {
    id: number | null
    wallet_id: number | null
    jumlah: number | null
    saldo_akhir: number | null
    tipe: $Enums.wallet_tipe | null
    transaksi_id: number | null
    order_id: number | null
    created_at: Date | null
  }

  export type Wallet_historyCountAggregateOutputType = {
    id: number
    wallet_id: number
    jumlah: number
    saldo_akhir: number
    tipe: number
    transaksi_id: number
    order_id: number
    created_at: number
    _all: number
  }


  export type Wallet_historyAvgAggregateInputType = {
    id?: true
    wallet_id?: true
    jumlah?: true
    saldo_akhir?: true
    transaksi_id?: true
    order_id?: true
  }

  export type Wallet_historySumAggregateInputType = {
    id?: true
    wallet_id?: true
    jumlah?: true
    saldo_akhir?: true
    transaksi_id?: true
    order_id?: true
  }

  export type Wallet_historyMinAggregateInputType = {
    id?: true
    wallet_id?: true
    jumlah?: true
    saldo_akhir?: true
    tipe?: true
    transaksi_id?: true
    order_id?: true
    created_at?: true
  }

  export type Wallet_historyMaxAggregateInputType = {
    id?: true
    wallet_id?: true
    jumlah?: true
    saldo_akhir?: true
    tipe?: true
    transaksi_id?: true
    order_id?: true
    created_at?: true
  }

  export type Wallet_historyCountAggregateInputType = {
    id?: true
    wallet_id?: true
    jumlah?: true
    saldo_akhir?: true
    tipe?: true
    transaksi_id?: true
    order_id?: true
    created_at?: true
    _all?: true
  }

  export type Wallet_historyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which wallet_history to aggregate.
     */
    where?: wallet_historyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of wallet_histories to fetch.
     */
    orderBy?: wallet_historyOrderByWithRelationInput | wallet_historyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: wallet_historyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` wallet_histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` wallet_histories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned wallet_histories
    **/
    _count?: true | Wallet_historyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Wallet_historyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Wallet_historySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Wallet_historyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Wallet_historyMaxAggregateInputType
  }

  export type GetWallet_historyAggregateType<T extends Wallet_historyAggregateArgs> = {
        [P in keyof T & keyof AggregateWallet_history]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWallet_history[P]>
      : GetScalarType<T[P], AggregateWallet_history[P]>
  }




  export type wallet_historyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: wallet_historyWhereInput
    orderBy?: wallet_historyOrderByWithAggregationInput | wallet_historyOrderByWithAggregationInput[]
    by: Wallet_historyScalarFieldEnum[] | Wallet_historyScalarFieldEnum
    having?: wallet_historyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Wallet_historyCountAggregateInputType | true
    _avg?: Wallet_historyAvgAggregateInputType
    _sum?: Wallet_historySumAggregateInputType
    _min?: Wallet_historyMinAggregateInputType
    _max?: Wallet_historyMaxAggregateInputType
  }

  export type Wallet_historyGroupByOutputType = {
    id: number
    wallet_id: number
    jumlah: number
    saldo_akhir: number
    tipe: $Enums.wallet_tipe
    transaksi_id: number | null
    order_id: number | null
    created_at: Date
    _count: Wallet_historyCountAggregateOutputType | null
    _avg: Wallet_historyAvgAggregateOutputType | null
    _sum: Wallet_historySumAggregateOutputType | null
    _min: Wallet_historyMinAggregateOutputType | null
    _max: Wallet_historyMaxAggregateOutputType | null
  }

  type GetWallet_historyGroupByPayload<T extends wallet_historyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Wallet_historyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Wallet_historyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Wallet_historyGroupByOutputType[P]>
            : GetScalarType<T[P], Wallet_historyGroupByOutputType[P]>
        }
      >
    >


  export type wallet_historySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    wallet_id?: boolean
    jumlah?: boolean
    saldo_akhir?: boolean
    tipe?: boolean
    transaksi_id?: boolean
    order_id?: boolean
    created_at?: boolean
    wallet?: boolean | wallet_userDefaultArgs<ExtArgs>
    order?: boolean | wallet_history$orderArgs<ExtArgs>
  }, ExtArgs["result"]["wallet_history"]>


  export type wallet_historySelectScalar = {
    id?: boolean
    wallet_id?: boolean
    jumlah?: boolean
    saldo_akhir?: boolean
    tipe?: boolean
    transaksi_id?: boolean
    order_id?: boolean
    created_at?: boolean
  }

  export type wallet_historyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    wallet?: boolean | wallet_userDefaultArgs<ExtArgs>
    order?: boolean | wallet_history$orderArgs<ExtArgs>
  }

  export type $wallet_historyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "wallet_history"
    objects: {
      wallet: Prisma.$wallet_userPayload<ExtArgs>
      order: Prisma.$order_bookingPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      wallet_id: number
      jumlah: number
      saldo_akhir: number
      tipe: $Enums.wallet_tipe
      transaksi_id: number | null
      order_id: number | null
      created_at: Date
    }, ExtArgs["result"]["wallet_history"]>
    composites: {}
  }

  type wallet_historyGetPayload<S extends boolean | null | undefined | wallet_historyDefaultArgs> = $Result.GetResult<Prisma.$wallet_historyPayload, S>

  type wallet_historyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<wallet_historyFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Wallet_historyCountAggregateInputType | true
    }

  export interface wallet_historyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['wallet_history'], meta: { name: 'wallet_history' } }
    /**
     * Find zero or one Wallet_history that matches the filter.
     * @param {wallet_historyFindUniqueArgs} args - Arguments to find a Wallet_history
     * @example
     * // Get one Wallet_history
     * const wallet_history = await prisma.wallet_history.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends wallet_historyFindUniqueArgs>(args: SelectSubset<T, wallet_historyFindUniqueArgs<ExtArgs>>): Prisma__wallet_historyClient<$Result.GetResult<Prisma.$wallet_historyPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Wallet_history that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {wallet_historyFindUniqueOrThrowArgs} args - Arguments to find a Wallet_history
     * @example
     * // Get one Wallet_history
     * const wallet_history = await prisma.wallet_history.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends wallet_historyFindUniqueOrThrowArgs>(args: SelectSubset<T, wallet_historyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__wallet_historyClient<$Result.GetResult<Prisma.$wallet_historyPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Wallet_history that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {wallet_historyFindFirstArgs} args - Arguments to find a Wallet_history
     * @example
     * // Get one Wallet_history
     * const wallet_history = await prisma.wallet_history.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends wallet_historyFindFirstArgs>(args?: SelectSubset<T, wallet_historyFindFirstArgs<ExtArgs>>): Prisma__wallet_historyClient<$Result.GetResult<Prisma.$wallet_historyPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Wallet_history that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {wallet_historyFindFirstOrThrowArgs} args - Arguments to find a Wallet_history
     * @example
     * // Get one Wallet_history
     * const wallet_history = await prisma.wallet_history.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends wallet_historyFindFirstOrThrowArgs>(args?: SelectSubset<T, wallet_historyFindFirstOrThrowArgs<ExtArgs>>): Prisma__wallet_historyClient<$Result.GetResult<Prisma.$wallet_historyPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Wallet_histories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {wallet_historyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Wallet_histories
     * const wallet_histories = await prisma.wallet_history.findMany()
     * 
     * // Get first 10 Wallet_histories
     * const wallet_histories = await prisma.wallet_history.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const wallet_historyWithIdOnly = await prisma.wallet_history.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends wallet_historyFindManyArgs>(args?: SelectSubset<T, wallet_historyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$wallet_historyPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Wallet_history.
     * @param {wallet_historyCreateArgs} args - Arguments to create a Wallet_history.
     * @example
     * // Create one Wallet_history
     * const Wallet_history = await prisma.wallet_history.create({
     *   data: {
     *     // ... data to create a Wallet_history
     *   }
     * })
     * 
     */
    create<T extends wallet_historyCreateArgs>(args: SelectSubset<T, wallet_historyCreateArgs<ExtArgs>>): Prisma__wallet_historyClient<$Result.GetResult<Prisma.$wallet_historyPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Wallet_histories.
     * @param {wallet_historyCreateManyArgs} args - Arguments to create many Wallet_histories.
     * @example
     * // Create many Wallet_histories
     * const wallet_history = await prisma.wallet_history.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends wallet_historyCreateManyArgs>(args?: SelectSubset<T, wallet_historyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Wallet_history.
     * @param {wallet_historyDeleteArgs} args - Arguments to delete one Wallet_history.
     * @example
     * // Delete one Wallet_history
     * const Wallet_history = await prisma.wallet_history.delete({
     *   where: {
     *     // ... filter to delete one Wallet_history
     *   }
     * })
     * 
     */
    delete<T extends wallet_historyDeleteArgs>(args: SelectSubset<T, wallet_historyDeleteArgs<ExtArgs>>): Prisma__wallet_historyClient<$Result.GetResult<Prisma.$wallet_historyPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Wallet_history.
     * @param {wallet_historyUpdateArgs} args - Arguments to update one Wallet_history.
     * @example
     * // Update one Wallet_history
     * const wallet_history = await prisma.wallet_history.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends wallet_historyUpdateArgs>(args: SelectSubset<T, wallet_historyUpdateArgs<ExtArgs>>): Prisma__wallet_historyClient<$Result.GetResult<Prisma.$wallet_historyPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Wallet_histories.
     * @param {wallet_historyDeleteManyArgs} args - Arguments to filter Wallet_histories to delete.
     * @example
     * // Delete a few Wallet_histories
     * const { count } = await prisma.wallet_history.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends wallet_historyDeleteManyArgs>(args?: SelectSubset<T, wallet_historyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Wallet_histories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {wallet_historyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Wallet_histories
     * const wallet_history = await prisma.wallet_history.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends wallet_historyUpdateManyArgs>(args: SelectSubset<T, wallet_historyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Wallet_history.
     * @param {wallet_historyUpsertArgs} args - Arguments to update or create a Wallet_history.
     * @example
     * // Update or create a Wallet_history
     * const wallet_history = await prisma.wallet_history.upsert({
     *   create: {
     *     // ... data to create a Wallet_history
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Wallet_history we want to update
     *   }
     * })
     */
    upsert<T extends wallet_historyUpsertArgs>(args: SelectSubset<T, wallet_historyUpsertArgs<ExtArgs>>): Prisma__wallet_historyClient<$Result.GetResult<Prisma.$wallet_historyPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Wallet_histories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {wallet_historyCountArgs} args - Arguments to filter Wallet_histories to count.
     * @example
     * // Count the number of Wallet_histories
     * const count = await prisma.wallet_history.count({
     *   where: {
     *     // ... the filter for the Wallet_histories we want to count
     *   }
     * })
    **/
    count<T extends wallet_historyCountArgs>(
      args?: Subset<T, wallet_historyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Wallet_historyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Wallet_history.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Wallet_historyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Wallet_historyAggregateArgs>(args: Subset<T, Wallet_historyAggregateArgs>): Prisma.PrismaPromise<GetWallet_historyAggregateType<T>>

    /**
     * Group by Wallet_history.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {wallet_historyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends wallet_historyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: wallet_historyGroupByArgs['orderBy'] }
        : { orderBy?: wallet_historyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, wallet_historyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWallet_historyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the wallet_history model
   */
  readonly fields: wallet_historyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for wallet_history.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__wallet_historyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    wallet<T extends wallet_userDefaultArgs<ExtArgs> = {}>(args?: Subset<T, wallet_userDefaultArgs<ExtArgs>>): Prisma__wallet_userClient<$Result.GetResult<Prisma.$wallet_userPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    order<T extends wallet_history$orderArgs<ExtArgs> = {}>(args?: Subset<T, wallet_history$orderArgs<ExtArgs>>): Prisma__order_bookingClient<$Result.GetResult<Prisma.$order_bookingPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the wallet_history model
   */ 
  interface wallet_historyFieldRefs {
    readonly id: FieldRef<"wallet_history", 'Int'>
    readonly wallet_id: FieldRef<"wallet_history", 'Int'>
    readonly jumlah: FieldRef<"wallet_history", 'Int'>
    readonly saldo_akhir: FieldRef<"wallet_history", 'Int'>
    readonly tipe: FieldRef<"wallet_history", 'wallet_tipe'>
    readonly transaksi_id: FieldRef<"wallet_history", 'Int'>
    readonly order_id: FieldRef<"wallet_history", 'Int'>
    readonly created_at: FieldRef<"wallet_history", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * wallet_history findUnique
   */
  export type wallet_historyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wallet_history
     */
    select?: wallet_historySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: wallet_historyInclude<ExtArgs> | null
    /**
     * Filter, which wallet_history to fetch.
     */
    where: wallet_historyWhereUniqueInput
  }

  /**
   * wallet_history findUniqueOrThrow
   */
  export type wallet_historyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wallet_history
     */
    select?: wallet_historySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: wallet_historyInclude<ExtArgs> | null
    /**
     * Filter, which wallet_history to fetch.
     */
    where: wallet_historyWhereUniqueInput
  }

  /**
   * wallet_history findFirst
   */
  export type wallet_historyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wallet_history
     */
    select?: wallet_historySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: wallet_historyInclude<ExtArgs> | null
    /**
     * Filter, which wallet_history to fetch.
     */
    where?: wallet_historyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of wallet_histories to fetch.
     */
    orderBy?: wallet_historyOrderByWithRelationInput | wallet_historyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for wallet_histories.
     */
    cursor?: wallet_historyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` wallet_histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` wallet_histories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of wallet_histories.
     */
    distinct?: Wallet_historyScalarFieldEnum | Wallet_historyScalarFieldEnum[]
  }

  /**
   * wallet_history findFirstOrThrow
   */
  export type wallet_historyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wallet_history
     */
    select?: wallet_historySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: wallet_historyInclude<ExtArgs> | null
    /**
     * Filter, which wallet_history to fetch.
     */
    where?: wallet_historyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of wallet_histories to fetch.
     */
    orderBy?: wallet_historyOrderByWithRelationInput | wallet_historyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for wallet_histories.
     */
    cursor?: wallet_historyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` wallet_histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` wallet_histories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of wallet_histories.
     */
    distinct?: Wallet_historyScalarFieldEnum | Wallet_historyScalarFieldEnum[]
  }

  /**
   * wallet_history findMany
   */
  export type wallet_historyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wallet_history
     */
    select?: wallet_historySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: wallet_historyInclude<ExtArgs> | null
    /**
     * Filter, which wallet_histories to fetch.
     */
    where?: wallet_historyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of wallet_histories to fetch.
     */
    orderBy?: wallet_historyOrderByWithRelationInput | wallet_historyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing wallet_histories.
     */
    cursor?: wallet_historyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` wallet_histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` wallet_histories.
     */
    skip?: number
    distinct?: Wallet_historyScalarFieldEnum | Wallet_historyScalarFieldEnum[]
  }

  /**
   * wallet_history create
   */
  export type wallet_historyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wallet_history
     */
    select?: wallet_historySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: wallet_historyInclude<ExtArgs> | null
    /**
     * The data needed to create a wallet_history.
     */
    data: XOR<wallet_historyCreateInput, wallet_historyUncheckedCreateInput>
  }

  /**
   * wallet_history createMany
   */
  export type wallet_historyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many wallet_histories.
     */
    data: wallet_historyCreateManyInput | wallet_historyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * wallet_history update
   */
  export type wallet_historyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wallet_history
     */
    select?: wallet_historySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: wallet_historyInclude<ExtArgs> | null
    /**
     * The data needed to update a wallet_history.
     */
    data: XOR<wallet_historyUpdateInput, wallet_historyUncheckedUpdateInput>
    /**
     * Choose, which wallet_history to update.
     */
    where: wallet_historyWhereUniqueInput
  }

  /**
   * wallet_history updateMany
   */
  export type wallet_historyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update wallet_histories.
     */
    data: XOR<wallet_historyUpdateManyMutationInput, wallet_historyUncheckedUpdateManyInput>
    /**
     * Filter which wallet_histories to update
     */
    where?: wallet_historyWhereInput
  }

  /**
   * wallet_history upsert
   */
  export type wallet_historyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wallet_history
     */
    select?: wallet_historySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: wallet_historyInclude<ExtArgs> | null
    /**
     * The filter to search for the wallet_history to update in case it exists.
     */
    where: wallet_historyWhereUniqueInput
    /**
     * In case the wallet_history found by the `where` argument doesn't exist, create a new wallet_history with this data.
     */
    create: XOR<wallet_historyCreateInput, wallet_historyUncheckedCreateInput>
    /**
     * In case the wallet_history was found with the provided `where` argument, update it with this data.
     */
    update: XOR<wallet_historyUpdateInput, wallet_historyUncheckedUpdateInput>
  }

  /**
   * wallet_history delete
   */
  export type wallet_historyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wallet_history
     */
    select?: wallet_historySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: wallet_historyInclude<ExtArgs> | null
    /**
     * Filter which wallet_history to delete.
     */
    where: wallet_historyWhereUniqueInput
  }

  /**
   * wallet_history deleteMany
   */
  export type wallet_historyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which wallet_histories to delete
     */
    where?: wallet_historyWhereInput
  }

  /**
   * wallet_history.order
   */
  export type wallet_history$orderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order_booking
     */
    select?: order_bookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: order_bookingInclude<ExtArgs> | null
    where?: order_bookingWhereInput
  }

  /**
   * wallet_history without action
   */
  export type wallet_historyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wallet_history
     */
    select?: wallet_historySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: wallet_historyInclude<ExtArgs> | null
  }


  /**
   * Model refund
   */

  export type AggregateRefund = {
    _count: RefundCountAggregateOutputType | null
    _avg: RefundAvgAggregateOutputType | null
    _sum: RefundSumAggregateOutputType | null
    _min: RefundMinAggregateOutputType | null
    _max: RefundMaxAggregateOutputType | null
  }

  export type RefundAvgAggregateOutputType = {
    id: number | null
    user_id: number | null
    transaksi_id: number | null
    order_id: number | null
    jumlah: Decimal | null
  }

  export type RefundSumAggregateOutputType = {
    id: number | null
    user_id: number | null
    transaksi_id: number | null
    order_id: number | null
    jumlah: Decimal | null
  }

  export type RefundMinAggregateOutputType = {
    id: number | null
    user_id: number | null
    transaksi_id: number | null
    order_id: number | null
    jumlah: Decimal | null
    alasan: string | null
    status: $Enums.refund_status | null
    created_at: Date | null
    processed_at: Date | null
  }

  export type RefundMaxAggregateOutputType = {
    id: number | null
    user_id: number | null
    transaksi_id: number | null
    order_id: number | null
    jumlah: Decimal | null
    alasan: string | null
    status: $Enums.refund_status | null
    created_at: Date | null
    processed_at: Date | null
  }

  export type RefundCountAggregateOutputType = {
    id: number
    user_id: number
    transaksi_id: number
    order_id: number
    jumlah: number
    alasan: number
    status: number
    created_at: number
    processed_at: number
    _all: number
  }


  export type RefundAvgAggregateInputType = {
    id?: true
    user_id?: true
    transaksi_id?: true
    order_id?: true
    jumlah?: true
  }

  export type RefundSumAggregateInputType = {
    id?: true
    user_id?: true
    transaksi_id?: true
    order_id?: true
    jumlah?: true
  }

  export type RefundMinAggregateInputType = {
    id?: true
    user_id?: true
    transaksi_id?: true
    order_id?: true
    jumlah?: true
    alasan?: true
    status?: true
    created_at?: true
    processed_at?: true
  }

  export type RefundMaxAggregateInputType = {
    id?: true
    user_id?: true
    transaksi_id?: true
    order_id?: true
    jumlah?: true
    alasan?: true
    status?: true
    created_at?: true
    processed_at?: true
  }

  export type RefundCountAggregateInputType = {
    id?: true
    user_id?: true
    transaksi_id?: true
    order_id?: true
    jumlah?: true
    alasan?: true
    status?: true
    created_at?: true
    processed_at?: true
    _all?: true
  }

  export type RefundAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which refund to aggregate.
     */
    where?: refundWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of refunds to fetch.
     */
    orderBy?: refundOrderByWithRelationInput | refundOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: refundWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` refunds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` refunds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned refunds
    **/
    _count?: true | RefundCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RefundAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RefundSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RefundMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RefundMaxAggregateInputType
  }

  export type GetRefundAggregateType<T extends RefundAggregateArgs> = {
        [P in keyof T & keyof AggregateRefund]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRefund[P]>
      : GetScalarType<T[P], AggregateRefund[P]>
  }




  export type refundGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: refundWhereInput
    orderBy?: refundOrderByWithAggregationInput | refundOrderByWithAggregationInput[]
    by: RefundScalarFieldEnum[] | RefundScalarFieldEnum
    having?: refundScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RefundCountAggregateInputType | true
    _avg?: RefundAvgAggregateInputType
    _sum?: RefundSumAggregateInputType
    _min?: RefundMinAggregateInputType
    _max?: RefundMaxAggregateInputType
  }

  export type RefundGroupByOutputType = {
    id: number
    user_id: number
    transaksi_id: number
    order_id: number
    jumlah: Decimal
    alasan: string | null
    status: $Enums.refund_status
    created_at: Date
    processed_at: Date | null
    _count: RefundCountAggregateOutputType | null
    _avg: RefundAvgAggregateOutputType | null
    _sum: RefundSumAggregateOutputType | null
    _min: RefundMinAggregateOutputType | null
    _max: RefundMaxAggregateOutputType | null
  }

  type GetRefundGroupByPayload<T extends refundGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RefundGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RefundGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RefundGroupByOutputType[P]>
            : GetScalarType<T[P], RefundGroupByOutputType[P]>
        }
      >
    >


  export type refundSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    transaksi_id?: boolean
    order_id?: boolean
    jumlah?: boolean
    alasan?: boolean
    status?: boolean
    created_at?: boolean
    processed_at?: boolean
    user?: boolean | usersDefaultArgs<ExtArgs>
    transaksi?: boolean | transaksiDefaultArgs<ExtArgs>
    order?: boolean | order_bookingDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["refund"]>


  export type refundSelectScalar = {
    id?: boolean
    user_id?: boolean
    transaksi_id?: boolean
    order_id?: boolean
    jumlah?: boolean
    alasan?: boolean
    status?: boolean
    created_at?: boolean
    processed_at?: boolean
  }

  export type refundInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | usersDefaultArgs<ExtArgs>
    transaksi?: boolean | transaksiDefaultArgs<ExtArgs>
    order?: boolean | order_bookingDefaultArgs<ExtArgs>
  }

  export type $refundPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "refund"
    objects: {
      user: Prisma.$usersPayload<ExtArgs>
      transaksi: Prisma.$transaksiPayload<ExtArgs>
      order: Prisma.$order_bookingPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      user_id: number
      transaksi_id: number
      order_id: number
      jumlah: Prisma.Decimal
      alasan: string | null
      status: $Enums.refund_status
      created_at: Date
      processed_at: Date | null
    }, ExtArgs["result"]["refund"]>
    composites: {}
  }

  type refundGetPayload<S extends boolean | null | undefined | refundDefaultArgs> = $Result.GetResult<Prisma.$refundPayload, S>

  type refundCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<refundFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RefundCountAggregateInputType | true
    }

  export interface refundDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['refund'], meta: { name: 'refund' } }
    /**
     * Find zero or one Refund that matches the filter.
     * @param {refundFindUniqueArgs} args - Arguments to find a Refund
     * @example
     * // Get one Refund
     * const refund = await prisma.refund.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends refundFindUniqueArgs>(args: SelectSubset<T, refundFindUniqueArgs<ExtArgs>>): Prisma__refundClient<$Result.GetResult<Prisma.$refundPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Refund that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {refundFindUniqueOrThrowArgs} args - Arguments to find a Refund
     * @example
     * // Get one Refund
     * const refund = await prisma.refund.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends refundFindUniqueOrThrowArgs>(args: SelectSubset<T, refundFindUniqueOrThrowArgs<ExtArgs>>): Prisma__refundClient<$Result.GetResult<Prisma.$refundPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Refund that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {refundFindFirstArgs} args - Arguments to find a Refund
     * @example
     * // Get one Refund
     * const refund = await prisma.refund.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends refundFindFirstArgs>(args?: SelectSubset<T, refundFindFirstArgs<ExtArgs>>): Prisma__refundClient<$Result.GetResult<Prisma.$refundPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Refund that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {refundFindFirstOrThrowArgs} args - Arguments to find a Refund
     * @example
     * // Get one Refund
     * const refund = await prisma.refund.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends refundFindFirstOrThrowArgs>(args?: SelectSubset<T, refundFindFirstOrThrowArgs<ExtArgs>>): Prisma__refundClient<$Result.GetResult<Prisma.$refundPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Refunds that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {refundFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Refunds
     * const refunds = await prisma.refund.findMany()
     * 
     * // Get first 10 Refunds
     * const refunds = await prisma.refund.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const refundWithIdOnly = await prisma.refund.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends refundFindManyArgs>(args?: SelectSubset<T, refundFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$refundPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Refund.
     * @param {refundCreateArgs} args - Arguments to create a Refund.
     * @example
     * // Create one Refund
     * const Refund = await prisma.refund.create({
     *   data: {
     *     // ... data to create a Refund
     *   }
     * })
     * 
     */
    create<T extends refundCreateArgs>(args: SelectSubset<T, refundCreateArgs<ExtArgs>>): Prisma__refundClient<$Result.GetResult<Prisma.$refundPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Refunds.
     * @param {refundCreateManyArgs} args - Arguments to create many Refunds.
     * @example
     * // Create many Refunds
     * const refund = await prisma.refund.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends refundCreateManyArgs>(args?: SelectSubset<T, refundCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Refund.
     * @param {refundDeleteArgs} args - Arguments to delete one Refund.
     * @example
     * // Delete one Refund
     * const Refund = await prisma.refund.delete({
     *   where: {
     *     // ... filter to delete one Refund
     *   }
     * })
     * 
     */
    delete<T extends refundDeleteArgs>(args: SelectSubset<T, refundDeleteArgs<ExtArgs>>): Prisma__refundClient<$Result.GetResult<Prisma.$refundPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Refund.
     * @param {refundUpdateArgs} args - Arguments to update one Refund.
     * @example
     * // Update one Refund
     * const refund = await prisma.refund.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends refundUpdateArgs>(args: SelectSubset<T, refundUpdateArgs<ExtArgs>>): Prisma__refundClient<$Result.GetResult<Prisma.$refundPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Refunds.
     * @param {refundDeleteManyArgs} args - Arguments to filter Refunds to delete.
     * @example
     * // Delete a few Refunds
     * const { count } = await prisma.refund.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends refundDeleteManyArgs>(args?: SelectSubset<T, refundDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Refunds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {refundUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Refunds
     * const refund = await prisma.refund.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends refundUpdateManyArgs>(args: SelectSubset<T, refundUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Refund.
     * @param {refundUpsertArgs} args - Arguments to update or create a Refund.
     * @example
     * // Update or create a Refund
     * const refund = await prisma.refund.upsert({
     *   create: {
     *     // ... data to create a Refund
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Refund we want to update
     *   }
     * })
     */
    upsert<T extends refundUpsertArgs>(args: SelectSubset<T, refundUpsertArgs<ExtArgs>>): Prisma__refundClient<$Result.GetResult<Prisma.$refundPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Refunds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {refundCountArgs} args - Arguments to filter Refunds to count.
     * @example
     * // Count the number of Refunds
     * const count = await prisma.refund.count({
     *   where: {
     *     // ... the filter for the Refunds we want to count
     *   }
     * })
    **/
    count<T extends refundCountArgs>(
      args?: Subset<T, refundCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RefundCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Refund.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefundAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RefundAggregateArgs>(args: Subset<T, RefundAggregateArgs>): Prisma.PrismaPromise<GetRefundAggregateType<T>>

    /**
     * Group by Refund.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {refundGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends refundGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: refundGroupByArgs['orderBy'] }
        : { orderBy?: refundGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, refundGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRefundGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the refund model
   */
  readonly fields: refundFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for refund.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__refundClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    transaksi<T extends transaksiDefaultArgs<ExtArgs> = {}>(args?: Subset<T, transaksiDefaultArgs<ExtArgs>>): Prisma__transaksiClient<$Result.GetResult<Prisma.$transaksiPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    order<T extends order_bookingDefaultArgs<ExtArgs> = {}>(args?: Subset<T, order_bookingDefaultArgs<ExtArgs>>): Prisma__order_bookingClient<$Result.GetResult<Prisma.$order_bookingPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the refund model
   */ 
  interface refundFieldRefs {
    readonly id: FieldRef<"refund", 'Int'>
    readonly user_id: FieldRef<"refund", 'Int'>
    readonly transaksi_id: FieldRef<"refund", 'Int'>
    readonly order_id: FieldRef<"refund", 'Int'>
    readonly jumlah: FieldRef<"refund", 'Decimal'>
    readonly alasan: FieldRef<"refund", 'String'>
    readonly status: FieldRef<"refund", 'refund_status'>
    readonly created_at: FieldRef<"refund", 'DateTime'>
    readonly processed_at: FieldRef<"refund", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * refund findUnique
   */
  export type refundFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the refund
     */
    select?: refundSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: refundInclude<ExtArgs> | null
    /**
     * Filter, which refund to fetch.
     */
    where: refundWhereUniqueInput
  }

  /**
   * refund findUniqueOrThrow
   */
  export type refundFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the refund
     */
    select?: refundSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: refundInclude<ExtArgs> | null
    /**
     * Filter, which refund to fetch.
     */
    where: refundWhereUniqueInput
  }

  /**
   * refund findFirst
   */
  export type refundFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the refund
     */
    select?: refundSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: refundInclude<ExtArgs> | null
    /**
     * Filter, which refund to fetch.
     */
    where?: refundWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of refunds to fetch.
     */
    orderBy?: refundOrderByWithRelationInput | refundOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for refunds.
     */
    cursor?: refundWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` refunds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` refunds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of refunds.
     */
    distinct?: RefundScalarFieldEnum | RefundScalarFieldEnum[]
  }

  /**
   * refund findFirstOrThrow
   */
  export type refundFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the refund
     */
    select?: refundSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: refundInclude<ExtArgs> | null
    /**
     * Filter, which refund to fetch.
     */
    where?: refundWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of refunds to fetch.
     */
    orderBy?: refundOrderByWithRelationInput | refundOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for refunds.
     */
    cursor?: refundWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` refunds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` refunds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of refunds.
     */
    distinct?: RefundScalarFieldEnum | RefundScalarFieldEnum[]
  }

  /**
   * refund findMany
   */
  export type refundFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the refund
     */
    select?: refundSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: refundInclude<ExtArgs> | null
    /**
     * Filter, which refunds to fetch.
     */
    where?: refundWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of refunds to fetch.
     */
    orderBy?: refundOrderByWithRelationInput | refundOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing refunds.
     */
    cursor?: refundWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` refunds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` refunds.
     */
    skip?: number
    distinct?: RefundScalarFieldEnum | RefundScalarFieldEnum[]
  }

  /**
   * refund create
   */
  export type refundCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the refund
     */
    select?: refundSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: refundInclude<ExtArgs> | null
    /**
     * The data needed to create a refund.
     */
    data: XOR<refundCreateInput, refundUncheckedCreateInput>
  }

  /**
   * refund createMany
   */
  export type refundCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many refunds.
     */
    data: refundCreateManyInput | refundCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * refund update
   */
  export type refundUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the refund
     */
    select?: refundSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: refundInclude<ExtArgs> | null
    /**
     * The data needed to update a refund.
     */
    data: XOR<refundUpdateInput, refundUncheckedUpdateInput>
    /**
     * Choose, which refund to update.
     */
    where: refundWhereUniqueInput
  }

  /**
   * refund updateMany
   */
  export type refundUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update refunds.
     */
    data: XOR<refundUpdateManyMutationInput, refundUncheckedUpdateManyInput>
    /**
     * Filter which refunds to update
     */
    where?: refundWhereInput
  }

  /**
   * refund upsert
   */
  export type refundUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the refund
     */
    select?: refundSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: refundInclude<ExtArgs> | null
    /**
     * The filter to search for the refund to update in case it exists.
     */
    where: refundWhereUniqueInput
    /**
     * In case the refund found by the `where` argument doesn't exist, create a new refund with this data.
     */
    create: XOR<refundCreateInput, refundUncheckedCreateInput>
    /**
     * In case the refund was found with the provided `where` argument, update it with this data.
     */
    update: XOR<refundUpdateInput, refundUncheckedUpdateInput>
  }

  /**
   * refund delete
   */
  export type refundDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the refund
     */
    select?: refundSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: refundInclude<ExtArgs> | null
    /**
     * Filter which refund to delete.
     */
    where: refundWhereUniqueInput
  }

  /**
   * refund deleteMany
   */
  export type refundDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which refunds to delete
     */
    where?: refundWhereInput
  }

  /**
   * refund without action
   */
  export type refundDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the refund
     */
    select?: refundSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: refundInclude<ExtArgs> | null
  }


  /**
   * Model notifikasi
   */

  export type AggregateNotifikasi = {
    _count: NotifikasiCountAggregateOutputType | null
    _avg: NotifikasiAvgAggregateOutputType | null
    _sum: NotifikasiSumAggregateOutputType | null
    _min: NotifikasiMinAggregateOutputType | null
    _max: NotifikasiMaxAggregateOutputType | null
  }

  export type NotifikasiAvgAggregateOutputType = {
    id: number | null
    user_id: number | null
  }

  export type NotifikasiSumAggregateOutputType = {
    id: number | null
    user_id: number | null
  }

  export type NotifikasiMinAggregateOutputType = {
    id: number | null
    user_id: number | null
    pesan: string | null
    dibaca: boolean | null
    created_at: Date | null
  }

  export type NotifikasiMaxAggregateOutputType = {
    id: number | null
    user_id: number | null
    pesan: string | null
    dibaca: boolean | null
    created_at: Date | null
  }

  export type NotifikasiCountAggregateOutputType = {
    id: number
    user_id: number
    pesan: number
    dibaca: number
    created_at: number
    _all: number
  }


  export type NotifikasiAvgAggregateInputType = {
    id?: true
    user_id?: true
  }

  export type NotifikasiSumAggregateInputType = {
    id?: true
    user_id?: true
  }

  export type NotifikasiMinAggregateInputType = {
    id?: true
    user_id?: true
    pesan?: true
    dibaca?: true
    created_at?: true
  }

  export type NotifikasiMaxAggregateInputType = {
    id?: true
    user_id?: true
    pesan?: true
    dibaca?: true
    created_at?: true
  }

  export type NotifikasiCountAggregateInputType = {
    id?: true
    user_id?: true
    pesan?: true
    dibaca?: true
    created_at?: true
    _all?: true
  }

  export type NotifikasiAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which notifikasi to aggregate.
     */
    where?: notifikasiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of notifikasis to fetch.
     */
    orderBy?: notifikasiOrderByWithRelationInput | notifikasiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: notifikasiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` notifikasis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` notifikasis.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned notifikasis
    **/
    _count?: true | NotifikasiCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NotifikasiAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NotifikasiSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotifikasiMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotifikasiMaxAggregateInputType
  }

  export type GetNotifikasiAggregateType<T extends NotifikasiAggregateArgs> = {
        [P in keyof T & keyof AggregateNotifikasi]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotifikasi[P]>
      : GetScalarType<T[P], AggregateNotifikasi[P]>
  }




  export type notifikasiGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: notifikasiWhereInput
    orderBy?: notifikasiOrderByWithAggregationInput | notifikasiOrderByWithAggregationInput[]
    by: NotifikasiScalarFieldEnum[] | NotifikasiScalarFieldEnum
    having?: notifikasiScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotifikasiCountAggregateInputType | true
    _avg?: NotifikasiAvgAggregateInputType
    _sum?: NotifikasiSumAggregateInputType
    _min?: NotifikasiMinAggregateInputType
    _max?: NotifikasiMaxAggregateInputType
  }

  export type NotifikasiGroupByOutputType = {
    id: number
    user_id: number
    pesan: string
    dibaca: boolean
    created_at: Date
    _count: NotifikasiCountAggregateOutputType | null
    _avg: NotifikasiAvgAggregateOutputType | null
    _sum: NotifikasiSumAggregateOutputType | null
    _min: NotifikasiMinAggregateOutputType | null
    _max: NotifikasiMaxAggregateOutputType | null
  }

  type GetNotifikasiGroupByPayload<T extends notifikasiGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotifikasiGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotifikasiGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotifikasiGroupByOutputType[P]>
            : GetScalarType<T[P], NotifikasiGroupByOutputType[P]>
        }
      >
    >


  export type notifikasiSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    pesan?: boolean
    dibaca?: boolean
    created_at?: boolean
    user?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notifikasi"]>


  export type notifikasiSelectScalar = {
    id?: boolean
    user_id?: boolean
    pesan?: boolean
    dibaca?: boolean
    created_at?: boolean
  }

  export type notifikasiInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | usersDefaultArgs<ExtArgs>
  }

  export type $notifikasiPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "notifikasi"
    objects: {
      user: Prisma.$usersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      user_id: number
      pesan: string
      dibaca: boolean
      created_at: Date
    }, ExtArgs["result"]["notifikasi"]>
    composites: {}
  }

  type notifikasiGetPayload<S extends boolean | null | undefined | notifikasiDefaultArgs> = $Result.GetResult<Prisma.$notifikasiPayload, S>

  type notifikasiCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<notifikasiFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: NotifikasiCountAggregateInputType | true
    }

  export interface notifikasiDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['notifikasi'], meta: { name: 'notifikasi' } }
    /**
     * Find zero or one Notifikasi that matches the filter.
     * @param {notifikasiFindUniqueArgs} args - Arguments to find a Notifikasi
     * @example
     * // Get one Notifikasi
     * const notifikasi = await prisma.notifikasi.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends notifikasiFindUniqueArgs>(args: SelectSubset<T, notifikasiFindUniqueArgs<ExtArgs>>): Prisma__notifikasiClient<$Result.GetResult<Prisma.$notifikasiPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Notifikasi that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {notifikasiFindUniqueOrThrowArgs} args - Arguments to find a Notifikasi
     * @example
     * // Get one Notifikasi
     * const notifikasi = await prisma.notifikasi.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends notifikasiFindUniqueOrThrowArgs>(args: SelectSubset<T, notifikasiFindUniqueOrThrowArgs<ExtArgs>>): Prisma__notifikasiClient<$Result.GetResult<Prisma.$notifikasiPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Notifikasi that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notifikasiFindFirstArgs} args - Arguments to find a Notifikasi
     * @example
     * // Get one Notifikasi
     * const notifikasi = await prisma.notifikasi.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends notifikasiFindFirstArgs>(args?: SelectSubset<T, notifikasiFindFirstArgs<ExtArgs>>): Prisma__notifikasiClient<$Result.GetResult<Prisma.$notifikasiPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Notifikasi that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notifikasiFindFirstOrThrowArgs} args - Arguments to find a Notifikasi
     * @example
     * // Get one Notifikasi
     * const notifikasi = await prisma.notifikasi.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends notifikasiFindFirstOrThrowArgs>(args?: SelectSubset<T, notifikasiFindFirstOrThrowArgs<ExtArgs>>): Prisma__notifikasiClient<$Result.GetResult<Prisma.$notifikasiPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Notifikasis that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notifikasiFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifikasis
     * const notifikasis = await prisma.notifikasi.findMany()
     * 
     * // Get first 10 Notifikasis
     * const notifikasis = await prisma.notifikasi.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notifikasiWithIdOnly = await prisma.notifikasi.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends notifikasiFindManyArgs>(args?: SelectSubset<T, notifikasiFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$notifikasiPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Notifikasi.
     * @param {notifikasiCreateArgs} args - Arguments to create a Notifikasi.
     * @example
     * // Create one Notifikasi
     * const Notifikasi = await prisma.notifikasi.create({
     *   data: {
     *     // ... data to create a Notifikasi
     *   }
     * })
     * 
     */
    create<T extends notifikasiCreateArgs>(args: SelectSubset<T, notifikasiCreateArgs<ExtArgs>>): Prisma__notifikasiClient<$Result.GetResult<Prisma.$notifikasiPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Notifikasis.
     * @param {notifikasiCreateManyArgs} args - Arguments to create many Notifikasis.
     * @example
     * // Create many Notifikasis
     * const notifikasi = await prisma.notifikasi.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends notifikasiCreateManyArgs>(args?: SelectSubset<T, notifikasiCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Notifikasi.
     * @param {notifikasiDeleteArgs} args - Arguments to delete one Notifikasi.
     * @example
     * // Delete one Notifikasi
     * const Notifikasi = await prisma.notifikasi.delete({
     *   where: {
     *     // ... filter to delete one Notifikasi
     *   }
     * })
     * 
     */
    delete<T extends notifikasiDeleteArgs>(args: SelectSubset<T, notifikasiDeleteArgs<ExtArgs>>): Prisma__notifikasiClient<$Result.GetResult<Prisma.$notifikasiPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Notifikasi.
     * @param {notifikasiUpdateArgs} args - Arguments to update one Notifikasi.
     * @example
     * // Update one Notifikasi
     * const notifikasi = await prisma.notifikasi.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends notifikasiUpdateArgs>(args: SelectSubset<T, notifikasiUpdateArgs<ExtArgs>>): Prisma__notifikasiClient<$Result.GetResult<Prisma.$notifikasiPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Notifikasis.
     * @param {notifikasiDeleteManyArgs} args - Arguments to filter Notifikasis to delete.
     * @example
     * // Delete a few Notifikasis
     * const { count } = await prisma.notifikasi.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends notifikasiDeleteManyArgs>(args?: SelectSubset<T, notifikasiDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifikasis.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notifikasiUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifikasis
     * const notifikasi = await prisma.notifikasi.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends notifikasiUpdateManyArgs>(args: SelectSubset<T, notifikasiUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Notifikasi.
     * @param {notifikasiUpsertArgs} args - Arguments to update or create a Notifikasi.
     * @example
     * // Update or create a Notifikasi
     * const notifikasi = await prisma.notifikasi.upsert({
     *   create: {
     *     // ... data to create a Notifikasi
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notifikasi we want to update
     *   }
     * })
     */
    upsert<T extends notifikasiUpsertArgs>(args: SelectSubset<T, notifikasiUpsertArgs<ExtArgs>>): Prisma__notifikasiClient<$Result.GetResult<Prisma.$notifikasiPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Notifikasis.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notifikasiCountArgs} args - Arguments to filter Notifikasis to count.
     * @example
     * // Count the number of Notifikasis
     * const count = await prisma.notifikasi.count({
     *   where: {
     *     // ... the filter for the Notifikasis we want to count
     *   }
     * })
    **/
    count<T extends notifikasiCountArgs>(
      args?: Subset<T, notifikasiCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotifikasiCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notifikasi.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotifikasiAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotifikasiAggregateArgs>(args: Subset<T, NotifikasiAggregateArgs>): Prisma.PrismaPromise<GetNotifikasiAggregateType<T>>

    /**
     * Group by Notifikasi.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notifikasiGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends notifikasiGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: notifikasiGroupByArgs['orderBy'] }
        : { orderBy?: notifikasiGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, notifikasiGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotifikasiGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the notifikasi model
   */
  readonly fields: notifikasiFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for notifikasi.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__notifikasiClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the notifikasi model
   */ 
  interface notifikasiFieldRefs {
    readonly id: FieldRef<"notifikasi", 'Int'>
    readonly user_id: FieldRef<"notifikasi", 'Int'>
    readonly pesan: FieldRef<"notifikasi", 'String'>
    readonly dibaca: FieldRef<"notifikasi", 'Boolean'>
    readonly created_at: FieldRef<"notifikasi", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * notifikasi findUnique
   */
  export type notifikasiFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifikasi
     */
    select?: notifikasiSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notifikasiInclude<ExtArgs> | null
    /**
     * Filter, which notifikasi to fetch.
     */
    where: notifikasiWhereUniqueInput
  }

  /**
   * notifikasi findUniqueOrThrow
   */
  export type notifikasiFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifikasi
     */
    select?: notifikasiSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notifikasiInclude<ExtArgs> | null
    /**
     * Filter, which notifikasi to fetch.
     */
    where: notifikasiWhereUniqueInput
  }

  /**
   * notifikasi findFirst
   */
  export type notifikasiFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifikasi
     */
    select?: notifikasiSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notifikasiInclude<ExtArgs> | null
    /**
     * Filter, which notifikasi to fetch.
     */
    where?: notifikasiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of notifikasis to fetch.
     */
    orderBy?: notifikasiOrderByWithRelationInput | notifikasiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for notifikasis.
     */
    cursor?: notifikasiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` notifikasis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` notifikasis.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of notifikasis.
     */
    distinct?: NotifikasiScalarFieldEnum | NotifikasiScalarFieldEnum[]
  }

  /**
   * notifikasi findFirstOrThrow
   */
  export type notifikasiFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifikasi
     */
    select?: notifikasiSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notifikasiInclude<ExtArgs> | null
    /**
     * Filter, which notifikasi to fetch.
     */
    where?: notifikasiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of notifikasis to fetch.
     */
    orderBy?: notifikasiOrderByWithRelationInput | notifikasiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for notifikasis.
     */
    cursor?: notifikasiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` notifikasis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` notifikasis.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of notifikasis.
     */
    distinct?: NotifikasiScalarFieldEnum | NotifikasiScalarFieldEnum[]
  }

  /**
   * notifikasi findMany
   */
  export type notifikasiFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifikasi
     */
    select?: notifikasiSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notifikasiInclude<ExtArgs> | null
    /**
     * Filter, which notifikasis to fetch.
     */
    where?: notifikasiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of notifikasis to fetch.
     */
    orderBy?: notifikasiOrderByWithRelationInput | notifikasiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing notifikasis.
     */
    cursor?: notifikasiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` notifikasis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` notifikasis.
     */
    skip?: number
    distinct?: NotifikasiScalarFieldEnum | NotifikasiScalarFieldEnum[]
  }

  /**
   * notifikasi create
   */
  export type notifikasiCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifikasi
     */
    select?: notifikasiSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notifikasiInclude<ExtArgs> | null
    /**
     * The data needed to create a notifikasi.
     */
    data: XOR<notifikasiCreateInput, notifikasiUncheckedCreateInput>
  }

  /**
   * notifikasi createMany
   */
  export type notifikasiCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many notifikasis.
     */
    data: notifikasiCreateManyInput | notifikasiCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * notifikasi update
   */
  export type notifikasiUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifikasi
     */
    select?: notifikasiSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notifikasiInclude<ExtArgs> | null
    /**
     * The data needed to update a notifikasi.
     */
    data: XOR<notifikasiUpdateInput, notifikasiUncheckedUpdateInput>
    /**
     * Choose, which notifikasi to update.
     */
    where: notifikasiWhereUniqueInput
  }

  /**
   * notifikasi updateMany
   */
  export type notifikasiUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update notifikasis.
     */
    data: XOR<notifikasiUpdateManyMutationInput, notifikasiUncheckedUpdateManyInput>
    /**
     * Filter which notifikasis to update
     */
    where?: notifikasiWhereInput
  }

  /**
   * notifikasi upsert
   */
  export type notifikasiUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifikasi
     */
    select?: notifikasiSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notifikasiInclude<ExtArgs> | null
    /**
     * The filter to search for the notifikasi to update in case it exists.
     */
    where: notifikasiWhereUniqueInput
    /**
     * In case the notifikasi found by the `where` argument doesn't exist, create a new notifikasi with this data.
     */
    create: XOR<notifikasiCreateInput, notifikasiUncheckedCreateInput>
    /**
     * In case the notifikasi was found with the provided `where` argument, update it with this data.
     */
    update: XOR<notifikasiUpdateInput, notifikasiUncheckedUpdateInput>
  }

  /**
   * notifikasi delete
   */
  export type notifikasiDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifikasi
     */
    select?: notifikasiSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notifikasiInclude<ExtArgs> | null
    /**
     * Filter which notifikasi to delete.
     */
    where: notifikasiWhereUniqueInput
  }

  /**
   * notifikasi deleteMany
   */
  export type notifikasiDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which notifikasis to delete
     */
    where?: notifikasiWhereInput
  }

  /**
   * notifikasi without action
   */
  export type notifikasiDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifikasi
     */
    select?: notifikasiSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notifikasiInclude<ExtArgs> | null
  }


  /**
   * Model ulasan
   */

  export type AggregateUlasan = {
    _count: UlasanCountAggregateOutputType | null
    _avg: UlasanAvgAggregateOutputType | null
    _sum: UlasanSumAggregateOutputType | null
    _min: UlasanMinAggregateOutputType | null
    _max: UlasanMaxAggregateOutputType | null
  }

  export type UlasanAvgAggregateOutputType = {
    id: number | null
    user_id: number | null
    lapangan_id: number | null
    rating: number | null
  }

  export type UlasanSumAggregateOutputType = {
    id: number | null
    user_id: number | null
    lapangan_id: number | null
    rating: number | null
  }

  export type UlasanMinAggregateOutputType = {
    id: number | null
    user_id: number | null
    lapangan_id: number | null
    rating: number | null
    komentar: string | null
    created_at: Date | null
  }

  export type UlasanMaxAggregateOutputType = {
    id: number | null
    user_id: number | null
    lapangan_id: number | null
    rating: number | null
    komentar: string | null
    created_at: Date | null
  }

  export type UlasanCountAggregateOutputType = {
    id: number
    user_id: number
    lapangan_id: number
    rating: number
    komentar: number
    created_at: number
    _all: number
  }


  export type UlasanAvgAggregateInputType = {
    id?: true
    user_id?: true
    lapangan_id?: true
    rating?: true
  }

  export type UlasanSumAggregateInputType = {
    id?: true
    user_id?: true
    lapangan_id?: true
    rating?: true
  }

  export type UlasanMinAggregateInputType = {
    id?: true
    user_id?: true
    lapangan_id?: true
    rating?: true
    komentar?: true
    created_at?: true
  }

  export type UlasanMaxAggregateInputType = {
    id?: true
    user_id?: true
    lapangan_id?: true
    rating?: true
    komentar?: true
    created_at?: true
  }

  export type UlasanCountAggregateInputType = {
    id?: true
    user_id?: true
    lapangan_id?: true
    rating?: true
    komentar?: true
    created_at?: true
    _all?: true
  }

  export type UlasanAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ulasan to aggregate.
     */
    where?: ulasanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ulasans to fetch.
     */
    orderBy?: ulasanOrderByWithRelationInput | ulasanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ulasanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ulasans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ulasans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ulasans
    **/
    _count?: true | UlasanCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UlasanAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UlasanSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UlasanMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UlasanMaxAggregateInputType
  }

  export type GetUlasanAggregateType<T extends UlasanAggregateArgs> = {
        [P in keyof T & keyof AggregateUlasan]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUlasan[P]>
      : GetScalarType<T[P], AggregateUlasan[P]>
  }




  export type ulasanGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ulasanWhereInput
    orderBy?: ulasanOrderByWithAggregationInput | ulasanOrderByWithAggregationInput[]
    by: UlasanScalarFieldEnum[] | UlasanScalarFieldEnum
    having?: ulasanScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UlasanCountAggregateInputType | true
    _avg?: UlasanAvgAggregateInputType
    _sum?: UlasanSumAggregateInputType
    _min?: UlasanMinAggregateInputType
    _max?: UlasanMaxAggregateInputType
  }

  export type UlasanGroupByOutputType = {
    id: number
    user_id: number
    lapangan_id: number
    rating: number
    komentar: string | null
    created_at: Date
    _count: UlasanCountAggregateOutputType | null
    _avg: UlasanAvgAggregateOutputType | null
    _sum: UlasanSumAggregateOutputType | null
    _min: UlasanMinAggregateOutputType | null
    _max: UlasanMaxAggregateOutputType | null
  }

  type GetUlasanGroupByPayload<T extends ulasanGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UlasanGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UlasanGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UlasanGroupByOutputType[P]>
            : GetScalarType<T[P], UlasanGroupByOutputType[P]>
        }
      >
    >


  export type ulasanSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    lapangan_id?: boolean
    rating?: boolean
    komentar?: boolean
    created_at?: boolean
    user?: boolean | usersDefaultArgs<ExtArgs>
    lapangan?: boolean | LapanganDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ulasan"]>


  export type ulasanSelectScalar = {
    id?: boolean
    user_id?: boolean
    lapangan_id?: boolean
    rating?: boolean
    komentar?: boolean
    created_at?: boolean
  }

  export type ulasanInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | usersDefaultArgs<ExtArgs>
    lapangan?: boolean | LapanganDefaultArgs<ExtArgs>
  }

  export type $ulasanPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ulasan"
    objects: {
      user: Prisma.$usersPayload<ExtArgs>
      lapangan: Prisma.$LapanganPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      user_id: number
      lapangan_id: number
      rating: number
      komentar: string | null
      created_at: Date
    }, ExtArgs["result"]["ulasan"]>
    composites: {}
  }

  type ulasanGetPayload<S extends boolean | null | undefined | ulasanDefaultArgs> = $Result.GetResult<Prisma.$ulasanPayload, S>

  type ulasanCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ulasanFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UlasanCountAggregateInputType | true
    }

  export interface ulasanDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ulasan'], meta: { name: 'ulasan' } }
    /**
     * Find zero or one Ulasan that matches the filter.
     * @param {ulasanFindUniqueArgs} args - Arguments to find a Ulasan
     * @example
     * // Get one Ulasan
     * const ulasan = await prisma.ulasan.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ulasanFindUniqueArgs>(args: SelectSubset<T, ulasanFindUniqueArgs<ExtArgs>>): Prisma__ulasanClient<$Result.GetResult<Prisma.$ulasanPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Ulasan that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ulasanFindUniqueOrThrowArgs} args - Arguments to find a Ulasan
     * @example
     * // Get one Ulasan
     * const ulasan = await prisma.ulasan.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ulasanFindUniqueOrThrowArgs>(args: SelectSubset<T, ulasanFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ulasanClient<$Result.GetResult<Prisma.$ulasanPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Ulasan that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ulasanFindFirstArgs} args - Arguments to find a Ulasan
     * @example
     * // Get one Ulasan
     * const ulasan = await prisma.ulasan.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ulasanFindFirstArgs>(args?: SelectSubset<T, ulasanFindFirstArgs<ExtArgs>>): Prisma__ulasanClient<$Result.GetResult<Prisma.$ulasanPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Ulasan that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ulasanFindFirstOrThrowArgs} args - Arguments to find a Ulasan
     * @example
     * // Get one Ulasan
     * const ulasan = await prisma.ulasan.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ulasanFindFirstOrThrowArgs>(args?: SelectSubset<T, ulasanFindFirstOrThrowArgs<ExtArgs>>): Prisma__ulasanClient<$Result.GetResult<Prisma.$ulasanPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Ulasans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ulasanFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Ulasans
     * const ulasans = await prisma.ulasan.findMany()
     * 
     * // Get first 10 Ulasans
     * const ulasans = await prisma.ulasan.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ulasanWithIdOnly = await prisma.ulasan.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ulasanFindManyArgs>(args?: SelectSubset<T, ulasanFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ulasanPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Ulasan.
     * @param {ulasanCreateArgs} args - Arguments to create a Ulasan.
     * @example
     * // Create one Ulasan
     * const Ulasan = await prisma.ulasan.create({
     *   data: {
     *     // ... data to create a Ulasan
     *   }
     * })
     * 
     */
    create<T extends ulasanCreateArgs>(args: SelectSubset<T, ulasanCreateArgs<ExtArgs>>): Prisma__ulasanClient<$Result.GetResult<Prisma.$ulasanPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Ulasans.
     * @param {ulasanCreateManyArgs} args - Arguments to create many Ulasans.
     * @example
     * // Create many Ulasans
     * const ulasan = await prisma.ulasan.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ulasanCreateManyArgs>(args?: SelectSubset<T, ulasanCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Ulasan.
     * @param {ulasanDeleteArgs} args - Arguments to delete one Ulasan.
     * @example
     * // Delete one Ulasan
     * const Ulasan = await prisma.ulasan.delete({
     *   where: {
     *     // ... filter to delete one Ulasan
     *   }
     * })
     * 
     */
    delete<T extends ulasanDeleteArgs>(args: SelectSubset<T, ulasanDeleteArgs<ExtArgs>>): Prisma__ulasanClient<$Result.GetResult<Prisma.$ulasanPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Ulasan.
     * @param {ulasanUpdateArgs} args - Arguments to update one Ulasan.
     * @example
     * // Update one Ulasan
     * const ulasan = await prisma.ulasan.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ulasanUpdateArgs>(args: SelectSubset<T, ulasanUpdateArgs<ExtArgs>>): Prisma__ulasanClient<$Result.GetResult<Prisma.$ulasanPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Ulasans.
     * @param {ulasanDeleteManyArgs} args - Arguments to filter Ulasans to delete.
     * @example
     * // Delete a few Ulasans
     * const { count } = await prisma.ulasan.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ulasanDeleteManyArgs>(args?: SelectSubset<T, ulasanDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ulasans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ulasanUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Ulasans
     * const ulasan = await prisma.ulasan.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ulasanUpdateManyArgs>(args: SelectSubset<T, ulasanUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Ulasan.
     * @param {ulasanUpsertArgs} args - Arguments to update or create a Ulasan.
     * @example
     * // Update or create a Ulasan
     * const ulasan = await prisma.ulasan.upsert({
     *   create: {
     *     // ... data to create a Ulasan
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Ulasan we want to update
     *   }
     * })
     */
    upsert<T extends ulasanUpsertArgs>(args: SelectSubset<T, ulasanUpsertArgs<ExtArgs>>): Prisma__ulasanClient<$Result.GetResult<Prisma.$ulasanPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Ulasans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ulasanCountArgs} args - Arguments to filter Ulasans to count.
     * @example
     * // Count the number of Ulasans
     * const count = await prisma.ulasan.count({
     *   where: {
     *     // ... the filter for the Ulasans we want to count
     *   }
     * })
    **/
    count<T extends ulasanCountArgs>(
      args?: Subset<T, ulasanCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UlasanCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Ulasan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UlasanAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UlasanAggregateArgs>(args: Subset<T, UlasanAggregateArgs>): Prisma.PrismaPromise<GetUlasanAggregateType<T>>

    /**
     * Group by Ulasan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ulasanGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ulasanGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ulasanGroupByArgs['orderBy'] }
        : { orderBy?: ulasanGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ulasanGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUlasanGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ulasan model
   */
  readonly fields: ulasanFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ulasan.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ulasanClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    lapangan<T extends LapanganDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LapanganDefaultArgs<ExtArgs>>): Prisma__LapanganClient<$Result.GetResult<Prisma.$LapanganPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ulasan model
   */ 
  interface ulasanFieldRefs {
    readonly id: FieldRef<"ulasan", 'Int'>
    readonly user_id: FieldRef<"ulasan", 'Int'>
    readonly lapangan_id: FieldRef<"ulasan", 'Int'>
    readonly rating: FieldRef<"ulasan", 'Int'>
    readonly komentar: FieldRef<"ulasan", 'String'>
    readonly created_at: FieldRef<"ulasan", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ulasan findUnique
   */
  export type ulasanFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ulasan
     */
    select?: ulasanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ulasanInclude<ExtArgs> | null
    /**
     * Filter, which ulasan to fetch.
     */
    where: ulasanWhereUniqueInput
  }

  /**
   * ulasan findUniqueOrThrow
   */
  export type ulasanFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ulasan
     */
    select?: ulasanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ulasanInclude<ExtArgs> | null
    /**
     * Filter, which ulasan to fetch.
     */
    where: ulasanWhereUniqueInput
  }

  /**
   * ulasan findFirst
   */
  export type ulasanFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ulasan
     */
    select?: ulasanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ulasanInclude<ExtArgs> | null
    /**
     * Filter, which ulasan to fetch.
     */
    where?: ulasanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ulasans to fetch.
     */
    orderBy?: ulasanOrderByWithRelationInput | ulasanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ulasans.
     */
    cursor?: ulasanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ulasans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ulasans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ulasans.
     */
    distinct?: UlasanScalarFieldEnum | UlasanScalarFieldEnum[]
  }

  /**
   * ulasan findFirstOrThrow
   */
  export type ulasanFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ulasan
     */
    select?: ulasanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ulasanInclude<ExtArgs> | null
    /**
     * Filter, which ulasan to fetch.
     */
    where?: ulasanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ulasans to fetch.
     */
    orderBy?: ulasanOrderByWithRelationInput | ulasanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ulasans.
     */
    cursor?: ulasanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ulasans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ulasans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ulasans.
     */
    distinct?: UlasanScalarFieldEnum | UlasanScalarFieldEnum[]
  }

  /**
   * ulasan findMany
   */
  export type ulasanFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ulasan
     */
    select?: ulasanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ulasanInclude<ExtArgs> | null
    /**
     * Filter, which ulasans to fetch.
     */
    where?: ulasanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ulasans to fetch.
     */
    orderBy?: ulasanOrderByWithRelationInput | ulasanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ulasans.
     */
    cursor?: ulasanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ulasans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ulasans.
     */
    skip?: number
    distinct?: UlasanScalarFieldEnum | UlasanScalarFieldEnum[]
  }

  /**
   * ulasan create
   */
  export type ulasanCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ulasan
     */
    select?: ulasanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ulasanInclude<ExtArgs> | null
    /**
     * The data needed to create a ulasan.
     */
    data: XOR<ulasanCreateInput, ulasanUncheckedCreateInput>
  }

  /**
   * ulasan createMany
   */
  export type ulasanCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ulasans.
     */
    data: ulasanCreateManyInput | ulasanCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ulasan update
   */
  export type ulasanUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ulasan
     */
    select?: ulasanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ulasanInclude<ExtArgs> | null
    /**
     * The data needed to update a ulasan.
     */
    data: XOR<ulasanUpdateInput, ulasanUncheckedUpdateInput>
    /**
     * Choose, which ulasan to update.
     */
    where: ulasanWhereUniqueInput
  }

  /**
   * ulasan updateMany
   */
  export type ulasanUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ulasans.
     */
    data: XOR<ulasanUpdateManyMutationInput, ulasanUncheckedUpdateManyInput>
    /**
     * Filter which ulasans to update
     */
    where?: ulasanWhereInput
  }

  /**
   * ulasan upsert
   */
  export type ulasanUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ulasan
     */
    select?: ulasanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ulasanInclude<ExtArgs> | null
    /**
     * The filter to search for the ulasan to update in case it exists.
     */
    where: ulasanWhereUniqueInput
    /**
     * In case the ulasan found by the `where` argument doesn't exist, create a new ulasan with this data.
     */
    create: XOR<ulasanCreateInput, ulasanUncheckedCreateInput>
    /**
     * In case the ulasan was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ulasanUpdateInput, ulasanUncheckedUpdateInput>
  }

  /**
   * ulasan delete
   */
  export type ulasanDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ulasan
     */
    select?: ulasanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ulasanInclude<ExtArgs> | null
    /**
     * Filter which ulasan to delete.
     */
    where: ulasanWhereUniqueInput
  }

  /**
   * ulasan deleteMany
   */
  export type ulasanDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ulasans to delete
     */
    where?: ulasanWhereInput
  }

  /**
   * ulasan without action
   */
  export type ulasanDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ulasan
     */
    select?: ulasanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ulasanInclude<ExtArgs> | null
  }


  /**
   * Model pendapatan_mitra
   */

  export type AggregatePendapatan_mitra = {
    _count: Pendapatan_mitraCountAggregateOutputType | null
    _avg: Pendapatan_mitraAvgAggregateOutputType | null
    _sum: Pendapatan_mitraSumAggregateOutputType | null
    _min: Pendapatan_mitraMinAggregateOutputType | null
    _max: Pendapatan_mitraMaxAggregateOutputType | null
  }

  export type Pendapatan_mitraAvgAggregateOutputType = {
    id: number | null
    mitra_id: number | null
    transaksi_id: number | null
    jumlah: Decimal | null
  }

  export type Pendapatan_mitraSumAggregateOutputType = {
    id: number | null
    mitra_id: number | null
    transaksi_id: number | null
    jumlah: Decimal | null
  }

  export type Pendapatan_mitraMinAggregateOutputType = {
    id: number | null
    mitra_id: number | null
    transaksi_id: number | null
    jumlah: Decimal | null
    created_at: Date | null
  }

  export type Pendapatan_mitraMaxAggregateOutputType = {
    id: number | null
    mitra_id: number | null
    transaksi_id: number | null
    jumlah: Decimal | null
    created_at: Date | null
  }

  export type Pendapatan_mitraCountAggregateOutputType = {
    id: number
    mitra_id: number
    transaksi_id: number
    jumlah: number
    created_at: number
    _all: number
  }


  export type Pendapatan_mitraAvgAggregateInputType = {
    id?: true
    mitra_id?: true
    transaksi_id?: true
    jumlah?: true
  }

  export type Pendapatan_mitraSumAggregateInputType = {
    id?: true
    mitra_id?: true
    transaksi_id?: true
    jumlah?: true
  }

  export type Pendapatan_mitraMinAggregateInputType = {
    id?: true
    mitra_id?: true
    transaksi_id?: true
    jumlah?: true
    created_at?: true
  }

  export type Pendapatan_mitraMaxAggregateInputType = {
    id?: true
    mitra_id?: true
    transaksi_id?: true
    jumlah?: true
    created_at?: true
  }

  export type Pendapatan_mitraCountAggregateInputType = {
    id?: true
    mitra_id?: true
    transaksi_id?: true
    jumlah?: true
    created_at?: true
    _all?: true
  }

  export type Pendapatan_mitraAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which pendapatan_mitra to aggregate.
     */
    where?: pendapatan_mitraWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pendapatan_mitras to fetch.
     */
    orderBy?: pendapatan_mitraOrderByWithRelationInput | pendapatan_mitraOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: pendapatan_mitraWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pendapatan_mitras from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pendapatan_mitras.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned pendapatan_mitras
    **/
    _count?: true | Pendapatan_mitraCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Pendapatan_mitraAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Pendapatan_mitraSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Pendapatan_mitraMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Pendapatan_mitraMaxAggregateInputType
  }

  export type GetPendapatan_mitraAggregateType<T extends Pendapatan_mitraAggregateArgs> = {
        [P in keyof T & keyof AggregatePendapatan_mitra]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePendapatan_mitra[P]>
      : GetScalarType<T[P], AggregatePendapatan_mitra[P]>
  }




  export type pendapatan_mitraGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: pendapatan_mitraWhereInput
    orderBy?: pendapatan_mitraOrderByWithAggregationInput | pendapatan_mitraOrderByWithAggregationInput[]
    by: Pendapatan_mitraScalarFieldEnum[] | Pendapatan_mitraScalarFieldEnum
    having?: pendapatan_mitraScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Pendapatan_mitraCountAggregateInputType | true
    _avg?: Pendapatan_mitraAvgAggregateInputType
    _sum?: Pendapatan_mitraSumAggregateInputType
    _min?: Pendapatan_mitraMinAggregateInputType
    _max?: Pendapatan_mitraMaxAggregateInputType
  }

  export type Pendapatan_mitraGroupByOutputType = {
    id: number
    mitra_id: number
    transaksi_id: number
    jumlah: Decimal
    created_at: Date
    _count: Pendapatan_mitraCountAggregateOutputType | null
    _avg: Pendapatan_mitraAvgAggregateOutputType | null
    _sum: Pendapatan_mitraSumAggregateOutputType | null
    _min: Pendapatan_mitraMinAggregateOutputType | null
    _max: Pendapatan_mitraMaxAggregateOutputType | null
  }

  type GetPendapatan_mitraGroupByPayload<T extends pendapatan_mitraGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Pendapatan_mitraGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Pendapatan_mitraGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Pendapatan_mitraGroupByOutputType[P]>
            : GetScalarType<T[P], Pendapatan_mitraGroupByOutputType[P]>
        }
      >
    >


  export type pendapatan_mitraSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    mitra_id?: boolean
    transaksi_id?: boolean
    jumlah?: boolean
    created_at?: boolean
    mitra?: boolean | MitraDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pendapatan_mitra"]>


  export type pendapatan_mitraSelectScalar = {
    id?: boolean
    mitra_id?: boolean
    transaksi_id?: boolean
    jumlah?: boolean
    created_at?: boolean
  }

  export type pendapatan_mitraInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mitra?: boolean | MitraDefaultArgs<ExtArgs>
  }

  export type $pendapatan_mitraPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "pendapatan_mitra"
    objects: {
      mitra: Prisma.$MitraPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      mitra_id: number
      transaksi_id: number
      jumlah: Prisma.Decimal
      created_at: Date
    }, ExtArgs["result"]["pendapatan_mitra"]>
    composites: {}
  }

  type pendapatan_mitraGetPayload<S extends boolean | null | undefined | pendapatan_mitraDefaultArgs> = $Result.GetResult<Prisma.$pendapatan_mitraPayload, S>

  type pendapatan_mitraCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<pendapatan_mitraFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Pendapatan_mitraCountAggregateInputType | true
    }

  export interface pendapatan_mitraDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['pendapatan_mitra'], meta: { name: 'pendapatan_mitra' } }
    /**
     * Find zero or one Pendapatan_mitra that matches the filter.
     * @param {pendapatan_mitraFindUniqueArgs} args - Arguments to find a Pendapatan_mitra
     * @example
     * // Get one Pendapatan_mitra
     * const pendapatan_mitra = await prisma.pendapatan_mitra.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends pendapatan_mitraFindUniqueArgs>(args: SelectSubset<T, pendapatan_mitraFindUniqueArgs<ExtArgs>>): Prisma__pendapatan_mitraClient<$Result.GetResult<Prisma.$pendapatan_mitraPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Pendapatan_mitra that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {pendapatan_mitraFindUniqueOrThrowArgs} args - Arguments to find a Pendapatan_mitra
     * @example
     * // Get one Pendapatan_mitra
     * const pendapatan_mitra = await prisma.pendapatan_mitra.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends pendapatan_mitraFindUniqueOrThrowArgs>(args: SelectSubset<T, pendapatan_mitraFindUniqueOrThrowArgs<ExtArgs>>): Prisma__pendapatan_mitraClient<$Result.GetResult<Prisma.$pendapatan_mitraPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Pendapatan_mitra that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pendapatan_mitraFindFirstArgs} args - Arguments to find a Pendapatan_mitra
     * @example
     * // Get one Pendapatan_mitra
     * const pendapatan_mitra = await prisma.pendapatan_mitra.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends pendapatan_mitraFindFirstArgs>(args?: SelectSubset<T, pendapatan_mitraFindFirstArgs<ExtArgs>>): Prisma__pendapatan_mitraClient<$Result.GetResult<Prisma.$pendapatan_mitraPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Pendapatan_mitra that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pendapatan_mitraFindFirstOrThrowArgs} args - Arguments to find a Pendapatan_mitra
     * @example
     * // Get one Pendapatan_mitra
     * const pendapatan_mitra = await prisma.pendapatan_mitra.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends pendapatan_mitraFindFirstOrThrowArgs>(args?: SelectSubset<T, pendapatan_mitraFindFirstOrThrowArgs<ExtArgs>>): Prisma__pendapatan_mitraClient<$Result.GetResult<Prisma.$pendapatan_mitraPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Pendapatan_mitras that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pendapatan_mitraFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Pendapatan_mitras
     * const pendapatan_mitras = await prisma.pendapatan_mitra.findMany()
     * 
     * // Get first 10 Pendapatan_mitras
     * const pendapatan_mitras = await prisma.pendapatan_mitra.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pendapatan_mitraWithIdOnly = await prisma.pendapatan_mitra.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends pendapatan_mitraFindManyArgs>(args?: SelectSubset<T, pendapatan_mitraFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$pendapatan_mitraPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Pendapatan_mitra.
     * @param {pendapatan_mitraCreateArgs} args - Arguments to create a Pendapatan_mitra.
     * @example
     * // Create one Pendapatan_mitra
     * const Pendapatan_mitra = await prisma.pendapatan_mitra.create({
     *   data: {
     *     // ... data to create a Pendapatan_mitra
     *   }
     * })
     * 
     */
    create<T extends pendapatan_mitraCreateArgs>(args: SelectSubset<T, pendapatan_mitraCreateArgs<ExtArgs>>): Prisma__pendapatan_mitraClient<$Result.GetResult<Prisma.$pendapatan_mitraPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Pendapatan_mitras.
     * @param {pendapatan_mitraCreateManyArgs} args - Arguments to create many Pendapatan_mitras.
     * @example
     * // Create many Pendapatan_mitras
     * const pendapatan_mitra = await prisma.pendapatan_mitra.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends pendapatan_mitraCreateManyArgs>(args?: SelectSubset<T, pendapatan_mitraCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Pendapatan_mitra.
     * @param {pendapatan_mitraDeleteArgs} args - Arguments to delete one Pendapatan_mitra.
     * @example
     * // Delete one Pendapatan_mitra
     * const Pendapatan_mitra = await prisma.pendapatan_mitra.delete({
     *   where: {
     *     // ... filter to delete one Pendapatan_mitra
     *   }
     * })
     * 
     */
    delete<T extends pendapatan_mitraDeleteArgs>(args: SelectSubset<T, pendapatan_mitraDeleteArgs<ExtArgs>>): Prisma__pendapatan_mitraClient<$Result.GetResult<Prisma.$pendapatan_mitraPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Pendapatan_mitra.
     * @param {pendapatan_mitraUpdateArgs} args - Arguments to update one Pendapatan_mitra.
     * @example
     * // Update one Pendapatan_mitra
     * const pendapatan_mitra = await prisma.pendapatan_mitra.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends pendapatan_mitraUpdateArgs>(args: SelectSubset<T, pendapatan_mitraUpdateArgs<ExtArgs>>): Prisma__pendapatan_mitraClient<$Result.GetResult<Prisma.$pendapatan_mitraPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Pendapatan_mitras.
     * @param {pendapatan_mitraDeleteManyArgs} args - Arguments to filter Pendapatan_mitras to delete.
     * @example
     * // Delete a few Pendapatan_mitras
     * const { count } = await prisma.pendapatan_mitra.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends pendapatan_mitraDeleteManyArgs>(args?: SelectSubset<T, pendapatan_mitraDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pendapatan_mitras.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pendapatan_mitraUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Pendapatan_mitras
     * const pendapatan_mitra = await prisma.pendapatan_mitra.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends pendapatan_mitraUpdateManyArgs>(args: SelectSubset<T, pendapatan_mitraUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Pendapatan_mitra.
     * @param {pendapatan_mitraUpsertArgs} args - Arguments to update or create a Pendapatan_mitra.
     * @example
     * // Update or create a Pendapatan_mitra
     * const pendapatan_mitra = await prisma.pendapatan_mitra.upsert({
     *   create: {
     *     // ... data to create a Pendapatan_mitra
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Pendapatan_mitra we want to update
     *   }
     * })
     */
    upsert<T extends pendapatan_mitraUpsertArgs>(args: SelectSubset<T, pendapatan_mitraUpsertArgs<ExtArgs>>): Prisma__pendapatan_mitraClient<$Result.GetResult<Prisma.$pendapatan_mitraPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Pendapatan_mitras.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pendapatan_mitraCountArgs} args - Arguments to filter Pendapatan_mitras to count.
     * @example
     * // Count the number of Pendapatan_mitras
     * const count = await prisma.pendapatan_mitra.count({
     *   where: {
     *     // ... the filter for the Pendapatan_mitras we want to count
     *   }
     * })
    **/
    count<T extends pendapatan_mitraCountArgs>(
      args?: Subset<T, pendapatan_mitraCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Pendapatan_mitraCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Pendapatan_mitra.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Pendapatan_mitraAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Pendapatan_mitraAggregateArgs>(args: Subset<T, Pendapatan_mitraAggregateArgs>): Prisma.PrismaPromise<GetPendapatan_mitraAggregateType<T>>

    /**
     * Group by Pendapatan_mitra.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pendapatan_mitraGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends pendapatan_mitraGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: pendapatan_mitraGroupByArgs['orderBy'] }
        : { orderBy?: pendapatan_mitraGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, pendapatan_mitraGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPendapatan_mitraGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the pendapatan_mitra model
   */
  readonly fields: pendapatan_mitraFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for pendapatan_mitra.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__pendapatan_mitraClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    mitra<T extends MitraDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MitraDefaultArgs<ExtArgs>>): Prisma__MitraClient<$Result.GetResult<Prisma.$MitraPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the pendapatan_mitra model
   */ 
  interface pendapatan_mitraFieldRefs {
    readonly id: FieldRef<"pendapatan_mitra", 'Int'>
    readonly mitra_id: FieldRef<"pendapatan_mitra", 'Int'>
    readonly transaksi_id: FieldRef<"pendapatan_mitra", 'Int'>
    readonly jumlah: FieldRef<"pendapatan_mitra", 'Decimal'>
    readonly created_at: FieldRef<"pendapatan_mitra", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * pendapatan_mitra findUnique
   */
  export type pendapatan_mitraFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pendapatan_mitra
     */
    select?: pendapatan_mitraSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pendapatan_mitraInclude<ExtArgs> | null
    /**
     * Filter, which pendapatan_mitra to fetch.
     */
    where: pendapatan_mitraWhereUniqueInput
  }

  /**
   * pendapatan_mitra findUniqueOrThrow
   */
  export type pendapatan_mitraFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pendapatan_mitra
     */
    select?: pendapatan_mitraSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pendapatan_mitraInclude<ExtArgs> | null
    /**
     * Filter, which pendapatan_mitra to fetch.
     */
    where: pendapatan_mitraWhereUniqueInput
  }

  /**
   * pendapatan_mitra findFirst
   */
  export type pendapatan_mitraFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pendapatan_mitra
     */
    select?: pendapatan_mitraSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pendapatan_mitraInclude<ExtArgs> | null
    /**
     * Filter, which pendapatan_mitra to fetch.
     */
    where?: pendapatan_mitraWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pendapatan_mitras to fetch.
     */
    orderBy?: pendapatan_mitraOrderByWithRelationInput | pendapatan_mitraOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for pendapatan_mitras.
     */
    cursor?: pendapatan_mitraWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pendapatan_mitras from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pendapatan_mitras.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of pendapatan_mitras.
     */
    distinct?: Pendapatan_mitraScalarFieldEnum | Pendapatan_mitraScalarFieldEnum[]
  }

  /**
   * pendapatan_mitra findFirstOrThrow
   */
  export type pendapatan_mitraFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pendapatan_mitra
     */
    select?: pendapatan_mitraSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pendapatan_mitraInclude<ExtArgs> | null
    /**
     * Filter, which pendapatan_mitra to fetch.
     */
    where?: pendapatan_mitraWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pendapatan_mitras to fetch.
     */
    orderBy?: pendapatan_mitraOrderByWithRelationInput | pendapatan_mitraOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for pendapatan_mitras.
     */
    cursor?: pendapatan_mitraWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pendapatan_mitras from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pendapatan_mitras.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of pendapatan_mitras.
     */
    distinct?: Pendapatan_mitraScalarFieldEnum | Pendapatan_mitraScalarFieldEnum[]
  }

  /**
   * pendapatan_mitra findMany
   */
  export type pendapatan_mitraFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pendapatan_mitra
     */
    select?: pendapatan_mitraSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pendapatan_mitraInclude<ExtArgs> | null
    /**
     * Filter, which pendapatan_mitras to fetch.
     */
    where?: pendapatan_mitraWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pendapatan_mitras to fetch.
     */
    orderBy?: pendapatan_mitraOrderByWithRelationInput | pendapatan_mitraOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing pendapatan_mitras.
     */
    cursor?: pendapatan_mitraWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pendapatan_mitras from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pendapatan_mitras.
     */
    skip?: number
    distinct?: Pendapatan_mitraScalarFieldEnum | Pendapatan_mitraScalarFieldEnum[]
  }

  /**
   * pendapatan_mitra create
   */
  export type pendapatan_mitraCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pendapatan_mitra
     */
    select?: pendapatan_mitraSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pendapatan_mitraInclude<ExtArgs> | null
    /**
     * The data needed to create a pendapatan_mitra.
     */
    data: XOR<pendapatan_mitraCreateInput, pendapatan_mitraUncheckedCreateInput>
  }

  /**
   * pendapatan_mitra createMany
   */
  export type pendapatan_mitraCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many pendapatan_mitras.
     */
    data: pendapatan_mitraCreateManyInput | pendapatan_mitraCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * pendapatan_mitra update
   */
  export type pendapatan_mitraUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pendapatan_mitra
     */
    select?: pendapatan_mitraSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pendapatan_mitraInclude<ExtArgs> | null
    /**
     * The data needed to update a pendapatan_mitra.
     */
    data: XOR<pendapatan_mitraUpdateInput, pendapatan_mitraUncheckedUpdateInput>
    /**
     * Choose, which pendapatan_mitra to update.
     */
    where: pendapatan_mitraWhereUniqueInput
  }

  /**
   * pendapatan_mitra updateMany
   */
  export type pendapatan_mitraUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update pendapatan_mitras.
     */
    data: XOR<pendapatan_mitraUpdateManyMutationInput, pendapatan_mitraUncheckedUpdateManyInput>
    /**
     * Filter which pendapatan_mitras to update
     */
    where?: pendapatan_mitraWhereInput
  }

  /**
   * pendapatan_mitra upsert
   */
  export type pendapatan_mitraUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pendapatan_mitra
     */
    select?: pendapatan_mitraSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pendapatan_mitraInclude<ExtArgs> | null
    /**
     * The filter to search for the pendapatan_mitra to update in case it exists.
     */
    where: pendapatan_mitraWhereUniqueInput
    /**
     * In case the pendapatan_mitra found by the `where` argument doesn't exist, create a new pendapatan_mitra with this data.
     */
    create: XOR<pendapatan_mitraCreateInput, pendapatan_mitraUncheckedCreateInput>
    /**
     * In case the pendapatan_mitra was found with the provided `where` argument, update it with this data.
     */
    update: XOR<pendapatan_mitraUpdateInput, pendapatan_mitraUncheckedUpdateInput>
  }

  /**
   * pendapatan_mitra delete
   */
  export type pendapatan_mitraDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pendapatan_mitra
     */
    select?: pendapatan_mitraSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pendapatan_mitraInclude<ExtArgs> | null
    /**
     * Filter which pendapatan_mitra to delete.
     */
    where: pendapatan_mitraWhereUniqueInput
  }

  /**
   * pendapatan_mitra deleteMany
   */
  export type pendapatan_mitraDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which pendapatan_mitras to delete
     */
    where?: pendapatan_mitraWhereInput
  }

  /**
   * pendapatan_mitra without action
   */
  export type pendapatan_mitraDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pendapatan_mitra
     */
    select?: pendapatan_mitraSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pendapatan_mitraInclude<ExtArgs> | null
  }


  /**
   * Model pencairan_pendapatan
   */

  export type AggregatePencairan_pendapatan = {
    _count: Pencairan_pendapatanCountAggregateOutputType | null
    _avg: Pencairan_pendapatanAvgAggregateOutputType | null
    _sum: Pencairan_pendapatanSumAggregateOutputType | null
    _min: Pencairan_pendapatanMinAggregateOutputType | null
    _max: Pencairan_pendapatanMaxAggregateOutputType | null
  }

  export type Pencairan_pendapatanAvgAggregateOutputType = {
    id: number | null
    mitra_id: number | null
    jumlah: Decimal | null
  }

  export type Pencairan_pendapatanSumAggregateOutputType = {
    id: number | null
    mitra_id: number | null
    jumlah: Decimal | null
  }

  export type Pencairan_pendapatanMinAggregateOutputType = {
    id: number | null
    mitra_id: number | null
    jumlah: Decimal | null
    status: $Enums.pencairan_status | null
    created_at: Date | null
  }

  export type Pencairan_pendapatanMaxAggregateOutputType = {
    id: number | null
    mitra_id: number | null
    jumlah: Decimal | null
    status: $Enums.pencairan_status | null
    created_at: Date | null
  }

  export type Pencairan_pendapatanCountAggregateOutputType = {
    id: number
    mitra_id: number
    jumlah: number
    status: number
    created_at: number
    _all: number
  }


  export type Pencairan_pendapatanAvgAggregateInputType = {
    id?: true
    mitra_id?: true
    jumlah?: true
  }

  export type Pencairan_pendapatanSumAggregateInputType = {
    id?: true
    mitra_id?: true
    jumlah?: true
  }

  export type Pencairan_pendapatanMinAggregateInputType = {
    id?: true
    mitra_id?: true
    jumlah?: true
    status?: true
    created_at?: true
  }

  export type Pencairan_pendapatanMaxAggregateInputType = {
    id?: true
    mitra_id?: true
    jumlah?: true
    status?: true
    created_at?: true
  }

  export type Pencairan_pendapatanCountAggregateInputType = {
    id?: true
    mitra_id?: true
    jumlah?: true
    status?: true
    created_at?: true
    _all?: true
  }

  export type Pencairan_pendapatanAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which pencairan_pendapatan to aggregate.
     */
    where?: pencairan_pendapatanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pencairan_pendapatans to fetch.
     */
    orderBy?: pencairan_pendapatanOrderByWithRelationInput | pencairan_pendapatanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: pencairan_pendapatanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pencairan_pendapatans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pencairan_pendapatans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned pencairan_pendapatans
    **/
    _count?: true | Pencairan_pendapatanCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Pencairan_pendapatanAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Pencairan_pendapatanSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Pencairan_pendapatanMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Pencairan_pendapatanMaxAggregateInputType
  }

  export type GetPencairan_pendapatanAggregateType<T extends Pencairan_pendapatanAggregateArgs> = {
        [P in keyof T & keyof AggregatePencairan_pendapatan]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePencairan_pendapatan[P]>
      : GetScalarType<T[P], AggregatePencairan_pendapatan[P]>
  }




  export type pencairan_pendapatanGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: pencairan_pendapatanWhereInput
    orderBy?: pencairan_pendapatanOrderByWithAggregationInput | pencairan_pendapatanOrderByWithAggregationInput[]
    by: Pencairan_pendapatanScalarFieldEnum[] | Pencairan_pendapatanScalarFieldEnum
    having?: pencairan_pendapatanScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Pencairan_pendapatanCountAggregateInputType | true
    _avg?: Pencairan_pendapatanAvgAggregateInputType
    _sum?: Pencairan_pendapatanSumAggregateInputType
    _min?: Pencairan_pendapatanMinAggregateInputType
    _max?: Pencairan_pendapatanMaxAggregateInputType
  }

  export type Pencairan_pendapatanGroupByOutputType = {
    id: number
    mitra_id: number
    jumlah: Decimal
    status: $Enums.pencairan_status
    created_at: Date
    _count: Pencairan_pendapatanCountAggregateOutputType | null
    _avg: Pencairan_pendapatanAvgAggregateOutputType | null
    _sum: Pencairan_pendapatanSumAggregateOutputType | null
    _min: Pencairan_pendapatanMinAggregateOutputType | null
    _max: Pencairan_pendapatanMaxAggregateOutputType | null
  }

  type GetPencairan_pendapatanGroupByPayload<T extends pencairan_pendapatanGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Pencairan_pendapatanGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Pencairan_pendapatanGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Pencairan_pendapatanGroupByOutputType[P]>
            : GetScalarType<T[P], Pencairan_pendapatanGroupByOutputType[P]>
        }
      >
    >


  export type pencairan_pendapatanSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    mitra_id?: boolean
    jumlah?: boolean
    status?: boolean
    created_at?: boolean
    mitra?: boolean | MitraDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pencairan_pendapatan"]>


  export type pencairan_pendapatanSelectScalar = {
    id?: boolean
    mitra_id?: boolean
    jumlah?: boolean
    status?: boolean
    created_at?: boolean
  }

  export type pencairan_pendapatanInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mitra?: boolean | MitraDefaultArgs<ExtArgs>
  }

  export type $pencairan_pendapatanPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "pencairan_pendapatan"
    objects: {
      mitra: Prisma.$MitraPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      mitra_id: number
      jumlah: Prisma.Decimal
      status: $Enums.pencairan_status
      created_at: Date
    }, ExtArgs["result"]["pencairan_pendapatan"]>
    composites: {}
  }

  type pencairan_pendapatanGetPayload<S extends boolean | null | undefined | pencairan_pendapatanDefaultArgs> = $Result.GetResult<Prisma.$pencairan_pendapatanPayload, S>

  type pencairan_pendapatanCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<pencairan_pendapatanFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Pencairan_pendapatanCountAggregateInputType | true
    }

  export interface pencairan_pendapatanDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['pencairan_pendapatan'], meta: { name: 'pencairan_pendapatan' } }
    /**
     * Find zero or one Pencairan_pendapatan that matches the filter.
     * @param {pencairan_pendapatanFindUniqueArgs} args - Arguments to find a Pencairan_pendapatan
     * @example
     * // Get one Pencairan_pendapatan
     * const pencairan_pendapatan = await prisma.pencairan_pendapatan.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends pencairan_pendapatanFindUniqueArgs>(args: SelectSubset<T, pencairan_pendapatanFindUniqueArgs<ExtArgs>>): Prisma__pencairan_pendapatanClient<$Result.GetResult<Prisma.$pencairan_pendapatanPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Pencairan_pendapatan that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {pencairan_pendapatanFindUniqueOrThrowArgs} args - Arguments to find a Pencairan_pendapatan
     * @example
     * // Get one Pencairan_pendapatan
     * const pencairan_pendapatan = await prisma.pencairan_pendapatan.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends pencairan_pendapatanFindUniqueOrThrowArgs>(args: SelectSubset<T, pencairan_pendapatanFindUniqueOrThrowArgs<ExtArgs>>): Prisma__pencairan_pendapatanClient<$Result.GetResult<Prisma.$pencairan_pendapatanPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Pencairan_pendapatan that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pencairan_pendapatanFindFirstArgs} args - Arguments to find a Pencairan_pendapatan
     * @example
     * // Get one Pencairan_pendapatan
     * const pencairan_pendapatan = await prisma.pencairan_pendapatan.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends pencairan_pendapatanFindFirstArgs>(args?: SelectSubset<T, pencairan_pendapatanFindFirstArgs<ExtArgs>>): Prisma__pencairan_pendapatanClient<$Result.GetResult<Prisma.$pencairan_pendapatanPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Pencairan_pendapatan that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pencairan_pendapatanFindFirstOrThrowArgs} args - Arguments to find a Pencairan_pendapatan
     * @example
     * // Get one Pencairan_pendapatan
     * const pencairan_pendapatan = await prisma.pencairan_pendapatan.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends pencairan_pendapatanFindFirstOrThrowArgs>(args?: SelectSubset<T, pencairan_pendapatanFindFirstOrThrowArgs<ExtArgs>>): Prisma__pencairan_pendapatanClient<$Result.GetResult<Prisma.$pencairan_pendapatanPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Pencairan_pendapatans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pencairan_pendapatanFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Pencairan_pendapatans
     * const pencairan_pendapatans = await prisma.pencairan_pendapatan.findMany()
     * 
     * // Get first 10 Pencairan_pendapatans
     * const pencairan_pendapatans = await prisma.pencairan_pendapatan.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pencairan_pendapatanWithIdOnly = await prisma.pencairan_pendapatan.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends pencairan_pendapatanFindManyArgs>(args?: SelectSubset<T, pencairan_pendapatanFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$pencairan_pendapatanPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Pencairan_pendapatan.
     * @param {pencairan_pendapatanCreateArgs} args - Arguments to create a Pencairan_pendapatan.
     * @example
     * // Create one Pencairan_pendapatan
     * const Pencairan_pendapatan = await prisma.pencairan_pendapatan.create({
     *   data: {
     *     // ... data to create a Pencairan_pendapatan
     *   }
     * })
     * 
     */
    create<T extends pencairan_pendapatanCreateArgs>(args: SelectSubset<T, pencairan_pendapatanCreateArgs<ExtArgs>>): Prisma__pencairan_pendapatanClient<$Result.GetResult<Prisma.$pencairan_pendapatanPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Pencairan_pendapatans.
     * @param {pencairan_pendapatanCreateManyArgs} args - Arguments to create many Pencairan_pendapatans.
     * @example
     * // Create many Pencairan_pendapatans
     * const pencairan_pendapatan = await prisma.pencairan_pendapatan.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends pencairan_pendapatanCreateManyArgs>(args?: SelectSubset<T, pencairan_pendapatanCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Pencairan_pendapatan.
     * @param {pencairan_pendapatanDeleteArgs} args - Arguments to delete one Pencairan_pendapatan.
     * @example
     * // Delete one Pencairan_pendapatan
     * const Pencairan_pendapatan = await prisma.pencairan_pendapatan.delete({
     *   where: {
     *     // ... filter to delete one Pencairan_pendapatan
     *   }
     * })
     * 
     */
    delete<T extends pencairan_pendapatanDeleteArgs>(args: SelectSubset<T, pencairan_pendapatanDeleteArgs<ExtArgs>>): Prisma__pencairan_pendapatanClient<$Result.GetResult<Prisma.$pencairan_pendapatanPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Pencairan_pendapatan.
     * @param {pencairan_pendapatanUpdateArgs} args - Arguments to update one Pencairan_pendapatan.
     * @example
     * // Update one Pencairan_pendapatan
     * const pencairan_pendapatan = await prisma.pencairan_pendapatan.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends pencairan_pendapatanUpdateArgs>(args: SelectSubset<T, pencairan_pendapatanUpdateArgs<ExtArgs>>): Prisma__pencairan_pendapatanClient<$Result.GetResult<Prisma.$pencairan_pendapatanPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Pencairan_pendapatans.
     * @param {pencairan_pendapatanDeleteManyArgs} args - Arguments to filter Pencairan_pendapatans to delete.
     * @example
     * // Delete a few Pencairan_pendapatans
     * const { count } = await prisma.pencairan_pendapatan.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends pencairan_pendapatanDeleteManyArgs>(args?: SelectSubset<T, pencairan_pendapatanDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pencairan_pendapatans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pencairan_pendapatanUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Pencairan_pendapatans
     * const pencairan_pendapatan = await prisma.pencairan_pendapatan.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends pencairan_pendapatanUpdateManyArgs>(args: SelectSubset<T, pencairan_pendapatanUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Pencairan_pendapatan.
     * @param {pencairan_pendapatanUpsertArgs} args - Arguments to update or create a Pencairan_pendapatan.
     * @example
     * // Update or create a Pencairan_pendapatan
     * const pencairan_pendapatan = await prisma.pencairan_pendapatan.upsert({
     *   create: {
     *     // ... data to create a Pencairan_pendapatan
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Pencairan_pendapatan we want to update
     *   }
     * })
     */
    upsert<T extends pencairan_pendapatanUpsertArgs>(args: SelectSubset<T, pencairan_pendapatanUpsertArgs<ExtArgs>>): Prisma__pencairan_pendapatanClient<$Result.GetResult<Prisma.$pencairan_pendapatanPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Pencairan_pendapatans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pencairan_pendapatanCountArgs} args - Arguments to filter Pencairan_pendapatans to count.
     * @example
     * // Count the number of Pencairan_pendapatans
     * const count = await prisma.pencairan_pendapatan.count({
     *   where: {
     *     // ... the filter for the Pencairan_pendapatans we want to count
     *   }
     * })
    **/
    count<T extends pencairan_pendapatanCountArgs>(
      args?: Subset<T, pencairan_pendapatanCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Pencairan_pendapatanCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Pencairan_pendapatan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Pencairan_pendapatanAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Pencairan_pendapatanAggregateArgs>(args: Subset<T, Pencairan_pendapatanAggregateArgs>): Prisma.PrismaPromise<GetPencairan_pendapatanAggregateType<T>>

    /**
     * Group by Pencairan_pendapatan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pencairan_pendapatanGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends pencairan_pendapatanGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: pencairan_pendapatanGroupByArgs['orderBy'] }
        : { orderBy?: pencairan_pendapatanGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, pencairan_pendapatanGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPencairan_pendapatanGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the pencairan_pendapatan model
   */
  readonly fields: pencairan_pendapatanFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for pencairan_pendapatan.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__pencairan_pendapatanClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    mitra<T extends MitraDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MitraDefaultArgs<ExtArgs>>): Prisma__MitraClient<$Result.GetResult<Prisma.$MitraPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the pencairan_pendapatan model
   */ 
  interface pencairan_pendapatanFieldRefs {
    readonly id: FieldRef<"pencairan_pendapatan", 'Int'>
    readonly mitra_id: FieldRef<"pencairan_pendapatan", 'Int'>
    readonly jumlah: FieldRef<"pencairan_pendapatan", 'Decimal'>
    readonly status: FieldRef<"pencairan_pendapatan", 'pencairan_status'>
    readonly created_at: FieldRef<"pencairan_pendapatan", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * pencairan_pendapatan findUnique
   */
  export type pencairan_pendapatanFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pencairan_pendapatan
     */
    select?: pencairan_pendapatanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pencairan_pendapatanInclude<ExtArgs> | null
    /**
     * Filter, which pencairan_pendapatan to fetch.
     */
    where: pencairan_pendapatanWhereUniqueInput
  }

  /**
   * pencairan_pendapatan findUniqueOrThrow
   */
  export type pencairan_pendapatanFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pencairan_pendapatan
     */
    select?: pencairan_pendapatanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pencairan_pendapatanInclude<ExtArgs> | null
    /**
     * Filter, which pencairan_pendapatan to fetch.
     */
    where: pencairan_pendapatanWhereUniqueInput
  }

  /**
   * pencairan_pendapatan findFirst
   */
  export type pencairan_pendapatanFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pencairan_pendapatan
     */
    select?: pencairan_pendapatanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pencairan_pendapatanInclude<ExtArgs> | null
    /**
     * Filter, which pencairan_pendapatan to fetch.
     */
    where?: pencairan_pendapatanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pencairan_pendapatans to fetch.
     */
    orderBy?: pencairan_pendapatanOrderByWithRelationInput | pencairan_pendapatanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for pencairan_pendapatans.
     */
    cursor?: pencairan_pendapatanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pencairan_pendapatans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pencairan_pendapatans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of pencairan_pendapatans.
     */
    distinct?: Pencairan_pendapatanScalarFieldEnum | Pencairan_pendapatanScalarFieldEnum[]
  }

  /**
   * pencairan_pendapatan findFirstOrThrow
   */
  export type pencairan_pendapatanFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pencairan_pendapatan
     */
    select?: pencairan_pendapatanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pencairan_pendapatanInclude<ExtArgs> | null
    /**
     * Filter, which pencairan_pendapatan to fetch.
     */
    where?: pencairan_pendapatanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pencairan_pendapatans to fetch.
     */
    orderBy?: pencairan_pendapatanOrderByWithRelationInput | pencairan_pendapatanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for pencairan_pendapatans.
     */
    cursor?: pencairan_pendapatanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pencairan_pendapatans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pencairan_pendapatans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of pencairan_pendapatans.
     */
    distinct?: Pencairan_pendapatanScalarFieldEnum | Pencairan_pendapatanScalarFieldEnum[]
  }

  /**
   * pencairan_pendapatan findMany
   */
  export type pencairan_pendapatanFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pencairan_pendapatan
     */
    select?: pencairan_pendapatanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pencairan_pendapatanInclude<ExtArgs> | null
    /**
     * Filter, which pencairan_pendapatans to fetch.
     */
    where?: pencairan_pendapatanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pencairan_pendapatans to fetch.
     */
    orderBy?: pencairan_pendapatanOrderByWithRelationInput | pencairan_pendapatanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing pencairan_pendapatans.
     */
    cursor?: pencairan_pendapatanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pencairan_pendapatans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pencairan_pendapatans.
     */
    skip?: number
    distinct?: Pencairan_pendapatanScalarFieldEnum | Pencairan_pendapatanScalarFieldEnum[]
  }

  /**
   * pencairan_pendapatan create
   */
  export type pencairan_pendapatanCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pencairan_pendapatan
     */
    select?: pencairan_pendapatanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pencairan_pendapatanInclude<ExtArgs> | null
    /**
     * The data needed to create a pencairan_pendapatan.
     */
    data: XOR<pencairan_pendapatanCreateInput, pencairan_pendapatanUncheckedCreateInput>
  }

  /**
   * pencairan_pendapatan createMany
   */
  export type pencairan_pendapatanCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many pencairan_pendapatans.
     */
    data: pencairan_pendapatanCreateManyInput | pencairan_pendapatanCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * pencairan_pendapatan update
   */
  export type pencairan_pendapatanUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pencairan_pendapatan
     */
    select?: pencairan_pendapatanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pencairan_pendapatanInclude<ExtArgs> | null
    /**
     * The data needed to update a pencairan_pendapatan.
     */
    data: XOR<pencairan_pendapatanUpdateInput, pencairan_pendapatanUncheckedUpdateInput>
    /**
     * Choose, which pencairan_pendapatan to update.
     */
    where: pencairan_pendapatanWhereUniqueInput
  }

  /**
   * pencairan_pendapatan updateMany
   */
  export type pencairan_pendapatanUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update pencairan_pendapatans.
     */
    data: XOR<pencairan_pendapatanUpdateManyMutationInput, pencairan_pendapatanUncheckedUpdateManyInput>
    /**
     * Filter which pencairan_pendapatans to update
     */
    where?: pencairan_pendapatanWhereInput
  }

  /**
   * pencairan_pendapatan upsert
   */
  export type pencairan_pendapatanUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pencairan_pendapatan
     */
    select?: pencairan_pendapatanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pencairan_pendapatanInclude<ExtArgs> | null
    /**
     * The filter to search for the pencairan_pendapatan to update in case it exists.
     */
    where: pencairan_pendapatanWhereUniqueInput
    /**
     * In case the pencairan_pendapatan found by the `where` argument doesn't exist, create a new pencairan_pendapatan with this data.
     */
    create: XOR<pencairan_pendapatanCreateInput, pencairan_pendapatanUncheckedCreateInput>
    /**
     * In case the pencairan_pendapatan was found with the provided `where` argument, update it with this data.
     */
    update: XOR<pencairan_pendapatanUpdateInput, pencairan_pendapatanUncheckedUpdateInput>
  }

  /**
   * pencairan_pendapatan delete
   */
  export type pencairan_pendapatanDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pencairan_pendapatan
     */
    select?: pencairan_pendapatanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pencairan_pendapatanInclude<ExtArgs> | null
    /**
     * Filter which pencairan_pendapatan to delete.
     */
    where: pencairan_pendapatanWhereUniqueInput
  }

  /**
   * pencairan_pendapatan deleteMany
   */
  export type pencairan_pendapatanDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which pencairan_pendapatans to delete
     */
    where?: pencairan_pendapatanWhereInput
  }

  /**
   * pencairan_pendapatan without action
   */
  export type pencairan_pendapatanDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pencairan_pendapatan
     */
    select?: pencairan_pendapatanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pencairan_pendapatanInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UsersScalarFieldEnum: {
    id: 'id',
    nama: 'nama',
    username: 'username',
    email: 'email',
    password: 'password',
    no_hp: 'no_hp',
    foto: 'foto',
    bio: 'bio',
    role: 'role',
    status: 'status',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type UsersScalarFieldEnum = (typeof UsersScalarFieldEnum)[keyof typeof UsersScalarFieldEnum]


  export const MitraScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    nama_usaha: 'nama_usaha',
    alamat_usaha: 'alamat_usaha',
    no_ktp: 'no_ktp',
    foto_ktp: 'foto_ktp',
    withdraw_type: 'withdraw_type',
    withdraw_day: 'withdraw_day',
    bank_mitra: 'bank_mitra',
    no_rekening_mitra: 'no_rekening_mitra',
    status: 'status',
    created_at: 'created_at'
  };

  export type MitraScalarFieldEnum = (typeof MitraScalarFieldEnum)[keyof typeof MitraScalarFieldEnum]


  export const Otp_codesScalarFieldEnum: {
    id: 'id',
    user_email: 'user_email',
    kode_otp: 'kode_otp',
    expired_at: 'expired_at',
    digunakan: 'digunakan',
    created_at: 'created_at'
  };

  export type Otp_codesScalarFieldEnum = (typeof Otp_codesScalarFieldEnum)[keyof typeof Otp_codesScalarFieldEnum]


  export const LapanganScalarFieldEnum: {
    id: 'id',
    mitra_id: 'mitra_id',
    nama: 'nama',
    slug: 'slug',
    lokasi: 'lokasi',
    harga: 'harga',
    gambar: 'gambar',
    rating: 'rating',
    status: 'status',
    created_at: 'created_at'
  };

  export type LapanganScalarFieldEnum = (typeof LapanganScalarFieldEnum)[keyof typeof LapanganScalarFieldEnum]


  export const LapanganDetailScalarFieldEnum: {
    id: 'id',
    lapangan_id: 'lapangan_id',
    alamat: 'alamat',
    maps: 'maps',
    deskripsi: 'deskripsi',
    type: 'type',
    fasilitas: 'fasilitas',
    interval: 'interval',
    breakTime: 'breakTime'
  };

  export type LapanganDetailScalarFieldEnum = (typeof LapanganDetailScalarFieldEnum)[keyof typeof LapanganDetailScalarFieldEnum]


  export const LapanganGambarScalarFieldEnum: {
    id: 'id',
    lapangan_id: 'lapangan_id',
    file_name: 'file_name',
    created_at: 'created_at'
  };

  export type LapanganGambarScalarFieldEnum = (typeof LapanganGambarScalarFieldEnum)[keyof typeof LapanganGambarScalarFieldEnum]


  export const JadwalLapanganScalarFieldEnum: {
    id: 'id',
    lapangan_id: 'lapangan_id',
    tanggal: 'tanggal',
    slot: 'slot',
    status: 'status',
    locked_until: 'locked_until'
  };

  export type JadwalLapanganScalarFieldEnum = (typeof JadwalLapanganScalarFieldEnum)[keyof typeof JadwalLapanganScalarFieldEnum]


  export const Order_bookingScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    lapangan_id: 'lapangan_id',
    jadwalLapanganId: 'jadwalLapanganId',
    tanggal: 'tanggal',
    jam_mulai: 'jam_mulai',
    jam_selesai: 'jam_selesai',
    total_harga: 'total_harga',
    status: 'status',
    sewa_raket: 'sewa_raket',
    biaya_raket: 'biaya_raket',
    created_at: 'created_at',
    expired_at: 'expired_at'
  };

  export type Order_bookingScalarFieldEnum = (typeof Order_bookingScalarFieldEnum)[keyof typeof Order_bookingScalarFieldEnum]


  export const TransaksiScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    lapangan_id: 'lapangan_id',
    jadwal_id: 'jadwal_id',
    order_id: 'order_id',
    total_harga: 'total_harga',
    status_pembayaran: 'status_pembayaran',
    created_at: 'created_at'
  };

  export type TransaksiScalarFieldEnum = (typeof TransaksiScalarFieldEnum)[keyof typeof TransaksiScalarFieldEnum]


  export const Raket_padelScalarFieldEnum: {
    id: 'id',
    nama: 'nama',
    harga: 'harga'
  };

  export type Raket_padelScalarFieldEnum = (typeof Raket_padelScalarFieldEnum)[keyof typeof Raket_padelScalarFieldEnum]


  export const Sewa_raketScalarFieldEnum: {
    id: 'id',
    transaksi_id: 'transaksi_id',
    raket_id: 'raket_id',
    jumlah: 'jumlah',
    total_harga: 'total_harga'
  };

  export type Sewa_raketScalarFieldEnum = (typeof Sewa_raketScalarFieldEnum)[keyof typeof Sewa_raketScalarFieldEnum]


  export const Wallet_userScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    saldo: 'saldo',
    updated_at: 'updated_at'
  };

  export type Wallet_userScalarFieldEnum = (typeof Wallet_userScalarFieldEnum)[keyof typeof Wallet_userScalarFieldEnum]


  export const Wallet_historyScalarFieldEnum: {
    id: 'id',
    wallet_id: 'wallet_id',
    jumlah: 'jumlah',
    saldo_akhir: 'saldo_akhir',
    tipe: 'tipe',
    transaksi_id: 'transaksi_id',
    order_id: 'order_id',
    created_at: 'created_at'
  };

  export type Wallet_historyScalarFieldEnum = (typeof Wallet_historyScalarFieldEnum)[keyof typeof Wallet_historyScalarFieldEnum]


  export const RefundScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    transaksi_id: 'transaksi_id',
    order_id: 'order_id',
    jumlah: 'jumlah',
    alasan: 'alasan',
    status: 'status',
    created_at: 'created_at',
    processed_at: 'processed_at'
  };

  export type RefundScalarFieldEnum = (typeof RefundScalarFieldEnum)[keyof typeof RefundScalarFieldEnum]


  export const NotifikasiScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    pesan: 'pesan',
    dibaca: 'dibaca',
    created_at: 'created_at'
  };

  export type NotifikasiScalarFieldEnum = (typeof NotifikasiScalarFieldEnum)[keyof typeof NotifikasiScalarFieldEnum]


  export const UlasanScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    lapangan_id: 'lapangan_id',
    rating: 'rating',
    komentar: 'komentar',
    created_at: 'created_at'
  };

  export type UlasanScalarFieldEnum = (typeof UlasanScalarFieldEnum)[keyof typeof UlasanScalarFieldEnum]


  export const Pendapatan_mitraScalarFieldEnum: {
    id: 'id',
    mitra_id: 'mitra_id',
    transaksi_id: 'transaksi_id',
    jumlah: 'jumlah',
    created_at: 'created_at'
  };

  export type Pendapatan_mitraScalarFieldEnum = (typeof Pendapatan_mitraScalarFieldEnum)[keyof typeof Pendapatan_mitraScalarFieldEnum]


  export const Pencairan_pendapatanScalarFieldEnum: {
    id: 'id',
    mitra_id: 'mitra_id',
    jumlah: 'jumlah',
    status: 'status',
    created_at: 'created_at'
  };

  export type Pencairan_pendapatanScalarFieldEnum = (typeof Pencairan_pendapatanScalarFieldEnum)[keyof typeof Pencairan_pendapatanScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'users_role'
   */
  export type Enumusers_roleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'users_role'>
    


  /**
   * Reference to a field of type 'users_status'
   */
  export type Enumusers_statusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'users_status'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'mitra_status'
   */
  export type Enummitra_statusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'mitra_status'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'lapangan_status'
   */
  export type Enumlapangan_statusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'lapangan_status'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'jadwal_status'
   */
  export type Enumjadwal_statusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'jadwal_status'>
    


  /**
   * Reference to a field of type 'transaksi_status_pembayaran'
   */
  export type Enumtransaksi_status_pembayaranFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'transaksi_status_pembayaran'>
    


  /**
   * Reference to a field of type 'wallet_tipe'
   */
  export type Enumwallet_tipeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'wallet_tipe'>
    


  /**
   * Reference to a field of type 'refund_status'
   */
  export type Enumrefund_statusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'refund_status'>
    


  /**
   * Reference to a field of type 'pencairan_status'
   */
  export type Enumpencairan_statusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'pencairan_status'>
    
  /**
   * Deep Input Types
   */


  export type usersWhereInput = {
    AND?: usersWhereInput | usersWhereInput[]
    OR?: usersWhereInput[]
    NOT?: usersWhereInput | usersWhereInput[]
    id?: IntFilter<"users"> | number
    nama?: StringFilter<"users"> | string
    username?: StringFilter<"users"> | string
    email?: StringFilter<"users"> | string
    password?: StringFilter<"users"> | string
    no_hp?: StringNullableFilter<"users"> | string | null
    foto?: StringNullableFilter<"users"> | string | null
    bio?: StringNullableFilter<"users"> | string | null
    role?: Enumusers_roleFilter<"users"> | $Enums.users_role
    status?: Enumusers_statusFilter<"users"> | $Enums.users_status
    created_at?: DateTimeFilter<"users"> | Date | string
    updated_at?: DateTimeFilter<"users"> | Date | string
    mitra?: XOR<MitraNullableRelationFilter, MitraWhereInput> | null
    orders?: Order_bookingListRelationFilter
    transaksi?: TransaksiListRelationFilter
    notifikasi?: NotifikasiListRelationFilter
    ulasan?: UlasanListRelationFilter
    wallet?: XOR<Wallet_userNullableRelationFilter, wallet_userWhereInput> | null
    refund?: RefundListRelationFilter
  }

  export type usersOrderByWithRelationInput = {
    id?: SortOrder
    nama?: SortOrder
    username?: SortOrder
    email?: SortOrder
    password?: SortOrder
    no_hp?: SortOrderInput | SortOrder
    foto?: SortOrderInput | SortOrder
    bio?: SortOrderInput | SortOrder
    role?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    mitra?: MitraOrderByWithRelationInput
    orders?: order_bookingOrderByRelationAggregateInput
    transaksi?: transaksiOrderByRelationAggregateInput
    notifikasi?: notifikasiOrderByRelationAggregateInput
    ulasan?: ulasanOrderByRelationAggregateInput
    wallet?: wallet_userOrderByWithRelationInput
    refund?: refundOrderByRelationAggregateInput
  }

  export type usersWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    username?: string
    email?: string
    AND?: usersWhereInput | usersWhereInput[]
    OR?: usersWhereInput[]
    NOT?: usersWhereInput | usersWhereInput[]
    nama?: StringFilter<"users"> | string
    password?: StringFilter<"users"> | string
    no_hp?: StringNullableFilter<"users"> | string | null
    foto?: StringNullableFilter<"users"> | string | null
    bio?: StringNullableFilter<"users"> | string | null
    role?: Enumusers_roleFilter<"users"> | $Enums.users_role
    status?: Enumusers_statusFilter<"users"> | $Enums.users_status
    created_at?: DateTimeFilter<"users"> | Date | string
    updated_at?: DateTimeFilter<"users"> | Date | string
    mitra?: XOR<MitraNullableRelationFilter, MitraWhereInput> | null
    orders?: Order_bookingListRelationFilter
    transaksi?: TransaksiListRelationFilter
    notifikasi?: NotifikasiListRelationFilter
    ulasan?: UlasanListRelationFilter
    wallet?: XOR<Wallet_userNullableRelationFilter, wallet_userWhereInput> | null
    refund?: RefundListRelationFilter
  }, "id" | "username" | "email">

  export type usersOrderByWithAggregationInput = {
    id?: SortOrder
    nama?: SortOrder
    username?: SortOrder
    email?: SortOrder
    password?: SortOrder
    no_hp?: SortOrderInput | SortOrder
    foto?: SortOrderInput | SortOrder
    bio?: SortOrderInput | SortOrder
    role?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: usersCountOrderByAggregateInput
    _avg?: usersAvgOrderByAggregateInput
    _max?: usersMaxOrderByAggregateInput
    _min?: usersMinOrderByAggregateInput
    _sum?: usersSumOrderByAggregateInput
  }

  export type usersScalarWhereWithAggregatesInput = {
    AND?: usersScalarWhereWithAggregatesInput | usersScalarWhereWithAggregatesInput[]
    OR?: usersScalarWhereWithAggregatesInput[]
    NOT?: usersScalarWhereWithAggregatesInput | usersScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"users"> | number
    nama?: StringWithAggregatesFilter<"users"> | string
    username?: StringWithAggregatesFilter<"users"> | string
    email?: StringWithAggregatesFilter<"users"> | string
    password?: StringWithAggregatesFilter<"users"> | string
    no_hp?: StringNullableWithAggregatesFilter<"users"> | string | null
    foto?: StringNullableWithAggregatesFilter<"users"> | string | null
    bio?: StringNullableWithAggregatesFilter<"users"> | string | null
    role?: Enumusers_roleWithAggregatesFilter<"users"> | $Enums.users_role
    status?: Enumusers_statusWithAggregatesFilter<"users"> | $Enums.users_status
    created_at?: DateTimeWithAggregatesFilter<"users"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"users"> | Date | string
  }

  export type MitraWhereInput = {
    AND?: MitraWhereInput | MitraWhereInput[]
    OR?: MitraWhereInput[]
    NOT?: MitraWhereInput | MitraWhereInput[]
    id?: IntFilter<"Mitra"> | number
    userId?: IntFilter<"Mitra"> | number
    nama_usaha?: StringFilter<"Mitra"> | string
    alamat_usaha?: StringFilter<"Mitra"> | string
    no_ktp?: StringFilter<"Mitra"> | string
    foto_ktp?: StringFilter<"Mitra"> | string
    withdraw_type?: StringNullableFilter<"Mitra"> | string | null
    withdraw_day?: IntNullableFilter<"Mitra"> | number | null
    bank_mitra?: StringNullableFilter<"Mitra"> | string | null
    no_rekening_mitra?: StringNullableFilter<"Mitra"> | string | null
    status?: Enummitra_statusFilter<"Mitra"> | $Enums.mitra_status
    created_at?: DateTimeFilter<"Mitra"> | Date | string
    user?: XOR<UsersRelationFilter, usersWhereInput>
    lapangan?: LapanganListRelationFilter
    pendapatan?: Pendapatan_mitraListRelationFilter
    pencairan?: Pencairan_pendapatanListRelationFilter
  }

  export type MitraOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    nama_usaha?: SortOrder
    alamat_usaha?: SortOrder
    no_ktp?: SortOrder
    foto_ktp?: SortOrder
    withdraw_type?: SortOrderInput | SortOrder
    withdraw_day?: SortOrderInput | SortOrder
    bank_mitra?: SortOrderInput | SortOrder
    no_rekening_mitra?: SortOrderInput | SortOrder
    status?: SortOrder
    created_at?: SortOrder
    user?: usersOrderByWithRelationInput
    lapangan?: LapanganOrderByRelationAggregateInput
    pendapatan?: pendapatan_mitraOrderByRelationAggregateInput
    pencairan?: pencairan_pendapatanOrderByRelationAggregateInput
  }

  export type MitraWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    userId?: number
    AND?: MitraWhereInput | MitraWhereInput[]
    OR?: MitraWhereInput[]
    NOT?: MitraWhereInput | MitraWhereInput[]
    nama_usaha?: StringFilter<"Mitra"> | string
    alamat_usaha?: StringFilter<"Mitra"> | string
    no_ktp?: StringFilter<"Mitra"> | string
    foto_ktp?: StringFilter<"Mitra"> | string
    withdraw_type?: StringNullableFilter<"Mitra"> | string | null
    withdraw_day?: IntNullableFilter<"Mitra"> | number | null
    bank_mitra?: StringNullableFilter<"Mitra"> | string | null
    no_rekening_mitra?: StringNullableFilter<"Mitra"> | string | null
    status?: Enummitra_statusFilter<"Mitra"> | $Enums.mitra_status
    created_at?: DateTimeFilter<"Mitra"> | Date | string
    user?: XOR<UsersRelationFilter, usersWhereInput>
    lapangan?: LapanganListRelationFilter
    pendapatan?: Pendapatan_mitraListRelationFilter
    pencairan?: Pencairan_pendapatanListRelationFilter
  }, "id" | "userId">

  export type MitraOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    nama_usaha?: SortOrder
    alamat_usaha?: SortOrder
    no_ktp?: SortOrder
    foto_ktp?: SortOrder
    withdraw_type?: SortOrderInput | SortOrder
    withdraw_day?: SortOrderInput | SortOrder
    bank_mitra?: SortOrderInput | SortOrder
    no_rekening_mitra?: SortOrderInput | SortOrder
    status?: SortOrder
    created_at?: SortOrder
    _count?: MitraCountOrderByAggregateInput
    _avg?: MitraAvgOrderByAggregateInput
    _max?: MitraMaxOrderByAggregateInput
    _min?: MitraMinOrderByAggregateInput
    _sum?: MitraSumOrderByAggregateInput
  }

  export type MitraScalarWhereWithAggregatesInput = {
    AND?: MitraScalarWhereWithAggregatesInput | MitraScalarWhereWithAggregatesInput[]
    OR?: MitraScalarWhereWithAggregatesInput[]
    NOT?: MitraScalarWhereWithAggregatesInput | MitraScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Mitra"> | number
    userId?: IntWithAggregatesFilter<"Mitra"> | number
    nama_usaha?: StringWithAggregatesFilter<"Mitra"> | string
    alamat_usaha?: StringWithAggregatesFilter<"Mitra"> | string
    no_ktp?: StringWithAggregatesFilter<"Mitra"> | string
    foto_ktp?: StringWithAggregatesFilter<"Mitra"> | string
    withdraw_type?: StringNullableWithAggregatesFilter<"Mitra"> | string | null
    withdraw_day?: IntNullableWithAggregatesFilter<"Mitra"> | number | null
    bank_mitra?: StringNullableWithAggregatesFilter<"Mitra"> | string | null
    no_rekening_mitra?: StringNullableWithAggregatesFilter<"Mitra"> | string | null
    status?: Enummitra_statusWithAggregatesFilter<"Mitra"> | $Enums.mitra_status
    created_at?: DateTimeWithAggregatesFilter<"Mitra"> | Date | string
  }

  export type otp_codesWhereInput = {
    AND?: otp_codesWhereInput | otp_codesWhereInput[]
    OR?: otp_codesWhereInput[]
    NOT?: otp_codesWhereInput | otp_codesWhereInput[]
    id?: IntFilter<"otp_codes"> | number
    user_email?: StringFilter<"otp_codes"> | string
    kode_otp?: StringFilter<"otp_codes"> | string
    expired_at?: DateTimeFilter<"otp_codes"> | Date | string
    digunakan?: BoolFilter<"otp_codes"> | boolean
    created_at?: DateTimeFilter<"otp_codes"> | Date | string
  }

  export type otp_codesOrderByWithRelationInput = {
    id?: SortOrder
    user_email?: SortOrder
    kode_otp?: SortOrder
    expired_at?: SortOrder
    digunakan?: SortOrder
    created_at?: SortOrder
  }

  export type otp_codesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: otp_codesWhereInput | otp_codesWhereInput[]
    OR?: otp_codesWhereInput[]
    NOT?: otp_codesWhereInput | otp_codesWhereInput[]
    user_email?: StringFilter<"otp_codes"> | string
    kode_otp?: StringFilter<"otp_codes"> | string
    expired_at?: DateTimeFilter<"otp_codes"> | Date | string
    digunakan?: BoolFilter<"otp_codes"> | boolean
    created_at?: DateTimeFilter<"otp_codes"> | Date | string
  }, "id">

  export type otp_codesOrderByWithAggregationInput = {
    id?: SortOrder
    user_email?: SortOrder
    kode_otp?: SortOrder
    expired_at?: SortOrder
    digunakan?: SortOrder
    created_at?: SortOrder
    _count?: otp_codesCountOrderByAggregateInput
    _avg?: otp_codesAvgOrderByAggregateInput
    _max?: otp_codesMaxOrderByAggregateInput
    _min?: otp_codesMinOrderByAggregateInput
    _sum?: otp_codesSumOrderByAggregateInput
  }

  export type otp_codesScalarWhereWithAggregatesInput = {
    AND?: otp_codesScalarWhereWithAggregatesInput | otp_codesScalarWhereWithAggregatesInput[]
    OR?: otp_codesScalarWhereWithAggregatesInput[]
    NOT?: otp_codesScalarWhereWithAggregatesInput | otp_codesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"otp_codes"> | number
    user_email?: StringWithAggregatesFilter<"otp_codes"> | string
    kode_otp?: StringWithAggregatesFilter<"otp_codes"> | string
    expired_at?: DateTimeWithAggregatesFilter<"otp_codes"> | Date | string
    digunakan?: BoolWithAggregatesFilter<"otp_codes"> | boolean
    created_at?: DateTimeWithAggregatesFilter<"otp_codes"> | Date | string
  }

  export type LapanganWhereInput = {
    AND?: LapanganWhereInput | LapanganWhereInput[]
    OR?: LapanganWhereInput[]
    NOT?: LapanganWhereInput | LapanganWhereInput[]
    id?: IntFilter<"Lapangan"> | number
    mitra_id?: IntFilter<"Lapangan"> | number
    nama?: StringFilter<"Lapangan"> | string
    slug?: StringFilter<"Lapangan"> | string
    lokasi?: StringNullableFilter<"Lapangan"> | string | null
    harga?: DecimalFilter<"Lapangan"> | Decimal | DecimalJsLike | number | string
    gambar?: StringNullableFilter<"Lapangan"> | string | null
    rating?: FloatNullableFilter<"Lapangan"> | number | null
    status?: Enumlapangan_statusFilter<"Lapangan"> | $Enums.lapangan_status
    created_at?: DateTimeFilter<"Lapangan"> | Date | string
    mitra?: XOR<MitraRelationFilter, MitraWhereInput>
    detail?: XOR<LapanganDetailNullableRelationFilter, LapanganDetailWhereInput> | null
    gambarList?: LapanganGambarListRelationFilter
    jadwal?: JadwalLapanganListRelationFilter
    orders?: Order_bookingListRelationFilter
    transaksi?: TransaksiListRelationFilter
    ulasan?: UlasanListRelationFilter
  }

  export type LapanganOrderByWithRelationInput = {
    id?: SortOrder
    mitra_id?: SortOrder
    nama?: SortOrder
    slug?: SortOrder
    lokasi?: SortOrderInput | SortOrder
    harga?: SortOrder
    gambar?: SortOrderInput | SortOrder
    rating?: SortOrderInput | SortOrder
    status?: SortOrder
    created_at?: SortOrder
    mitra?: MitraOrderByWithRelationInput
    detail?: LapanganDetailOrderByWithRelationInput
    gambarList?: LapanganGambarOrderByRelationAggregateInput
    jadwal?: JadwalLapanganOrderByRelationAggregateInput
    orders?: order_bookingOrderByRelationAggregateInput
    transaksi?: transaksiOrderByRelationAggregateInput
    ulasan?: ulasanOrderByRelationAggregateInput
  }

  export type LapanganWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    slug?: string
    AND?: LapanganWhereInput | LapanganWhereInput[]
    OR?: LapanganWhereInput[]
    NOT?: LapanganWhereInput | LapanganWhereInput[]
    mitra_id?: IntFilter<"Lapangan"> | number
    nama?: StringFilter<"Lapangan"> | string
    lokasi?: StringNullableFilter<"Lapangan"> | string | null
    harga?: DecimalFilter<"Lapangan"> | Decimal | DecimalJsLike | number | string
    gambar?: StringNullableFilter<"Lapangan"> | string | null
    rating?: FloatNullableFilter<"Lapangan"> | number | null
    status?: Enumlapangan_statusFilter<"Lapangan"> | $Enums.lapangan_status
    created_at?: DateTimeFilter<"Lapangan"> | Date | string
    mitra?: XOR<MitraRelationFilter, MitraWhereInput>
    detail?: XOR<LapanganDetailNullableRelationFilter, LapanganDetailWhereInput> | null
    gambarList?: LapanganGambarListRelationFilter
    jadwal?: JadwalLapanganListRelationFilter
    orders?: Order_bookingListRelationFilter
    transaksi?: TransaksiListRelationFilter
    ulasan?: UlasanListRelationFilter
  }, "id" | "slug">

  export type LapanganOrderByWithAggregationInput = {
    id?: SortOrder
    mitra_id?: SortOrder
    nama?: SortOrder
    slug?: SortOrder
    lokasi?: SortOrderInput | SortOrder
    harga?: SortOrder
    gambar?: SortOrderInput | SortOrder
    rating?: SortOrderInput | SortOrder
    status?: SortOrder
    created_at?: SortOrder
    _count?: LapanganCountOrderByAggregateInput
    _avg?: LapanganAvgOrderByAggregateInput
    _max?: LapanganMaxOrderByAggregateInput
    _min?: LapanganMinOrderByAggregateInput
    _sum?: LapanganSumOrderByAggregateInput
  }

  export type LapanganScalarWhereWithAggregatesInput = {
    AND?: LapanganScalarWhereWithAggregatesInput | LapanganScalarWhereWithAggregatesInput[]
    OR?: LapanganScalarWhereWithAggregatesInput[]
    NOT?: LapanganScalarWhereWithAggregatesInput | LapanganScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Lapangan"> | number
    mitra_id?: IntWithAggregatesFilter<"Lapangan"> | number
    nama?: StringWithAggregatesFilter<"Lapangan"> | string
    slug?: StringWithAggregatesFilter<"Lapangan"> | string
    lokasi?: StringNullableWithAggregatesFilter<"Lapangan"> | string | null
    harga?: DecimalWithAggregatesFilter<"Lapangan"> | Decimal | DecimalJsLike | number | string
    gambar?: StringNullableWithAggregatesFilter<"Lapangan"> | string | null
    rating?: FloatNullableWithAggregatesFilter<"Lapangan"> | number | null
    status?: Enumlapangan_statusWithAggregatesFilter<"Lapangan"> | $Enums.lapangan_status
    created_at?: DateTimeWithAggregatesFilter<"Lapangan"> | Date | string
  }

  export type LapanganDetailWhereInput = {
    AND?: LapanganDetailWhereInput | LapanganDetailWhereInput[]
    OR?: LapanganDetailWhereInput[]
    NOT?: LapanganDetailWhereInput | LapanganDetailWhereInput[]
    id?: IntFilter<"LapanganDetail"> | number
    lapangan_id?: IntFilter<"LapanganDetail"> | number
    alamat?: StringFilter<"LapanganDetail"> | string
    maps?: StringFilter<"LapanganDetail"> | string
    deskripsi?: StringFilter<"LapanganDetail"> | string
    type?: StringFilter<"LapanganDetail"> | string
    fasilitas?: JsonFilter<"LapanganDetail">
    interval?: IntFilter<"LapanganDetail"> | number
    breakTime?: IntFilter<"LapanganDetail"> | number
    lapangan?: XOR<LapanganRelationFilter, LapanganWhereInput>
  }

  export type LapanganDetailOrderByWithRelationInput = {
    id?: SortOrder
    lapangan_id?: SortOrder
    alamat?: SortOrder
    maps?: SortOrder
    deskripsi?: SortOrder
    type?: SortOrder
    fasilitas?: SortOrder
    interval?: SortOrder
    breakTime?: SortOrder
    lapangan?: LapanganOrderByWithRelationInput
  }

  export type LapanganDetailWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    lapangan_id?: number
    AND?: LapanganDetailWhereInput | LapanganDetailWhereInput[]
    OR?: LapanganDetailWhereInput[]
    NOT?: LapanganDetailWhereInput | LapanganDetailWhereInput[]
    alamat?: StringFilter<"LapanganDetail"> | string
    maps?: StringFilter<"LapanganDetail"> | string
    deskripsi?: StringFilter<"LapanganDetail"> | string
    type?: StringFilter<"LapanganDetail"> | string
    fasilitas?: JsonFilter<"LapanganDetail">
    interval?: IntFilter<"LapanganDetail"> | number
    breakTime?: IntFilter<"LapanganDetail"> | number
    lapangan?: XOR<LapanganRelationFilter, LapanganWhereInput>
  }, "id" | "lapangan_id">

  export type LapanganDetailOrderByWithAggregationInput = {
    id?: SortOrder
    lapangan_id?: SortOrder
    alamat?: SortOrder
    maps?: SortOrder
    deskripsi?: SortOrder
    type?: SortOrder
    fasilitas?: SortOrder
    interval?: SortOrder
    breakTime?: SortOrder
    _count?: LapanganDetailCountOrderByAggregateInput
    _avg?: LapanganDetailAvgOrderByAggregateInput
    _max?: LapanganDetailMaxOrderByAggregateInput
    _min?: LapanganDetailMinOrderByAggregateInput
    _sum?: LapanganDetailSumOrderByAggregateInput
  }

  export type LapanganDetailScalarWhereWithAggregatesInput = {
    AND?: LapanganDetailScalarWhereWithAggregatesInput | LapanganDetailScalarWhereWithAggregatesInput[]
    OR?: LapanganDetailScalarWhereWithAggregatesInput[]
    NOT?: LapanganDetailScalarWhereWithAggregatesInput | LapanganDetailScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"LapanganDetail"> | number
    lapangan_id?: IntWithAggregatesFilter<"LapanganDetail"> | number
    alamat?: StringWithAggregatesFilter<"LapanganDetail"> | string
    maps?: StringWithAggregatesFilter<"LapanganDetail"> | string
    deskripsi?: StringWithAggregatesFilter<"LapanganDetail"> | string
    type?: StringWithAggregatesFilter<"LapanganDetail"> | string
    fasilitas?: JsonWithAggregatesFilter<"LapanganDetail">
    interval?: IntWithAggregatesFilter<"LapanganDetail"> | number
    breakTime?: IntWithAggregatesFilter<"LapanganDetail"> | number
  }

  export type LapanganGambarWhereInput = {
    AND?: LapanganGambarWhereInput | LapanganGambarWhereInput[]
    OR?: LapanganGambarWhereInput[]
    NOT?: LapanganGambarWhereInput | LapanganGambarWhereInput[]
    id?: IntFilter<"LapanganGambar"> | number
    lapangan_id?: IntFilter<"LapanganGambar"> | number
    file_name?: StringFilter<"LapanganGambar"> | string
    created_at?: DateTimeFilter<"LapanganGambar"> | Date | string
    lapangan?: XOR<LapanganRelationFilter, LapanganWhereInput>
  }

  export type LapanganGambarOrderByWithRelationInput = {
    id?: SortOrder
    lapangan_id?: SortOrder
    file_name?: SortOrder
    created_at?: SortOrder
    lapangan?: LapanganOrderByWithRelationInput
  }

  export type LapanganGambarWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: LapanganGambarWhereInput | LapanganGambarWhereInput[]
    OR?: LapanganGambarWhereInput[]
    NOT?: LapanganGambarWhereInput | LapanganGambarWhereInput[]
    lapangan_id?: IntFilter<"LapanganGambar"> | number
    file_name?: StringFilter<"LapanganGambar"> | string
    created_at?: DateTimeFilter<"LapanganGambar"> | Date | string
    lapangan?: XOR<LapanganRelationFilter, LapanganWhereInput>
  }, "id">

  export type LapanganGambarOrderByWithAggregationInput = {
    id?: SortOrder
    lapangan_id?: SortOrder
    file_name?: SortOrder
    created_at?: SortOrder
    _count?: LapanganGambarCountOrderByAggregateInput
    _avg?: LapanganGambarAvgOrderByAggregateInput
    _max?: LapanganGambarMaxOrderByAggregateInput
    _min?: LapanganGambarMinOrderByAggregateInput
    _sum?: LapanganGambarSumOrderByAggregateInput
  }

  export type LapanganGambarScalarWhereWithAggregatesInput = {
    AND?: LapanganGambarScalarWhereWithAggregatesInput | LapanganGambarScalarWhereWithAggregatesInput[]
    OR?: LapanganGambarScalarWhereWithAggregatesInput[]
    NOT?: LapanganGambarScalarWhereWithAggregatesInput | LapanganGambarScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"LapanganGambar"> | number
    lapangan_id?: IntWithAggregatesFilter<"LapanganGambar"> | number
    file_name?: StringWithAggregatesFilter<"LapanganGambar"> | string
    created_at?: DateTimeWithAggregatesFilter<"LapanganGambar"> | Date | string
  }

  export type JadwalLapanganWhereInput = {
    AND?: JadwalLapanganWhereInput | JadwalLapanganWhereInput[]
    OR?: JadwalLapanganWhereInput[]
    NOT?: JadwalLapanganWhereInput | JadwalLapanganWhereInput[]
    id?: IntFilter<"JadwalLapangan"> | number
    lapangan_id?: IntFilter<"JadwalLapangan"> | number
    tanggal?: DateTimeFilter<"JadwalLapangan"> | Date | string
    slot?: StringFilter<"JadwalLapangan"> | string
    status?: Enumjadwal_statusFilter<"JadwalLapangan"> | $Enums.jadwal_status
    locked_until?: DateTimeNullableFilter<"JadwalLapangan"> | Date | string | null
    lapangan?: XOR<LapanganRelationFilter, LapanganWhereInput>
    orders?: Order_bookingListRelationFilter
    transaksi?: TransaksiListRelationFilter
  }

  export type JadwalLapanganOrderByWithRelationInput = {
    id?: SortOrder
    lapangan_id?: SortOrder
    tanggal?: SortOrder
    slot?: SortOrder
    status?: SortOrder
    locked_until?: SortOrderInput | SortOrder
    lapangan?: LapanganOrderByWithRelationInput
    orders?: order_bookingOrderByRelationAggregateInput
    transaksi?: transaksiOrderByRelationAggregateInput
  }

  export type JadwalLapanganWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    lapangan_id_tanggal_slot?: JadwalLapanganLapangan_idTanggalSlotCompoundUniqueInput
    AND?: JadwalLapanganWhereInput | JadwalLapanganWhereInput[]
    OR?: JadwalLapanganWhereInput[]
    NOT?: JadwalLapanganWhereInput | JadwalLapanganWhereInput[]
    lapangan_id?: IntFilter<"JadwalLapangan"> | number
    tanggal?: DateTimeFilter<"JadwalLapangan"> | Date | string
    slot?: StringFilter<"JadwalLapangan"> | string
    status?: Enumjadwal_statusFilter<"JadwalLapangan"> | $Enums.jadwal_status
    locked_until?: DateTimeNullableFilter<"JadwalLapangan"> | Date | string | null
    lapangan?: XOR<LapanganRelationFilter, LapanganWhereInput>
    orders?: Order_bookingListRelationFilter
    transaksi?: TransaksiListRelationFilter
  }, "id" | "lapangan_id_tanggal_slot">

  export type JadwalLapanganOrderByWithAggregationInput = {
    id?: SortOrder
    lapangan_id?: SortOrder
    tanggal?: SortOrder
    slot?: SortOrder
    status?: SortOrder
    locked_until?: SortOrderInput | SortOrder
    _count?: JadwalLapanganCountOrderByAggregateInput
    _avg?: JadwalLapanganAvgOrderByAggregateInput
    _max?: JadwalLapanganMaxOrderByAggregateInput
    _min?: JadwalLapanganMinOrderByAggregateInput
    _sum?: JadwalLapanganSumOrderByAggregateInput
  }

  export type JadwalLapanganScalarWhereWithAggregatesInput = {
    AND?: JadwalLapanganScalarWhereWithAggregatesInput | JadwalLapanganScalarWhereWithAggregatesInput[]
    OR?: JadwalLapanganScalarWhereWithAggregatesInput[]
    NOT?: JadwalLapanganScalarWhereWithAggregatesInput | JadwalLapanganScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"JadwalLapangan"> | number
    lapangan_id?: IntWithAggregatesFilter<"JadwalLapangan"> | number
    tanggal?: DateTimeWithAggregatesFilter<"JadwalLapangan"> | Date | string
    slot?: StringWithAggregatesFilter<"JadwalLapangan"> | string
    status?: Enumjadwal_statusWithAggregatesFilter<"JadwalLapangan"> | $Enums.jadwal_status
    locked_until?: DateTimeNullableWithAggregatesFilter<"JadwalLapangan"> | Date | string | null
  }

  export type order_bookingWhereInput = {
    AND?: order_bookingWhereInput | order_bookingWhereInput[]
    OR?: order_bookingWhereInput[]
    NOT?: order_bookingWhereInput | order_bookingWhereInput[]
    id?: IntFilter<"order_booking"> | number
    user_id?: IntFilter<"order_booking"> | number
    lapangan_id?: IntFilter<"order_booking"> | number
    jadwalLapanganId?: IntFilter<"order_booking"> | number
    tanggal?: DateTimeFilter<"order_booking"> | Date | string
    jam_mulai?: StringFilter<"order_booking"> | string
    jam_selesai?: StringFilter<"order_booking"> | string
    total_harga?: DecimalFilter<"order_booking"> | Decimal | DecimalJsLike | number | string
    status?: StringFilter<"order_booking"> | string
    sewa_raket?: BoolFilter<"order_booking"> | boolean
    biaya_raket?: IntFilter<"order_booking"> | number
    created_at?: DateTimeFilter<"order_booking"> | Date | string
    expired_at?: DateTimeNullableFilter<"order_booking"> | Date | string | null
    user?: XOR<UsersRelationFilter, usersWhereInput>
    lapangan?: XOR<LapanganRelationFilter, LapanganWhereInput>
    jadwalLapangan?: XOR<JadwalLapanganRelationFilter, JadwalLapanganWhereInput>
    transaksi?: XOR<TransaksiNullableRelationFilter, transaksiWhereInput> | null
    refund?: XOR<RefundNullableRelationFilter, refundWhereInput> | null
    wallet_histories?: Wallet_historyListRelationFilter
  }

  export type order_bookingOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    lapangan_id?: SortOrder
    jadwalLapanganId?: SortOrder
    tanggal?: SortOrder
    jam_mulai?: SortOrder
    jam_selesai?: SortOrder
    total_harga?: SortOrder
    status?: SortOrder
    sewa_raket?: SortOrder
    biaya_raket?: SortOrder
    created_at?: SortOrder
    expired_at?: SortOrderInput | SortOrder
    user?: usersOrderByWithRelationInput
    lapangan?: LapanganOrderByWithRelationInput
    jadwalLapangan?: JadwalLapanganOrderByWithRelationInput
    transaksi?: transaksiOrderByWithRelationInput
    refund?: refundOrderByWithRelationInput
    wallet_histories?: wallet_historyOrderByRelationAggregateInput
  }

  export type order_bookingWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: order_bookingWhereInput | order_bookingWhereInput[]
    OR?: order_bookingWhereInput[]
    NOT?: order_bookingWhereInput | order_bookingWhereInput[]
    user_id?: IntFilter<"order_booking"> | number
    lapangan_id?: IntFilter<"order_booking"> | number
    jadwalLapanganId?: IntFilter<"order_booking"> | number
    tanggal?: DateTimeFilter<"order_booking"> | Date | string
    jam_mulai?: StringFilter<"order_booking"> | string
    jam_selesai?: StringFilter<"order_booking"> | string
    total_harga?: DecimalFilter<"order_booking"> | Decimal | DecimalJsLike | number | string
    status?: StringFilter<"order_booking"> | string
    sewa_raket?: BoolFilter<"order_booking"> | boolean
    biaya_raket?: IntFilter<"order_booking"> | number
    created_at?: DateTimeFilter<"order_booking"> | Date | string
    expired_at?: DateTimeNullableFilter<"order_booking"> | Date | string | null
    user?: XOR<UsersRelationFilter, usersWhereInput>
    lapangan?: XOR<LapanganRelationFilter, LapanganWhereInput>
    jadwalLapangan?: XOR<JadwalLapanganRelationFilter, JadwalLapanganWhereInput>
    transaksi?: XOR<TransaksiNullableRelationFilter, transaksiWhereInput> | null
    refund?: XOR<RefundNullableRelationFilter, refundWhereInput> | null
    wallet_histories?: Wallet_historyListRelationFilter
  }, "id">

  export type order_bookingOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    lapangan_id?: SortOrder
    jadwalLapanganId?: SortOrder
    tanggal?: SortOrder
    jam_mulai?: SortOrder
    jam_selesai?: SortOrder
    total_harga?: SortOrder
    status?: SortOrder
    sewa_raket?: SortOrder
    biaya_raket?: SortOrder
    created_at?: SortOrder
    expired_at?: SortOrderInput | SortOrder
    _count?: order_bookingCountOrderByAggregateInput
    _avg?: order_bookingAvgOrderByAggregateInput
    _max?: order_bookingMaxOrderByAggregateInput
    _min?: order_bookingMinOrderByAggregateInput
    _sum?: order_bookingSumOrderByAggregateInput
  }

  export type order_bookingScalarWhereWithAggregatesInput = {
    AND?: order_bookingScalarWhereWithAggregatesInput | order_bookingScalarWhereWithAggregatesInput[]
    OR?: order_bookingScalarWhereWithAggregatesInput[]
    NOT?: order_bookingScalarWhereWithAggregatesInput | order_bookingScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"order_booking"> | number
    user_id?: IntWithAggregatesFilter<"order_booking"> | number
    lapangan_id?: IntWithAggregatesFilter<"order_booking"> | number
    jadwalLapanganId?: IntWithAggregatesFilter<"order_booking"> | number
    tanggal?: DateTimeWithAggregatesFilter<"order_booking"> | Date | string
    jam_mulai?: StringWithAggregatesFilter<"order_booking"> | string
    jam_selesai?: StringWithAggregatesFilter<"order_booking"> | string
    total_harga?: DecimalWithAggregatesFilter<"order_booking"> | Decimal | DecimalJsLike | number | string
    status?: StringWithAggregatesFilter<"order_booking"> | string
    sewa_raket?: BoolWithAggregatesFilter<"order_booking"> | boolean
    biaya_raket?: IntWithAggregatesFilter<"order_booking"> | number
    created_at?: DateTimeWithAggregatesFilter<"order_booking"> | Date | string
    expired_at?: DateTimeNullableWithAggregatesFilter<"order_booking"> | Date | string | null
  }

  export type transaksiWhereInput = {
    AND?: transaksiWhereInput | transaksiWhereInput[]
    OR?: transaksiWhereInput[]
    NOT?: transaksiWhereInput | transaksiWhereInput[]
    id?: IntFilter<"transaksi"> | number
    user_id?: IntFilter<"transaksi"> | number
    lapangan_id?: IntFilter<"transaksi"> | number
    jadwal_id?: IntFilter<"transaksi"> | number
    order_id?: IntNullableFilter<"transaksi"> | number | null
    total_harga?: DecimalFilter<"transaksi"> | Decimal | DecimalJsLike | number | string
    status_pembayaran?: Enumtransaksi_status_pembayaranFilter<"transaksi"> | $Enums.transaksi_status_pembayaran
    created_at?: DateTimeFilter<"transaksi"> | Date | string
    user?: XOR<UsersRelationFilter, usersWhereInput>
    lapangan?: XOR<LapanganRelationFilter, LapanganWhereInput>
    jadwal?: XOR<JadwalLapanganRelationFilter, JadwalLapanganWhereInput>
    order?: XOR<Order_bookingNullableRelationFilter, order_bookingWhereInput> | null
    refund?: XOR<RefundNullableRelationFilter, refundWhereInput> | null
    sewa_raket?: Sewa_raketListRelationFilter
  }

  export type transaksiOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    lapangan_id?: SortOrder
    jadwal_id?: SortOrder
    order_id?: SortOrderInput | SortOrder
    total_harga?: SortOrder
    status_pembayaran?: SortOrder
    created_at?: SortOrder
    user?: usersOrderByWithRelationInput
    lapangan?: LapanganOrderByWithRelationInput
    jadwal?: JadwalLapanganOrderByWithRelationInput
    order?: order_bookingOrderByWithRelationInput
    refund?: refundOrderByWithRelationInput
    sewa_raket?: sewa_raketOrderByRelationAggregateInput
  }

  export type transaksiWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    order_id?: number
    AND?: transaksiWhereInput | transaksiWhereInput[]
    OR?: transaksiWhereInput[]
    NOT?: transaksiWhereInput | transaksiWhereInput[]
    user_id?: IntFilter<"transaksi"> | number
    lapangan_id?: IntFilter<"transaksi"> | number
    jadwal_id?: IntFilter<"transaksi"> | number
    total_harga?: DecimalFilter<"transaksi"> | Decimal | DecimalJsLike | number | string
    status_pembayaran?: Enumtransaksi_status_pembayaranFilter<"transaksi"> | $Enums.transaksi_status_pembayaran
    created_at?: DateTimeFilter<"transaksi"> | Date | string
    user?: XOR<UsersRelationFilter, usersWhereInput>
    lapangan?: XOR<LapanganRelationFilter, LapanganWhereInput>
    jadwal?: XOR<JadwalLapanganRelationFilter, JadwalLapanganWhereInput>
    order?: XOR<Order_bookingNullableRelationFilter, order_bookingWhereInput> | null
    refund?: XOR<RefundNullableRelationFilter, refundWhereInput> | null
    sewa_raket?: Sewa_raketListRelationFilter
  }, "id" | "order_id">

  export type transaksiOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    lapangan_id?: SortOrder
    jadwal_id?: SortOrder
    order_id?: SortOrderInput | SortOrder
    total_harga?: SortOrder
    status_pembayaran?: SortOrder
    created_at?: SortOrder
    _count?: transaksiCountOrderByAggregateInput
    _avg?: transaksiAvgOrderByAggregateInput
    _max?: transaksiMaxOrderByAggregateInput
    _min?: transaksiMinOrderByAggregateInput
    _sum?: transaksiSumOrderByAggregateInput
  }

  export type transaksiScalarWhereWithAggregatesInput = {
    AND?: transaksiScalarWhereWithAggregatesInput | transaksiScalarWhereWithAggregatesInput[]
    OR?: transaksiScalarWhereWithAggregatesInput[]
    NOT?: transaksiScalarWhereWithAggregatesInput | transaksiScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"transaksi"> | number
    user_id?: IntWithAggregatesFilter<"transaksi"> | number
    lapangan_id?: IntWithAggregatesFilter<"transaksi"> | number
    jadwal_id?: IntWithAggregatesFilter<"transaksi"> | number
    order_id?: IntNullableWithAggregatesFilter<"transaksi"> | number | null
    total_harga?: DecimalWithAggregatesFilter<"transaksi"> | Decimal | DecimalJsLike | number | string
    status_pembayaran?: Enumtransaksi_status_pembayaranWithAggregatesFilter<"transaksi"> | $Enums.transaksi_status_pembayaran
    created_at?: DateTimeWithAggregatesFilter<"transaksi"> | Date | string
  }

  export type raket_padelWhereInput = {
    AND?: raket_padelWhereInput | raket_padelWhereInput[]
    OR?: raket_padelWhereInput[]
    NOT?: raket_padelWhereInput | raket_padelWhereInput[]
    id?: IntFilter<"raket_padel"> | number
    nama?: StringFilter<"raket_padel"> | string
    harga?: DecimalFilter<"raket_padel"> | Decimal | DecimalJsLike | number | string
    sewa_raket?: Sewa_raketListRelationFilter
  }

  export type raket_padelOrderByWithRelationInput = {
    id?: SortOrder
    nama?: SortOrder
    harga?: SortOrder
    sewa_raket?: sewa_raketOrderByRelationAggregateInput
  }

  export type raket_padelWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: raket_padelWhereInput | raket_padelWhereInput[]
    OR?: raket_padelWhereInput[]
    NOT?: raket_padelWhereInput | raket_padelWhereInput[]
    nama?: StringFilter<"raket_padel"> | string
    harga?: DecimalFilter<"raket_padel"> | Decimal | DecimalJsLike | number | string
    sewa_raket?: Sewa_raketListRelationFilter
  }, "id">

  export type raket_padelOrderByWithAggregationInput = {
    id?: SortOrder
    nama?: SortOrder
    harga?: SortOrder
    _count?: raket_padelCountOrderByAggregateInput
    _avg?: raket_padelAvgOrderByAggregateInput
    _max?: raket_padelMaxOrderByAggregateInput
    _min?: raket_padelMinOrderByAggregateInput
    _sum?: raket_padelSumOrderByAggregateInput
  }

  export type raket_padelScalarWhereWithAggregatesInput = {
    AND?: raket_padelScalarWhereWithAggregatesInput | raket_padelScalarWhereWithAggregatesInput[]
    OR?: raket_padelScalarWhereWithAggregatesInput[]
    NOT?: raket_padelScalarWhereWithAggregatesInput | raket_padelScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"raket_padel"> | number
    nama?: StringWithAggregatesFilter<"raket_padel"> | string
    harga?: DecimalWithAggregatesFilter<"raket_padel"> | Decimal | DecimalJsLike | number | string
  }

  export type sewa_raketWhereInput = {
    AND?: sewa_raketWhereInput | sewa_raketWhereInput[]
    OR?: sewa_raketWhereInput[]
    NOT?: sewa_raketWhereInput | sewa_raketWhereInput[]
    id?: IntFilter<"sewa_raket"> | number
    transaksi_id?: IntFilter<"sewa_raket"> | number
    raket_id?: IntFilter<"sewa_raket"> | number
    jumlah?: IntFilter<"sewa_raket"> | number
    total_harga?: DecimalFilter<"sewa_raket"> | Decimal | DecimalJsLike | number | string
    transaksi?: XOR<TransaksiRelationFilter, transaksiWhereInput>
    raket?: XOR<Raket_padelRelationFilter, raket_padelWhereInput>
  }

  export type sewa_raketOrderByWithRelationInput = {
    id?: SortOrder
    transaksi_id?: SortOrder
    raket_id?: SortOrder
    jumlah?: SortOrder
    total_harga?: SortOrder
    transaksi?: transaksiOrderByWithRelationInput
    raket?: raket_padelOrderByWithRelationInput
  }

  export type sewa_raketWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: sewa_raketWhereInput | sewa_raketWhereInput[]
    OR?: sewa_raketWhereInput[]
    NOT?: sewa_raketWhereInput | sewa_raketWhereInput[]
    transaksi_id?: IntFilter<"sewa_raket"> | number
    raket_id?: IntFilter<"sewa_raket"> | number
    jumlah?: IntFilter<"sewa_raket"> | number
    total_harga?: DecimalFilter<"sewa_raket"> | Decimal | DecimalJsLike | number | string
    transaksi?: XOR<TransaksiRelationFilter, transaksiWhereInput>
    raket?: XOR<Raket_padelRelationFilter, raket_padelWhereInput>
  }, "id">

  export type sewa_raketOrderByWithAggregationInput = {
    id?: SortOrder
    transaksi_id?: SortOrder
    raket_id?: SortOrder
    jumlah?: SortOrder
    total_harga?: SortOrder
    _count?: sewa_raketCountOrderByAggregateInput
    _avg?: sewa_raketAvgOrderByAggregateInput
    _max?: sewa_raketMaxOrderByAggregateInput
    _min?: sewa_raketMinOrderByAggregateInput
    _sum?: sewa_raketSumOrderByAggregateInput
  }

  export type sewa_raketScalarWhereWithAggregatesInput = {
    AND?: sewa_raketScalarWhereWithAggregatesInput | sewa_raketScalarWhereWithAggregatesInput[]
    OR?: sewa_raketScalarWhereWithAggregatesInput[]
    NOT?: sewa_raketScalarWhereWithAggregatesInput | sewa_raketScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"sewa_raket"> | number
    transaksi_id?: IntWithAggregatesFilter<"sewa_raket"> | number
    raket_id?: IntWithAggregatesFilter<"sewa_raket"> | number
    jumlah?: IntWithAggregatesFilter<"sewa_raket"> | number
    total_harga?: DecimalWithAggregatesFilter<"sewa_raket"> | Decimal | DecimalJsLike | number | string
  }

  export type wallet_userWhereInput = {
    AND?: wallet_userWhereInput | wallet_userWhereInput[]
    OR?: wallet_userWhereInput[]
    NOT?: wallet_userWhereInput | wallet_userWhereInput[]
    id?: IntFilter<"wallet_user"> | number
    user_id?: IntFilter<"wallet_user"> | number
    saldo?: IntFilter<"wallet_user"> | number
    updated_at?: DateTimeFilter<"wallet_user"> | Date | string
    user?: XOR<UsersRelationFilter, usersWhereInput>
    history?: Wallet_historyListRelationFilter
  }

  export type wallet_userOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    saldo?: SortOrder
    updated_at?: SortOrder
    user?: usersOrderByWithRelationInput
    history?: wallet_historyOrderByRelationAggregateInput
  }

  export type wallet_userWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    user_id?: number
    AND?: wallet_userWhereInput | wallet_userWhereInput[]
    OR?: wallet_userWhereInput[]
    NOT?: wallet_userWhereInput | wallet_userWhereInput[]
    saldo?: IntFilter<"wallet_user"> | number
    updated_at?: DateTimeFilter<"wallet_user"> | Date | string
    user?: XOR<UsersRelationFilter, usersWhereInput>
    history?: Wallet_historyListRelationFilter
  }, "id" | "user_id">

  export type wallet_userOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    saldo?: SortOrder
    updated_at?: SortOrder
    _count?: wallet_userCountOrderByAggregateInput
    _avg?: wallet_userAvgOrderByAggregateInput
    _max?: wallet_userMaxOrderByAggregateInput
    _min?: wallet_userMinOrderByAggregateInput
    _sum?: wallet_userSumOrderByAggregateInput
  }

  export type wallet_userScalarWhereWithAggregatesInput = {
    AND?: wallet_userScalarWhereWithAggregatesInput | wallet_userScalarWhereWithAggregatesInput[]
    OR?: wallet_userScalarWhereWithAggregatesInput[]
    NOT?: wallet_userScalarWhereWithAggregatesInput | wallet_userScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"wallet_user"> | number
    user_id?: IntWithAggregatesFilter<"wallet_user"> | number
    saldo?: IntWithAggregatesFilter<"wallet_user"> | number
    updated_at?: DateTimeWithAggregatesFilter<"wallet_user"> | Date | string
  }

  export type wallet_historyWhereInput = {
    AND?: wallet_historyWhereInput | wallet_historyWhereInput[]
    OR?: wallet_historyWhereInput[]
    NOT?: wallet_historyWhereInput | wallet_historyWhereInput[]
    id?: IntFilter<"wallet_history"> | number
    wallet_id?: IntFilter<"wallet_history"> | number
    jumlah?: IntFilter<"wallet_history"> | number
    saldo_akhir?: IntFilter<"wallet_history"> | number
    tipe?: Enumwallet_tipeFilter<"wallet_history"> | $Enums.wallet_tipe
    transaksi_id?: IntNullableFilter<"wallet_history"> | number | null
    order_id?: IntNullableFilter<"wallet_history"> | number | null
    created_at?: DateTimeFilter<"wallet_history"> | Date | string
    wallet?: XOR<Wallet_userRelationFilter, wallet_userWhereInput>
    order?: XOR<Order_bookingNullableRelationFilter, order_bookingWhereInput> | null
  }

  export type wallet_historyOrderByWithRelationInput = {
    id?: SortOrder
    wallet_id?: SortOrder
    jumlah?: SortOrder
    saldo_akhir?: SortOrder
    tipe?: SortOrder
    transaksi_id?: SortOrderInput | SortOrder
    order_id?: SortOrderInput | SortOrder
    created_at?: SortOrder
    wallet?: wallet_userOrderByWithRelationInput
    order?: order_bookingOrderByWithRelationInput
  }

  export type wallet_historyWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: wallet_historyWhereInput | wallet_historyWhereInput[]
    OR?: wallet_historyWhereInput[]
    NOT?: wallet_historyWhereInput | wallet_historyWhereInput[]
    wallet_id?: IntFilter<"wallet_history"> | number
    jumlah?: IntFilter<"wallet_history"> | number
    saldo_akhir?: IntFilter<"wallet_history"> | number
    tipe?: Enumwallet_tipeFilter<"wallet_history"> | $Enums.wallet_tipe
    transaksi_id?: IntNullableFilter<"wallet_history"> | number | null
    order_id?: IntNullableFilter<"wallet_history"> | number | null
    created_at?: DateTimeFilter<"wallet_history"> | Date | string
    wallet?: XOR<Wallet_userRelationFilter, wallet_userWhereInput>
    order?: XOR<Order_bookingNullableRelationFilter, order_bookingWhereInput> | null
  }, "id">

  export type wallet_historyOrderByWithAggregationInput = {
    id?: SortOrder
    wallet_id?: SortOrder
    jumlah?: SortOrder
    saldo_akhir?: SortOrder
    tipe?: SortOrder
    transaksi_id?: SortOrderInput | SortOrder
    order_id?: SortOrderInput | SortOrder
    created_at?: SortOrder
    _count?: wallet_historyCountOrderByAggregateInput
    _avg?: wallet_historyAvgOrderByAggregateInput
    _max?: wallet_historyMaxOrderByAggregateInput
    _min?: wallet_historyMinOrderByAggregateInput
    _sum?: wallet_historySumOrderByAggregateInput
  }

  export type wallet_historyScalarWhereWithAggregatesInput = {
    AND?: wallet_historyScalarWhereWithAggregatesInput | wallet_historyScalarWhereWithAggregatesInput[]
    OR?: wallet_historyScalarWhereWithAggregatesInput[]
    NOT?: wallet_historyScalarWhereWithAggregatesInput | wallet_historyScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"wallet_history"> | number
    wallet_id?: IntWithAggregatesFilter<"wallet_history"> | number
    jumlah?: IntWithAggregatesFilter<"wallet_history"> | number
    saldo_akhir?: IntWithAggregatesFilter<"wallet_history"> | number
    tipe?: Enumwallet_tipeWithAggregatesFilter<"wallet_history"> | $Enums.wallet_tipe
    transaksi_id?: IntNullableWithAggregatesFilter<"wallet_history"> | number | null
    order_id?: IntNullableWithAggregatesFilter<"wallet_history"> | number | null
    created_at?: DateTimeWithAggregatesFilter<"wallet_history"> | Date | string
  }

  export type refundWhereInput = {
    AND?: refundWhereInput | refundWhereInput[]
    OR?: refundWhereInput[]
    NOT?: refundWhereInput | refundWhereInput[]
    id?: IntFilter<"refund"> | number
    user_id?: IntFilter<"refund"> | number
    transaksi_id?: IntFilter<"refund"> | number
    order_id?: IntFilter<"refund"> | number
    jumlah?: DecimalFilter<"refund"> | Decimal | DecimalJsLike | number | string
    alasan?: StringNullableFilter<"refund"> | string | null
    status?: Enumrefund_statusFilter<"refund"> | $Enums.refund_status
    created_at?: DateTimeFilter<"refund"> | Date | string
    processed_at?: DateTimeNullableFilter<"refund"> | Date | string | null
    user?: XOR<UsersRelationFilter, usersWhereInput>
    transaksi?: XOR<TransaksiRelationFilter, transaksiWhereInput>
    order?: XOR<Order_bookingRelationFilter, order_bookingWhereInput>
  }

  export type refundOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    transaksi_id?: SortOrder
    order_id?: SortOrder
    jumlah?: SortOrder
    alasan?: SortOrderInput | SortOrder
    status?: SortOrder
    created_at?: SortOrder
    processed_at?: SortOrderInput | SortOrder
    user?: usersOrderByWithRelationInput
    transaksi?: transaksiOrderByWithRelationInput
    order?: order_bookingOrderByWithRelationInput
  }

  export type refundWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    transaksi_id?: number
    order_id?: number
    AND?: refundWhereInput | refundWhereInput[]
    OR?: refundWhereInput[]
    NOT?: refundWhereInput | refundWhereInput[]
    user_id?: IntFilter<"refund"> | number
    jumlah?: DecimalFilter<"refund"> | Decimal | DecimalJsLike | number | string
    alasan?: StringNullableFilter<"refund"> | string | null
    status?: Enumrefund_statusFilter<"refund"> | $Enums.refund_status
    created_at?: DateTimeFilter<"refund"> | Date | string
    processed_at?: DateTimeNullableFilter<"refund"> | Date | string | null
    user?: XOR<UsersRelationFilter, usersWhereInput>
    transaksi?: XOR<TransaksiRelationFilter, transaksiWhereInput>
    order?: XOR<Order_bookingRelationFilter, order_bookingWhereInput>
  }, "id" | "transaksi_id" | "order_id">

  export type refundOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    transaksi_id?: SortOrder
    order_id?: SortOrder
    jumlah?: SortOrder
    alasan?: SortOrderInput | SortOrder
    status?: SortOrder
    created_at?: SortOrder
    processed_at?: SortOrderInput | SortOrder
    _count?: refundCountOrderByAggregateInput
    _avg?: refundAvgOrderByAggregateInput
    _max?: refundMaxOrderByAggregateInput
    _min?: refundMinOrderByAggregateInput
    _sum?: refundSumOrderByAggregateInput
  }

  export type refundScalarWhereWithAggregatesInput = {
    AND?: refundScalarWhereWithAggregatesInput | refundScalarWhereWithAggregatesInput[]
    OR?: refundScalarWhereWithAggregatesInput[]
    NOT?: refundScalarWhereWithAggregatesInput | refundScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"refund"> | number
    user_id?: IntWithAggregatesFilter<"refund"> | number
    transaksi_id?: IntWithAggregatesFilter<"refund"> | number
    order_id?: IntWithAggregatesFilter<"refund"> | number
    jumlah?: DecimalWithAggregatesFilter<"refund"> | Decimal | DecimalJsLike | number | string
    alasan?: StringNullableWithAggregatesFilter<"refund"> | string | null
    status?: Enumrefund_statusWithAggregatesFilter<"refund"> | $Enums.refund_status
    created_at?: DateTimeWithAggregatesFilter<"refund"> | Date | string
    processed_at?: DateTimeNullableWithAggregatesFilter<"refund"> | Date | string | null
  }

  export type notifikasiWhereInput = {
    AND?: notifikasiWhereInput | notifikasiWhereInput[]
    OR?: notifikasiWhereInput[]
    NOT?: notifikasiWhereInput | notifikasiWhereInput[]
    id?: IntFilter<"notifikasi"> | number
    user_id?: IntFilter<"notifikasi"> | number
    pesan?: StringFilter<"notifikasi"> | string
    dibaca?: BoolFilter<"notifikasi"> | boolean
    created_at?: DateTimeFilter<"notifikasi"> | Date | string
    user?: XOR<UsersRelationFilter, usersWhereInput>
  }

  export type notifikasiOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    pesan?: SortOrder
    dibaca?: SortOrder
    created_at?: SortOrder
    user?: usersOrderByWithRelationInput
  }

  export type notifikasiWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: notifikasiWhereInput | notifikasiWhereInput[]
    OR?: notifikasiWhereInput[]
    NOT?: notifikasiWhereInput | notifikasiWhereInput[]
    user_id?: IntFilter<"notifikasi"> | number
    pesan?: StringFilter<"notifikasi"> | string
    dibaca?: BoolFilter<"notifikasi"> | boolean
    created_at?: DateTimeFilter<"notifikasi"> | Date | string
    user?: XOR<UsersRelationFilter, usersWhereInput>
  }, "id">

  export type notifikasiOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    pesan?: SortOrder
    dibaca?: SortOrder
    created_at?: SortOrder
    _count?: notifikasiCountOrderByAggregateInput
    _avg?: notifikasiAvgOrderByAggregateInput
    _max?: notifikasiMaxOrderByAggregateInput
    _min?: notifikasiMinOrderByAggregateInput
    _sum?: notifikasiSumOrderByAggregateInput
  }

  export type notifikasiScalarWhereWithAggregatesInput = {
    AND?: notifikasiScalarWhereWithAggregatesInput | notifikasiScalarWhereWithAggregatesInput[]
    OR?: notifikasiScalarWhereWithAggregatesInput[]
    NOT?: notifikasiScalarWhereWithAggregatesInput | notifikasiScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"notifikasi"> | number
    user_id?: IntWithAggregatesFilter<"notifikasi"> | number
    pesan?: StringWithAggregatesFilter<"notifikasi"> | string
    dibaca?: BoolWithAggregatesFilter<"notifikasi"> | boolean
    created_at?: DateTimeWithAggregatesFilter<"notifikasi"> | Date | string
  }

  export type ulasanWhereInput = {
    AND?: ulasanWhereInput | ulasanWhereInput[]
    OR?: ulasanWhereInput[]
    NOT?: ulasanWhereInput | ulasanWhereInput[]
    id?: IntFilter<"ulasan"> | number
    user_id?: IntFilter<"ulasan"> | number
    lapangan_id?: IntFilter<"ulasan"> | number
    rating?: IntFilter<"ulasan"> | number
    komentar?: StringNullableFilter<"ulasan"> | string | null
    created_at?: DateTimeFilter<"ulasan"> | Date | string
    user?: XOR<UsersRelationFilter, usersWhereInput>
    lapangan?: XOR<LapanganRelationFilter, LapanganWhereInput>
  }

  export type ulasanOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    lapangan_id?: SortOrder
    rating?: SortOrder
    komentar?: SortOrderInput | SortOrder
    created_at?: SortOrder
    user?: usersOrderByWithRelationInput
    lapangan?: LapanganOrderByWithRelationInput
  }

  export type ulasanWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ulasanWhereInput | ulasanWhereInput[]
    OR?: ulasanWhereInput[]
    NOT?: ulasanWhereInput | ulasanWhereInput[]
    user_id?: IntFilter<"ulasan"> | number
    lapangan_id?: IntFilter<"ulasan"> | number
    rating?: IntFilter<"ulasan"> | number
    komentar?: StringNullableFilter<"ulasan"> | string | null
    created_at?: DateTimeFilter<"ulasan"> | Date | string
    user?: XOR<UsersRelationFilter, usersWhereInput>
    lapangan?: XOR<LapanganRelationFilter, LapanganWhereInput>
  }, "id">

  export type ulasanOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    lapangan_id?: SortOrder
    rating?: SortOrder
    komentar?: SortOrderInput | SortOrder
    created_at?: SortOrder
    _count?: ulasanCountOrderByAggregateInput
    _avg?: ulasanAvgOrderByAggregateInput
    _max?: ulasanMaxOrderByAggregateInput
    _min?: ulasanMinOrderByAggregateInput
    _sum?: ulasanSumOrderByAggregateInput
  }

  export type ulasanScalarWhereWithAggregatesInput = {
    AND?: ulasanScalarWhereWithAggregatesInput | ulasanScalarWhereWithAggregatesInput[]
    OR?: ulasanScalarWhereWithAggregatesInput[]
    NOT?: ulasanScalarWhereWithAggregatesInput | ulasanScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ulasan"> | number
    user_id?: IntWithAggregatesFilter<"ulasan"> | number
    lapangan_id?: IntWithAggregatesFilter<"ulasan"> | number
    rating?: IntWithAggregatesFilter<"ulasan"> | number
    komentar?: StringNullableWithAggregatesFilter<"ulasan"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"ulasan"> | Date | string
  }

  export type pendapatan_mitraWhereInput = {
    AND?: pendapatan_mitraWhereInput | pendapatan_mitraWhereInput[]
    OR?: pendapatan_mitraWhereInput[]
    NOT?: pendapatan_mitraWhereInput | pendapatan_mitraWhereInput[]
    id?: IntFilter<"pendapatan_mitra"> | number
    mitra_id?: IntFilter<"pendapatan_mitra"> | number
    transaksi_id?: IntFilter<"pendapatan_mitra"> | number
    jumlah?: DecimalFilter<"pendapatan_mitra"> | Decimal | DecimalJsLike | number | string
    created_at?: DateTimeFilter<"pendapatan_mitra"> | Date | string
    mitra?: XOR<MitraRelationFilter, MitraWhereInput>
  }

  export type pendapatan_mitraOrderByWithRelationInput = {
    id?: SortOrder
    mitra_id?: SortOrder
    transaksi_id?: SortOrder
    jumlah?: SortOrder
    created_at?: SortOrder
    mitra?: MitraOrderByWithRelationInput
  }

  export type pendapatan_mitraWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: pendapatan_mitraWhereInput | pendapatan_mitraWhereInput[]
    OR?: pendapatan_mitraWhereInput[]
    NOT?: pendapatan_mitraWhereInput | pendapatan_mitraWhereInput[]
    mitra_id?: IntFilter<"pendapatan_mitra"> | number
    transaksi_id?: IntFilter<"pendapatan_mitra"> | number
    jumlah?: DecimalFilter<"pendapatan_mitra"> | Decimal | DecimalJsLike | number | string
    created_at?: DateTimeFilter<"pendapatan_mitra"> | Date | string
    mitra?: XOR<MitraRelationFilter, MitraWhereInput>
  }, "id">

  export type pendapatan_mitraOrderByWithAggregationInput = {
    id?: SortOrder
    mitra_id?: SortOrder
    transaksi_id?: SortOrder
    jumlah?: SortOrder
    created_at?: SortOrder
    _count?: pendapatan_mitraCountOrderByAggregateInput
    _avg?: pendapatan_mitraAvgOrderByAggregateInput
    _max?: pendapatan_mitraMaxOrderByAggregateInput
    _min?: pendapatan_mitraMinOrderByAggregateInput
    _sum?: pendapatan_mitraSumOrderByAggregateInput
  }

  export type pendapatan_mitraScalarWhereWithAggregatesInput = {
    AND?: pendapatan_mitraScalarWhereWithAggregatesInput | pendapatan_mitraScalarWhereWithAggregatesInput[]
    OR?: pendapatan_mitraScalarWhereWithAggregatesInput[]
    NOT?: pendapatan_mitraScalarWhereWithAggregatesInput | pendapatan_mitraScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"pendapatan_mitra"> | number
    mitra_id?: IntWithAggregatesFilter<"pendapatan_mitra"> | number
    transaksi_id?: IntWithAggregatesFilter<"pendapatan_mitra"> | number
    jumlah?: DecimalWithAggregatesFilter<"pendapatan_mitra"> | Decimal | DecimalJsLike | number | string
    created_at?: DateTimeWithAggregatesFilter<"pendapatan_mitra"> | Date | string
  }

  export type pencairan_pendapatanWhereInput = {
    AND?: pencairan_pendapatanWhereInput | pencairan_pendapatanWhereInput[]
    OR?: pencairan_pendapatanWhereInput[]
    NOT?: pencairan_pendapatanWhereInput | pencairan_pendapatanWhereInput[]
    id?: IntFilter<"pencairan_pendapatan"> | number
    mitra_id?: IntFilter<"pencairan_pendapatan"> | number
    jumlah?: DecimalFilter<"pencairan_pendapatan"> | Decimal | DecimalJsLike | number | string
    status?: Enumpencairan_statusFilter<"pencairan_pendapatan"> | $Enums.pencairan_status
    created_at?: DateTimeFilter<"pencairan_pendapatan"> | Date | string
    mitra?: XOR<MitraRelationFilter, MitraWhereInput>
  }

  export type pencairan_pendapatanOrderByWithRelationInput = {
    id?: SortOrder
    mitra_id?: SortOrder
    jumlah?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    mitra?: MitraOrderByWithRelationInput
  }

  export type pencairan_pendapatanWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: pencairan_pendapatanWhereInput | pencairan_pendapatanWhereInput[]
    OR?: pencairan_pendapatanWhereInput[]
    NOT?: pencairan_pendapatanWhereInput | pencairan_pendapatanWhereInput[]
    mitra_id?: IntFilter<"pencairan_pendapatan"> | number
    jumlah?: DecimalFilter<"pencairan_pendapatan"> | Decimal | DecimalJsLike | number | string
    status?: Enumpencairan_statusFilter<"pencairan_pendapatan"> | $Enums.pencairan_status
    created_at?: DateTimeFilter<"pencairan_pendapatan"> | Date | string
    mitra?: XOR<MitraRelationFilter, MitraWhereInput>
  }, "id">

  export type pencairan_pendapatanOrderByWithAggregationInput = {
    id?: SortOrder
    mitra_id?: SortOrder
    jumlah?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    _count?: pencairan_pendapatanCountOrderByAggregateInput
    _avg?: pencairan_pendapatanAvgOrderByAggregateInput
    _max?: pencairan_pendapatanMaxOrderByAggregateInput
    _min?: pencairan_pendapatanMinOrderByAggregateInput
    _sum?: pencairan_pendapatanSumOrderByAggregateInput
  }

  export type pencairan_pendapatanScalarWhereWithAggregatesInput = {
    AND?: pencairan_pendapatanScalarWhereWithAggregatesInput | pencairan_pendapatanScalarWhereWithAggregatesInput[]
    OR?: pencairan_pendapatanScalarWhereWithAggregatesInput[]
    NOT?: pencairan_pendapatanScalarWhereWithAggregatesInput | pencairan_pendapatanScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"pencairan_pendapatan"> | number
    mitra_id?: IntWithAggregatesFilter<"pencairan_pendapatan"> | number
    jumlah?: DecimalWithAggregatesFilter<"pencairan_pendapatan"> | Decimal | DecimalJsLike | number | string
    status?: Enumpencairan_statusWithAggregatesFilter<"pencairan_pendapatan"> | $Enums.pencairan_status
    created_at?: DateTimeWithAggregatesFilter<"pencairan_pendapatan"> | Date | string
  }

  export type usersCreateInput = {
    nama: string
    username: string
    email: string
    password: string
    no_hp?: string | null
    foto?: string | null
    bio?: string | null
    role?: $Enums.users_role
    status?: $Enums.users_status
    created_at?: Date | string
    updated_at?: Date | string
    mitra?: MitraCreateNestedOneWithoutUserInput
    orders?: order_bookingCreateNestedManyWithoutUserInput
    transaksi?: transaksiCreateNestedManyWithoutUserInput
    notifikasi?: notifikasiCreateNestedManyWithoutUserInput
    ulasan?: ulasanCreateNestedManyWithoutUserInput
    wallet?: wallet_userCreateNestedOneWithoutUserInput
    refund?: refundCreateNestedManyWithoutUserInput
  }

  export type usersUncheckedCreateInput = {
    id?: number
    nama: string
    username: string
    email: string
    password: string
    no_hp?: string | null
    foto?: string | null
    bio?: string | null
    role?: $Enums.users_role
    status?: $Enums.users_status
    created_at?: Date | string
    updated_at?: Date | string
    mitra?: MitraUncheckedCreateNestedOneWithoutUserInput
    orders?: order_bookingUncheckedCreateNestedManyWithoutUserInput
    transaksi?: transaksiUncheckedCreateNestedManyWithoutUserInput
    notifikasi?: notifikasiUncheckedCreateNestedManyWithoutUserInput
    ulasan?: ulasanUncheckedCreateNestedManyWithoutUserInput
    wallet?: wallet_userUncheckedCreateNestedOneWithoutUserInput
    refund?: refundUncheckedCreateNestedManyWithoutUserInput
  }

  export type usersUpdateInput = {
    nama?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    no_hp?: NullableStringFieldUpdateOperationsInput | string | null
    foto?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    role?: Enumusers_roleFieldUpdateOperationsInput | $Enums.users_role
    status?: Enumusers_statusFieldUpdateOperationsInput | $Enums.users_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    mitra?: MitraUpdateOneWithoutUserNestedInput
    orders?: order_bookingUpdateManyWithoutUserNestedInput
    transaksi?: transaksiUpdateManyWithoutUserNestedInput
    notifikasi?: notifikasiUpdateManyWithoutUserNestedInput
    ulasan?: ulasanUpdateManyWithoutUserNestedInput
    wallet?: wallet_userUpdateOneWithoutUserNestedInput
    refund?: refundUpdateManyWithoutUserNestedInput
  }

  export type usersUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nama?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    no_hp?: NullableStringFieldUpdateOperationsInput | string | null
    foto?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    role?: Enumusers_roleFieldUpdateOperationsInput | $Enums.users_role
    status?: Enumusers_statusFieldUpdateOperationsInput | $Enums.users_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    mitra?: MitraUncheckedUpdateOneWithoutUserNestedInput
    orders?: order_bookingUncheckedUpdateManyWithoutUserNestedInput
    transaksi?: transaksiUncheckedUpdateManyWithoutUserNestedInput
    notifikasi?: notifikasiUncheckedUpdateManyWithoutUserNestedInput
    ulasan?: ulasanUncheckedUpdateManyWithoutUserNestedInput
    wallet?: wallet_userUncheckedUpdateOneWithoutUserNestedInput
    refund?: refundUncheckedUpdateManyWithoutUserNestedInput
  }

  export type usersCreateManyInput = {
    id?: number
    nama: string
    username: string
    email: string
    password: string
    no_hp?: string | null
    foto?: string | null
    bio?: string | null
    role?: $Enums.users_role
    status?: $Enums.users_status
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type usersUpdateManyMutationInput = {
    nama?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    no_hp?: NullableStringFieldUpdateOperationsInput | string | null
    foto?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    role?: Enumusers_roleFieldUpdateOperationsInput | $Enums.users_role
    status?: Enumusers_statusFieldUpdateOperationsInput | $Enums.users_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type usersUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nama?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    no_hp?: NullableStringFieldUpdateOperationsInput | string | null
    foto?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    role?: Enumusers_roleFieldUpdateOperationsInput | $Enums.users_role
    status?: Enumusers_statusFieldUpdateOperationsInput | $Enums.users_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MitraCreateInput = {
    nama_usaha: string
    alamat_usaha: string
    no_ktp: string
    foto_ktp: string
    withdraw_type?: string | null
    withdraw_day?: number | null
    bank_mitra?: string | null
    no_rekening_mitra?: string | null
    status?: $Enums.mitra_status
    created_at?: Date | string
    user: usersCreateNestedOneWithoutMitraInput
    lapangan?: LapanganCreateNestedManyWithoutMitraInput
    pendapatan?: pendapatan_mitraCreateNestedManyWithoutMitraInput
    pencairan?: pencairan_pendapatanCreateNestedManyWithoutMitraInput
  }

  export type MitraUncheckedCreateInput = {
    id?: number
    userId: number
    nama_usaha: string
    alamat_usaha: string
    no_ktp: string
    foto_ktp: string
    withdraw_type?: string | null
    withdraw_day?: number | null
    bank_mitra?: string | null
    no_rekening_mitra?: string | null
    status?: $Enums.mitra_status
    created_at?: Date | string
    lapangan?: LapanganUncheckedCreateNestedManyWithoutMitraInput
    pendapatan?: pendapatan_mitraUncheckedCreateNestedManyWithoutMitraInput
    pencairan?: pencairan_pendapatanUncheckedCreateNestedManyWithoutMitraInput
  }

  export type MitraUpdateInput = {
    nama_usaha?: StringFieldUpdateOperationsInput | string
    alamat_usaha?: StringFieldUpdateOperationsInput | string
    no_ktp?: StringFieldUpdateOperationsInput | string
    foto_ktp?: StringFieldUpdateOperationsInput | string
    withdraw_type?: NullableStringFieldUpdateOperationsInput | string | null
    withdraw_day?: NullableIntFieldUpdateOperationsInput | number | null
    bank_mitra?: NullableStringFieldUpdateOperationsInput | string | null
    no_rekening_mitra?: NullableStringFieldUpdateOperationsInput | string | null
    status?: Enummitra_statusFieldUpdateOperationsInput | $Enums.mitra_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: usersUpdateOneRequiredWithoutMitraNestedInput
    lapangan?: LapanganUpdateManyWithoutMitraNestedInput
    pendapatan?: pendapatan_mitraUpdateManyWithoutMitraNestedInput
    pencairan?: pencairan_pendapatanUpdateManyWithoutMitraNestedInput
  }

  export type MitraUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    nama_usaha?: StringFieldUpdateOperationsInput | string
    alamat_usaha?: StringFieldUpdateOperationsInput | string
    no_ktp?: StringFieldUpdateOperationsInput | string
    foto_ktp?: StringFieldUpdateOperationsInput | string
    withdraw_type?: NullableStringFieldUpdateOperationsInput | string | null
    withdraw_day?: NullableIntFieldUpdateOperationsInput | number | null
    bank_mitra?: NullableStringFieldUpdateOperationsInput | string | null
    no_rekening_mitra?: NullableStringFieldUpdateOperationsInput | string | null
    status?: Enummitra_statusFieldUpdateOperationsInput | $Enums.mitra_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    lapangan?: LapanganUncheckedUpdateManyWithoutMitraNestedInput
    pendapatan?: pendapatan_mitraUncheckedUpdateManyWithoutMitraNestedInput
    pencairan?: pencairan_pendapatanUncheckedUpdateManyWithoutMitraNestedInput
  }

  export type MitraCreateManyInput = {
    id?: number
    userId: number
    nama_usaha: string
    alamat_usaha: string
    no_ktp: string
    foto_ktp: string
    withdraw_type?: string | null
    withdraw_day?: number | null
    bank_mitra?: string | null
    no_rekening_mitra?: string | null
    status?: $Enums.mitra_status
    created_at?: Date | string
  }

  export type MitraUpdateManyMutationInput = {
    nama_usaha?: StringFieldUpdateOperationsInput | string
    alamat_usaha?: StringFieldUpdateOperationsInput | string
    no_ktp?: StringFieldUpdateOperationsInput | string
    foto_ktp?: StringFieldUpdateOperationsInput | string
    withdraw_type?: NullableStringFieldUpdateOperationsInput | string | null
    withdraw_day?: NullableIntFieldUpdateOperationsInput | number | null
    bank_mitra?: NullableStringFieldUpdateOperationsInput | string | null
    no_rekening_mitra?: NullableStringFieldUpdateOperationsInput | string | null
    status?: Enummitra_statusFieldUpdateOperationsInput | $Enums.mitra_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MitraUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    nama_usaha?: StringFieldUpdateOperationsInput | string
    alamat_usaha?: StringFieldUpdateOperationsInput | string
    no_ktp?: StringFieldUpdateOperationsInput | string
    foto_ktp?: StringFieldUpdateOperationsInput | string
    withdraw_type?: NullableStringFieldUpdateOperationsInput | string | null
    withdraw_day?: NullableIntFieldUpdateOperationsInput | number | null
    bank_mitra?: NullableStringFieldUpdateOperationsInput | string | null
    no_rekening_mitra?: NullableStringFieldUpdateOperationsInput | string | null
    status?: Enummitra_statusFieldUpdateOperationsInput | $Enums.mitra_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type otp_codesCreateInput = {
    user_email: string
    kode_otp: string
    expired_at: Date | string
    digunakan?: boolean
    created_at?: Date | string
  }

  export type otp_codesUncheckedCreateInput = {
    id?: number
    user_email: string
    kode_otp: string
    expired_at: Date | string
    digunakan?: boolean
    created_at?: Date | string
  }

  export type otp_codesUpdateInput = {
    user_email?: StringFieldUpdateOperationsInput | string
    kode_otp?: StringFieldUpdateOperationsInput | string
    expired_at?: DateTimeFieldUpdateOperationsInput | Date | string
    digunakan?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type otp_codesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_email?: StringFieldUpdateOperationsInput | string
    kode_otp?: StringFieldUpdateOperationsInput | string
    expired_at?: DateTimeFieldUpdateOperationsInput | Date | string
    digunakan?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type otp_codesCreateManyInput = {
    id?: number
    user_email: string
    kode_otp: string
    expired_at: Date | string
    digunakan?: boolean
    created_at?: Date | string
  }

  export type otp_codesUpdateManyMutationInput = {
    user_email?: StringFieldUpdateOperationsInput | string
    kode_otp?: StringFieldUpdateOperationsInput | string
    expired_at?: DateTimeFieldUpdateOperationsInput | Date | string
    digunakan?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type otp_codesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_email?: StringFieldUpdateOperationsInput | string
    kode_otp?: StringFieldUpdateOperationsInput | string
    expired_at?: DateTimeFieldUpdateOperationsInput | Date | string
    digunakan?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LapanganCreateInput = {
    nama: string
    slug: string
    lokasi?: string | null
    harga: Decimal | DecimalJsLike | number | string
    gambar?: string | null
    rating?: number | null
    status?: $Enums.lapangan_status
    created_at?: Date | string
    mitra: MitraCreateNestedOneWithoutLapanganInput
    detail?: LapanganDetailCreateNestedOneWithoutLapanganInput
    gambarList?: LapanganGambarCreateNestedManyWithoutLapanganInput
    jadwal?: JadwalLapanganCreateNestedManyWithoutLapanganInput
    orders?: order_bookingCreateNestedManyWithoutLapanganInput
    transaksi?: transaksiCreateNestedManyWithoutLapanganInput
    ulasan?: ulasanCreateNestedManyWithoutLapanganInput
  }

  export type LapanganUncheckedCreateInput = {
    id?: number
    mitra_id: number
    nama: string
    slug: string
    lokasi?: string | null
    harga: Decimal | DecimalJsLike | number | string
    gambar?: string | null
    rating?: number | null
    status?: $Enums.lapangan_status
    created_at?: Date | string
    detail?: LapanganDetailUncheckedCreateNestedOneWithoutLapanganInput
    gambarList?: LapanganGambarUncheckedCreateNestedManyWithoutLapanganInput
    jadwal?: JadwalLapanganUncheckedCreateNestedManyWithoutLapanganInput
    orders?: order_bookingUncheckedCreateNestedManyWithoutLapanganInput
    transaksi?: transaksiUncheckedCreateNestedManyWithoutLapanganInput
    ulasan?: ulasanUncheckedCreateNestedManyWithoutLapanganInput
  }

  export type LapanganUpdateInput = {
    nama?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    lokasi?: NullableStringFieldUpdateOperationsInput | string | null
    harga?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    gambar?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: Enumlapangan_statusFieldUpdateOperationsInput | $Enums.lapangan_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    mitra?: MitraUpdateOneRequiredWithoutLapanganNestedInput
    detail?: LapanganDetailUpdateOneWithoutLapanganNestedInput
    gambarList?: LapanganGambarUpdateManyWithoutLapanganNestedInput
    jadwal?: JadwalLapanganUpdateManyWithoutLapanganNestedInput
    orders?: order_bookingUpdateManyWithoutLapanganNestedInput
    transaksi?: transaksiUpdateManyWithoutLapanganNestedInput
    ulasan?: ulasanUpdateManyWithoutLapanganNestedInput
  }

  export type LapanganUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    mitra_id?: IntFieldUpdateOperationsInput | number
    nama?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    lokasi?: NullableStringFieldUpdateOperationsInput | string | null
    harga?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    gambar?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: Enumlapangan_statusFieldUpdateOperationsInput | $Enums.lapangan_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    detail?: LapanganDetailUncheckedUpdateOneWithoutLapanganNestedInput
    gambarList?: LapanganGambarUncheckedUpdateManyWithoutLapanganNestedInput
    jadwal?: JadwalLapanganUncheckedUpdateManyWithoutLapanganNestedInput
    orders?: order_bookingUncheckedUpdateManyWithoutLapanganNestedInput
    transaksi?: transaksiUncheckedUpdateManyWithoutLapanganNestedInput
    ulasan?: ulasanUncheckedUpdateManyWithoutLapanganNestedInput
  }

  export type LapanganCreateManyInput = {
    id?: number
    mitra_id: number
    nama: string
    slug: string
    lokasi?: string | null
    harga: Decimal | DecimalJsLike | number | string
    gambar?: string | null
    rating?: number | null
    status?: $Enums.lapangan_status
    created_at?: Date | string
  }

  export type LapanganUpdateManyMutationInput = {
    nama?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    lokasi?: NullableStringFieldUpdateOperationsInput | string | null
    harga?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    gambar?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: Enumlapangan_statusFieldUpdateOperationsInput | $Enums.lapangan_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LapanganUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    mitra_id?: IntFieldUpdateOperationsInput | number
    nama?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    lokasi?: NullableStringFieldUpdateOperationsInput | string | null
    harga?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    gambar?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: Enumlapangan_statusFieldUpdateOperationsInput | $Enums.lapangan_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LapanganDetailCreateInput = {
    alamat: string
    maps: string
    deskripsi: string
    type: string
    fasilitas: JsonNullValueInput | InputJsonValue
    interval?: number
    breakTime?: number
    lapangan: LapanganCreateNestedOneWithoutDetailInput
  }

  export type LapanganDetailUncheckedCreateInput = {
    id?: number
    lapangan_id: number
    alamat: string
    maps: string
    deskripsi: string
    type: string
    fasilitas: JsonNullValueInput | InputJsonValue
    interval?: number
    breakTime?: number
  }

  export type LapanganDetailUpdateInput = {
    alamat?: StringFieldUpdateOperationsInput | string
    maps?: StringFieldUpdateOperationsInput | string
    deskripsi?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    fasilitas?: JsonNullValueInput | InputJsonValue
    interval?: IntFieldUpdateOperationsInput | number
    breakTime?: IntFieldUpdateOperationsInput | number
    lapangan?: LapanganUpdateOneRequiredWithoutDetailNestedInput
  }

  export type LapanganDetailUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    lapangan_id?: IntFieldUpdateOperationsInput | number
    alamat?: StringFieldUpdateOperationsInput | string
    maps?: StringFieldUpdateOperationsInput | string
    deskripsi?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    fasilitas?: JsonNullValueInput | InputJsonValue
    interval?: IntFieldUpdateOperationsInput | number
    breakTime?: IntFieldUpdateOperationsInput | number
  }

  export type LapanganDetailCreateManyInput = {
    id?: number
    lapangan_id: number
    alamat: string
    maps: string
    deskripsi: string
    type: string
    fasilitas: JsonNullValueInput | InputJsonValue
    interval?: number
    breakTime?: number
  }

  export type LapanganDetailUpdateManyMutationInput = {
    alamat?: StringFieldUpdateOperationsInput | string
    maps?: StringFieldUpdateOperationsInput | string
    deskripsi?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    fasilitas?: JsonNullValueInput | InputJsonValue
    interval?: IntFieldUpdateOperationsInput | number
    breakTime?: IntFieldUpdateOperationsInput | number
  }

  export type LapanganDetailUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    lapangan_id?: IntFieldUpdateOperationsInput | number
    alamat?: StringFieldUpdateOperationsInput | string
    maps?: StringFieldUpdateOperationsInput | string
    deskripsi?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    fasilitas?: JsonNullValueInput | InputJsonValue
    interval?: IntFieldUpdateOperationsInput | number
    breakTime?: IntFieldUpdateOperationsInput | number
  }

  export type LapanganGambarCreateInput = {
    file_name: string
    created_at?: Date | string
    lapangan: LapanganCreateNestedOneWithoutGambarListInput
  }

  export type LapanganGambarUncheckedCreateInput = {
    id?: number
    lapangan_id: number
    file_name: string
    created_at?: Date | string
  }

  export type LapanganGambarUpdateInput = {
    file_name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    lapangan?: LapanganUpdateOneRequiredWithoutGambarListNestedInput
  }

  export type LapanganGambarUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    lapangan_id?: IntFieldUpdateOperationsInput | number
    file_name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LapanganGambarCreateManyInput = {
    id?: number
    lapangan_id: number
    file_name: string
    created_at?: Date | string
  }

  export type LapanganGambarUpdateManyMutationInput = {
    file_name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LapanganGambarUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    lapangan_id?: IntFieldUpdateOperationsInput | number
    file_name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JadwalLapanganCreateInput = {
    tanggal: Date | string
    slot: string
    status?: $Enums.jadwal_status
    locked_until?: Date | string | null
    lapangan: LapanganCreateNestedOneWithoutJadwalInput
    orders?: order_bookingCreateNestedManyWithoutJadwalLapanganInput
    transaksi?: transaksiCreateNestedManyWithoutJadwalInput
  }

  export type JadwalLapanganUncheckedCreateInput = {
    id?: number
    lapangan_id: number
    tanggal: Date | string
    slot: string
    status?: $Enums.jadwal_status
    locked_until?: Date | string | null
    orders?: order_bookingUncheckedCreateNestedManyWithoutJadwalLapanganInput
    transaksi?: transaksiUncheckedCreateNestedManyWithoutJadwalInput
  }

  export type JadwalLapanganUpdateInput = {
    tanggal?: DateTimeFieldUpdateOperationsInput | Date | string
    slot?: StringFieldUpdateOperationsInput | string
    status?: Enumjadwal_statusFieldUpdateOperationsInput | $Enums.jadwal_status
    locked_until?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lapangan?: LapanganUpdateOneRequiredWithoutJadwalNestedInput
    orders?: order_bookingUpdateManyWithoutJadwalLapanganNestedInput
    transaksi?: transaksiUpdateManyWithoutJadwalNestedInput
  }

  export type JadwalLapanganUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    lapangan_id?: IntFieldUpdateOperationsInput | number
    tanggal?: DateTimeFieldUpdateOperationsInput | Date | string
    slot?: StringFieldUpdateOperationsInput | string
    status?: Enumjadwal_statusFieldUpdateOperationsInput | $Enums.jadwal_status
    locked_until?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    orders?: order_bookingUncheckedUpdateManyWithoutJadwalLapanganNestedInput
    transaksi?: transaksiUncheckedUpdateManyWithoutJadwalNestedInput
  }

  export type JadwalLapanganCreateManyInput = {
    id?: number
    lapangan_id: number
    tanggal: Date | string
    slot: string
    status?: $Enums.jadwal_status
    locked_until?: Date | string | null
  }

  export type JadwalLapanganUpdateManyMutationInput = {
    tanggal?: DateTimeFieldUpdateOperationsInput | Date | string
    slot?: StringFieldUpdateOperationsInput | string
    status?: Enumjadwal_statusFieldUpdateOperationsInput | $Enums.jadwal_status
    locked_until?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type JadwalLapanganUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    lapangan_id?: IntFieldUpdateOperationsInput | number
    tanggal?: DateTimeFieldUpdateOperationsInput | Date | string
    slot?: StringFieldUpdateOperationsInput | string
    status?: Enumjadwal_statusFieldUpdateOperationsInput | $Enums.jadwal_status
    locked_until?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type order_bookingCreateInput = {
    tanggal: Date | string
    jam_mulai: string
    jam_selesai: string
    total_harga: Decimal | DecimalJsLike | number | string
    status: string
    sewa_raket?: boolean
    biaya_raket?: number
    created_at?: Date | string
    expired_at?: Date | string | null
    user: usersCreateNestedOneWithoutOrdersInput
    lapangan: LapanganCreateNestedOneWithoutOrdersInput
    jadwalLapangan: JadwalLapanganCreateNestedOneWithoutOrdersInput
    transaksi?: transaksiCreateNestedOneWithoutOrderInput
    refund?: refundCreateNestedOneWithoutOrderInput
    wallet_histories?: wallet_historyCreateNestedManyWithoutOrderInput
  }

  export type order_bookingUncheckedCreateInput = {
    id?: number
    user_id: number
    lapangan_id: number
    jadwalLapanganId: number
    tanggal: Date | string
    jam_mulai: string
    jam_selesai: string
    total_harga: Decimal | DecimalJsLike | number | string
    status: string
    sewa_raket?: boolean
    biaya_raket?: number
    created_at?: Date | string
    expired_at?: Date | string | null
    transaksi?: transaksiUncheckedCreateNestedOneWithoutOrderInput
    refund?: refundUncheckedCreateNestedOneWithoutOrderInput
    wallet_histories?: wallet_historyUncheckedCreateNestedManyWithoutOrderInput
  }

  export type order_bookingUpdateInput = {
    tanggal?: DateTimeFieldUpdateOperationsInput | Date | string
    jam_mulai?: StringFieldUpdateOperationsInput | string
    jam_selesai?: StringFieldUpdateOperationsInput | string
    total_harga?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    sewa_raket?: BoolFieldUpdateOperationsInput | boolean
    biaya_raket?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    expired_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: usersUpdateOneRequiredWithoutOrdersNestedInput
    lapangan?: LapanganUpdateOneRequiredWithoutOrdersNestedInput
    jadwalLapangan?: JadwalLapanganUpdateOneRequiredWithoutOrdersNestedInput
    transaksi?: transaksiUpdateOneWithoutOrderNestedInput
    refund?: refundUpdateOneWithoutOrderNestedInput
    wallet_histories?: wallet_historyUpdateManyWithoutOrderNestedInput
  }

  export type order_bookingUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    lapangan_id?: IntFieldUpdateOperationsInput | number
    jadwalLapanganId?: IntFieldUpdateOperationsInput | number
    tanggal?: DateTimeFieldUpdateOperationsInput | Date | string
    jam_mulai?: StringFieldUpdateOperationsInput | string
    jam_selesai?: StringFieldUpdateOperationsInput | string
    total_harga?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    sewa_raket?: BoolFieldUpdateOperationsInput | boolean
    biaya_raket?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    expired_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transaksi?: transaksiUncheckedUpdateOneWithoutOrderNestedInput
    refund?: refundUncheckedUpdateOneWithoutOrderNestedInput
    wallet_histories?: wallet_historyUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type order_bookingCreateManyInput = {
    id?: number
    user_id: number
    lapangan_id: number
    jadwalLapanganId: number
    tanggal: Date | string
    jam_mulai: string
    jam_selesai: string
    total_harga: Decimal | DecimalJsLike | number | string
    status: string
    sewa_raket?: boolean
    biaya_raket?: number
    created_at?: Date | string
    expired_at?: Date | string | null
  }

  export type order_bookingUpdateManyMutationInput = {
    tanggal?: DateTimeFieldUpdateOperationsInput | Date | string
    jam_mulai?: StringFieldUpdateOperationsInput | string
    jam_selesai?: StringFieldUpdateOperationsInput | string
    total_harga?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    sewa_raket?: BoolFieldUpdateOperationsInput | boolean
    biaya_raket?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    expired_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type order_bookingUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    lapangan_id?: IntFieldUpdateOperationsInput | number
    jadwalLapanganId?: IntFieldUpdateOperationsInput | number
    tanggal?: DateTimeFieldUpdateOperationsInput | Date | string
    jam_mulai?: StringFieldUpdateOperationsInput | string
    jam_selesai?: StringFieldUpdateOperationsInput | string
    total_harga?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    sewa_raket?: BoolFieldUpdateOperationsInput | boolean
    biaya_raket?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    expired_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type transaksiCreateInput = {
    total_harga: Decimal | DecimalJsLike | number | string
    status_pembayaran?: $Enums.transaksi_status_pembayaran
    created_at?: Date | string
    user: usersCreateNestedOneWithoutTransaksiInput
    lapangan: LapanganCreateNestedOneWithoutTransaksiInput
    jadwal: JadwalLapanganCreateNestedOneWithoutTransaksiInput
    order?: order_bookingCreateNestedOneWithoutTransaksiInput
    refund?: refundCreateNestedOneWithoutTransaksiInput
    sewa_raket?: sewa_raketCreateNestedManyWithoutTransaksiInput
  }

  export type transaksiUncheckedCreateInput = {
    id?: number
    user_id: number
    lapangan_id: number
    jadwal_id: number
    order_id?: number | null
    total_harga: Decimal | DecimalJsLike | number | string
    status_pembayaran?: $Enums.transaksi_status_pembayaran
    created_at?: Date | string
    refund?: refundUncheckedCreateNestedOneWithoutTransaksiInput
    sewa_raket?: sewa_raketUncheckedCreateNestedManyWithoutTransaksiInput
  }

  export type transaksiUpdateInput = {
    total_harga?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status_pembayaran?: Enumtransaksi_status_pembayaranFieldUpdateOperationsInput | $Enums.transaksi_status_pembayaran
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: usersUpdateOneRequiredWithoutTransaksiNestedInput
    lapangan?: LapanganUpdateOneRequiredWithoutTransaksiNestedInput
    jadwal?: JadwalLapanganUpdateOneRequiredWithoutTransaksiNestedInput
    order?: order_bookingUpdateOneWithoutTransaksiNestedInput
    refund?: refundUpdateOneWithoutTransaksiNestedInput
    sewa_raket?: sewa_raketUpdateManyWithoutTransaksiNestedInput
  }

  export type transaksiUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    lapangan_id?: IntFieldUpdateOperationsInput | number
    jadwal_id?: IntFieldUpdateOperationsInput | number
    order_id?: NullableIntFieldUpdateOperationsInput | number | null
    total_harga?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status_pembayaran?: Enumtransaksi_status_pembayaranFieldUpdateOperationsInput | $Enums.transaksi_status_pembayaran
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    refund?: refundUncheckedUpdateOneWithoutTransaksiNestedInput
    sewa_raket?: sewa_raketUncheckedUpdateManyWithoutTransaksiNestedInput
  }

  export type transaksiCreateManyInput = {
    id?: number
    user_id: number
    lapangan_id: number
    jadwal_id: number
    order_id?: number | null
    total_harga: Decimal | DecimalJsLike | number | string
    status_pembayaran?: $Enums.transaksi_status_pembayaran
    created_at?: Date | string
  }

  export type transaksiUpdateManyMutationInput = {
    total_harga?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status_pembayaran?: Enumtransaksi_status_pembayaranFieldUpdateOperationsInput | $Enums.transaksi_status_pembayaran
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type transaksiUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    lapangan_id?: IntFieldUpdateOperationsInput | number
    jadwal_id?: IntFieldUpdateOperationsInput | number
    order_id?: NullableIntFieldUpdateOperationsInput | number | null
    total_harga?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status_pembayaran?: Enumtransaksi_status_pembayaranFieldUpdateOperationsInput | $Enums.transaksi_status_pembayaran
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type raket_padelCreateInput = {
    nama: string
    harga: Decimal | DecimalJsLike | number | string
    sewa_raket?: sewa_raketCreateNestedManyWithoutRaketInput
  }

  export type raket_padelUncheckedCreateInput = {
    id?: number
    nama: string
    harga: Decimal | DecimalJsLike | number | string
    sewa_raket?: sewa_raketUncheckedCreateNestedManyWithoutRaketInput
  }

  export type raket_padelUpdateInput = {
    nama?: StringFieldUpdateOperationsInput | string
    harga?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sewa_raket?: sewa_raketUpdateManyWithoutRaketNestedInput
  }

  export type raket_padelUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nama?: StringFieldUpdateOperationsInput | string
    harga?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sewa_raket?: sewa_raketUncheckedUpdateManyWithoutRaketNestedInput
  }

  export type raket_padelCreateManyInput = {
    id?: number
    nama: string
    harga: Decimal | DecimalJsLike | number | string
  }

  export type raket_padelUpdateManyMutationInput = {
    nama?: StringFieldUpdateOperationsInput | string
    harga?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type raket_padelUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nama?: StringFieldUpdateOperationsInput | string
    harga?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type sewa_raketCreateInput = {
    jumlah: number
    total_harga: Decimal | DecimalJsLike | number | string
    transaksi: transaksiCreateNestedOneWithoutSewa_raketInput
    raket: raket_padelCreateNestedOneWithoutSewa_raketInput
  }

  export type sewa_raketUncheckedCreateInput = {
    id?: number
    transaksi_id: number
    raket_id: number
    jumlah: number
    total_harga: Decimal | DecimalJsLike | number | string
  }

  export type sewa_raketUpdateInput = {
    jumlah?: IntFieldUpdateOperationsInput | number
    total_harga?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    transaksi?: transaksiUpdateOneRequiredWithoutSewa_raketNestedInput
    raket?: raket_padelUpdateOneRequiredWithoutSewa_raketNestedInput
  }

  export type sewa_raketUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    transaksi_id?: IntFieldUpdateOperationsInput | number
    raket_id?: IntFieldUpdateOperationsInput | number
    jumlah?: IntFieldUpdateOperationsInput | number
    total_harga?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type sewa_raketCreateManyInput = {
    id?: number
    transaksi_id: number
    raket_id: number
    jumlah: number
    total_harga: Decimal | DecimalJsLike | number | string
  }

  export type sewa_raketUpdateManyMutationInput = {
    jumlah?: IntFieldUpdateOperationsInput | number
    total_harga?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type sewa_raketUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    transaksi_id?: IntFieldUpdateOperationsInput | number
    raket_id?: IntFieldUpdateOperationsInput | number
    jumlah?: IntFieldUpdateOperationsInput | number
    total_harga?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type wallet_userCreateInput = {
    saldo?: number
    updated_at?: Date | string
    user: usersCreateNestedOneWithoutWalletInput
    history?: wallet_historyCreateNestedManyWithoutWalletInput
  }

  export type wallet_userUncheckedCreateInput = {
    id?: number
    user_id: number
    saldo?: number
    updated_at?: Date | string
    history?: wallet_historyUncheckedCreateNestedManyWithoutWalletInput
  }

  export type wallet_userUpdateInput = {
    saldo?: IntFieldUpdateOperationsInput | number
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: usersUpdateOneRequiredWithoutWalletNestedInput
    history?: wallet_historyUpdateManyWithoutWalletNestedInput
  }

  export type wallet_userUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    saldo?: IntFieldUpdateOperationsInput | number
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    history?: wallet_historyUncheckedUpdateManyWithoutWalletNestedInput
  }

  export type wallet_userCreateManyInput = {
    id?: number
    user_id: number
    saldo?: number
    updated_at?: Date | string
  }

  export type wallet_userUpdateManyMutationInput = {
    saldo?: IntFieldUpdateOperationsInput | number
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type wallet_userUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    saldo?: IntFieldUpdateOperationsInput | number
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type wallet_historyCreateInput = {
    jumlah: number
    saldo_akhir: number
    tipe: $Enums.wallet_tipe
    transaksi_id?: number | null
    created_at?: Date | string
    wallet: wallet_userCreateNestedOneWithoutHistoryInput
    order?: order_bookingCreateNestedOneWithoutWallet_historiesInput
  }

  export type wallet_historyUncheckedCreateInput = {
    id?: number
    wallet_id: number
    jumlah: number
    saldo_akhir: number
    tipe: $Enums.wallet_tipe
    transaksi_id?: number | null
    order_id?: number | null
    created_at?: Date | string
  }

  export type wallet_historyUpdateInput = {
    jumlah?: IntFieldUpdateOperationsInput | number
    saldo_akhir?: IntFieldUpdateOperationsInput | number
    tipe?: Enumwallet_tipeFieldUpdateOperationsInput | $Enums.wallet_tipe
    transaksi_id?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    wallet?: wallet_userUpdateOneRequiredWithoutHistoryNestedInput
    order?: order_bookingUpdateOneWithoutWallet_historiesNestedInput
  }

  export type wallet_historyUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    wallet_id?: IntFieldUpdateOperationsInput | number
    jumlah?: IntFieldUpdateOperationsInput | number
    saldo_akhir?: IntFieldUpdateOperationsInput | number
    tipe?: Enumwallet_tipeFieldUpdateOperationsInput | $Enums.wallet_tipe
    transaksi_id?: NullableIntFieldUpdateOperationsInput | number | null
    order_id?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type wallet_historyCreateManyInput = {
    id?: number
    wallet_id: number
    jumlah: number
    saldo_akhir: number
    tipe: $Enums.wallet_tipe
    transaksi_id?: number | null
    order_id?: number | null
    created_at?: Date | string
  }

  export type wallet_historyUpdateManyMutationInput = {
    jumlah?: IntFieldUpdateOperationsInput | number
    saldo_akhir?: IntFieldUpdateOperationsInput | number
    tipe?: Enumwallet_tipeFieldUpdateOperationsInput | $Enums.wallet_tipe
    transaksi_id?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type wallet_historyUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    wallet_id?: IntFieldUpdateOperationsInput | number
    jumlah?: IntFieldUpdateOperationsInput | number
    saldo_akhir?: IntFieldUpdateOperationsInput | number
    tipe?: Enumwallet_tipeFieldUpdateOperationsInput | $Enums.wallet_tipe
    transaksi_id?: NullableIntFieldUpdateOperationsInput | number | null
    order_id?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type refundCreateInput = {
    jumlah: Decimal | DecimalJsLike | number | string
    alasan?: string | null
    status?: $Enums.refund_status
    created_at?: Date | string
    processed_at?: Date | string | null
    user: usersCreateNestedOneWithoutRefundInput
    transaksi: transaksiCreateNestedOneWithoutRefundInput
    order: order_bookingCreateNestedOneWithoutRefundInput
  }

  export type refundUncheckedCreateInput = {
    id?: number
    user_id: number
    transaksi_id: number
    order_id: number
    jumlah: Decimal | DecimalJsLike | number | string
    alasan?: string | null
    status?: $Enums.refund_status
    created_at?: Date | string
    processed_at?: Date | string | null
  }

  export type refundUpdateInput = {
    jumlah?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    alasan?: NullableStringFieldUpdateOperationsInput | string | null
    status?: Enumrefund_statusFieldUpdateOperationsInput | $Enums.refund_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    processed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: usersUpdateOneRequiredWithoutRefundNestedInput
    transaksi?: transaksiUpdateOneRequiredWithoutRefundNestedInput
    order?: order_bookingUpdateOneRequiredWithoutRefundNestedInput
  }

  export type refundUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    transaksi_id?: IntFieldUpdateOperationsInput | number
    order_id?: IntFieldUpdateOperationsInput | number
    jumlah?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    alasan?: NullableStringFieldUpdateOperationsInput | string | null
    status?: Enumrefund_statusFieldUpdateOperationsInput | $Enums.refund_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    processed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type refundCreateManyInput = {
    id?: number
    user_id: number
    transaksi_id: number
    order_id: number
    jumlah: Decimal | DecimalJsLike | number | string
    alasan?: string | null
    status?: $Enums.refund_status
    created_at?: Date | string
    processed_at?: Date | string | null
  }

  export type refundUpdateManyMutationInput = {
    jumlah?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    alasan?: NullableStringFieldUpdateOperationsInput | string | null
    status?: Enumrefund_statusFieldUpdateOperationsInput | $Enums.refund_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    processed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type refundUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    transaksi_id?: IntFieldUpdateOperationsInput | number
    order_id?: IntFieldUpdateOperationsInput | number
    jumlah?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    alasan?: NullableStringFieldUpdateOperationsInput | string | null
    status?: Enumrefund_statusFieldUpdateOperationsInput | $Enums.refund_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    processed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type notifikasiCreateInput = {
    pesan: string
    dibaca?: boolean
    created_at?: Date | string
    user: usersCreateNestedOneWithoutNotifikasiInput
  }

  export type notifikasiUncheckedCreateInput = {
    id?: number
    user_id: number
    pesan: string
    dibaca?: boolean
    created_at?: Date | string
  }

  export type notifikasiUpdateInput = {
    pesan?: StringFieldUpdateOperationsInput | string
    dibaca?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: usersUpdateOneRequiredWithoutNotifikasiNestedInput
  }

  export type notifikasiUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    pesan?: StringFieldUpdateOperationsInput | string
    dibaca?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type notifikasiCreateManyInput = {
    id?: number
    user_id: number
    pesan: string
    dibaca?: boolean
    created_at?: Date | string
  }

  export type notifikasiUpdateManyMutationInput = {
    pesan?: StringFieldUpdateOperationsInput | string
    dibaca?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type notifikasiUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    pesan?: StringFieldUpdateOperationsInput | string
    dibaca?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ulasanCreateInput = {
    rating: number
    komentar?: string | null
    created_at?: Date | string
    user: usersCreateNestedOneWithoutUlasanInput
    lapangan: LapanganCreateNestedOneWithoutUlasanInput
  }

  export type ulasanUncheckedCreateInput = {
    id?: number
    user_id: number
    lapangan_id: number
    rating: number
    komentar?: string | null
    created_at?: Date | string
  }

  export type ulasanUpdateInput = {
    rating?: IntFieldUpdateOperationsInput | number
    komentar?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: usersUpdateOneRequiredWithoutUlasanNestedInput
    lapangan?: LapanganUpdateOneRequiredWithoutUlasanNestedInput
  }

  export type ulasanUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    lapangan_id?: IntFieldUpdateOperationsInput | number
    rating?: IntFieldUpdateOperationsInput | number
    komentar?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ulasanCreateManyInput = {
    id?: number
    user_id: number
    lapangan_id: number
    rating: number
    komentar?: string | null
    created_at?: Date | string
  }

  export type ulasanUpdateManyMutationInput = {
    rating?: IntFieldUpdateOperationsInput | number
    komentar?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ulasanUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    lapangan_id?: IntFieldUpdateOperationsInput | number
    rating?: IntFieldUpdateOperationsInput | number
    komentar?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type pendapatan_mitraCreateInput = {
    transaksi_id: number
    jumlah: Decimal | DecimalJsLike | number | string
    created_at?: Date | string
    mitra: MitraCreateNestedOneWithoutPendapatanInput
  }

  export type pendapatan_mitraUncheckedCreateInput = {
    id?: number
    mitra_id: number
    transaksi_id: number
    jumlah: Decimal | DecimalJsLike | number | string
    created_at?: Date | string
  }

  export type pendapatan_mitraUpdateInput = {
    transaksi_id?: IntFieldUpdateOperationsInput | number
    jumlah?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    mitra?: MitraUpdateOneRequiredWithoutPendapatanNestedInput
  }

  export type pendapatan_mitraUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    mitra_id?: IntFieldUpdateOperationsInput | number
    transaksi_id?: IntFieldUpdateOperationsInput | number
    jumlah?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type pendapatan_mitraCreateManyInput = {
    id?: number
    mitra_id: number
    transaksi_id: number
    jumlah: Decimal | DecimalJsLike | number | string
    created_at?: Date | string
  }

  export type pendapatan_mitraUpdateManyMutationInput = {
    transaksi_id?: IntFieldUpdateOperationsInput | number
    jumlah?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type pendapatan_mitraUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    mitra_id?: IntFieldUpdateOperationsInput | number
    transaksi_id?: IntFieldUpdateOperationsInput | number
    jumlah?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type pencairan_pendapatanCreateInput = {
    jumlah: Decimal | DecimalJsLike | number | string
    status?: $Enums.pencairan_status
    created_at?: Date | string
    mitra: MitraCreateNestedOneWithoutPencairanInput
  }

  export type pencairan_pendapatanUncheckedCreateInput = {
    id?: number
    mitra_id: number
    jumlah: Decimal | DecimalJsLike | number | string
    status?: $Enums.pencairan_status
    created_at?: Date | string
  }

  export type pencairan_pendapatanUpdateInput = {
    jumlah?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: Enumpencairan_statusFieldUpdateOperationsInput | $Enums.pencairan_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    mitra?: MitraUpdateOneRequiredWithoutPencairanNestedInput
  }

  export type pencairan_pendapatanUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    mitra_id?: IntFieldUpdateOperationsInput | number
    jumlah?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: Enumpencairan_statusFieldUpdateOperationsInput | $Enums.pencairan_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type pencairan_pendapatanCreateManyInput = {
    id?: number
    mitra_id: number
    jumlah: Decimal | DecimalJsLike | number | string
    status?: $Enums.pencairan_status
    created_at?: Date | string
  }

  export type pencairan_pendapatanUpdateManyMutationInput = {
    jumlah?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: Enumpencairan_statusFieldUpdateOperationsInput | $Enums.pencairan_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type pencairan_pendapatanUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    mitra_id?: IntFieldUpdateOperationsInput | number
    jumlah?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: Enumpencairan_statusFieldUpdateOperationsInput | $Enums.pencairan_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type Enumusers_roleFilter<$PrismaModel = never> = {
    equals?: $Enums.users_role | Enumusers_roleFieldRefInput<$PrismaModel>
    in?: $Enums.users_role[]
    notIn?: $Enums.users_role[]
    not?: NestedEnumusers_roleFilter<$PrismaModel> | $Enums.users_role
  }

  export type Enumusers_statusFilter<$PrismaModel = never> = {
    equals?: $Enums.users_status | Enumusers_statusFieldRefInput<$PrismaModel>
    in?: $Enums.users_status[]
    notIn?: $Enums.users_status[]
    not?: NestedEnumusers_statusFilter<$PrismaModel> | $Enums.users_status
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type MitraNullableRelationFilter = {
    is?: MitraWhereInput | null
    isNot?: MitraWhereInput | null
  }

  export type Order_bookingListRelationFilter = {
    every?: order_bookingWhereInput
    some?: order_bookingWhereInput
    none?: order_bookingWhereInput
  }

  export type TransaksiListRelationFilter = {
    every?: transaksiWhereInput
    some?: transaksiWhereInput
    none?: transaksiWhereInput
  }

  export type NotifikasiListRelationFilter = {
    every?: notifikasiWhereInput
    some?: notifikasiWhereInput
    none?: notifikasiWhereInput
  }

  export type UlasanListRelationFilter = {
    every?: ulasanWhereInput
    some?: ulasanWhereInput
    none?: ulasanWhereInput
  }

  export type Wallet_userNullableRelationFilter = {
    is?: wallet_userWhereInput | null
    isNot?: wallet_userWhereInput | null
  }

  export type RefundListRelationFilter = {
    every?: refundWhereInput
    some?: refundWhereInput
    none?: refundWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type order_bookingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type transaksiOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type notifikasiOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ulasanOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type refundOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type usersCountOrderByAggregateInput = {
    id?: SortOrder
    nama?: SortOrder
    username?: SortOrder
    email?: SortOrder
    password?: SortOrder
    no_hp?: SortOrder
    foto?: SortOrder
    bio?: SortOrder
    role?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type usersAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type usersMaxOrderByAggregateInput = {
    id?: SortOrder
    nama?: SortOrder
    username?: SortOrder
    email?: SortOrder
    password?: SortOrder
    no_hp?: SortOrder
    foto?: SortOrder
    bio?: SortOrder
    role?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type usersMinOrderByAggregateInput = {
    id?: SortOrder
    nama?: SortOrder
    username?: SortOrder
    email?: SortOrder
    password?: SortOrder
    no_hp?: SortOrder
    foto?: SortOrder
    bio?: SortOrder
    role?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type usersSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type Enumusers_roleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.users_role | Enumusers_roleFieldRefInput<$PrismaModel>
    in?: $Enums.users_role[]
    notIn?: $Enums.users_role[]
    not?: NestedEnumusers_roleWithAggregatesFilter<$PrismaModel> | $Enums.users_role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumusers_roleFilter<$PrismaModel>
    _max?: NestedEnumusers_roleFilter<$PrismaModel>
  }

  export type Enumusers_statusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.users_status | Enumusers_statusFieldRefInput<$PrismaModel>
    in?: $Enums.users_status[]
    notIn?: $Enums.users_status[]
    not?: NestedEnumusers_statusWithAggregatesFilter<$PrismaModel> | $Enums.users_status
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumusers_statusFilter<$PrismaModel>
    _max?: NestedEnumusers_statusFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type Enummitra_statusFilter<$PrismaModel = never> = {
    equals?: $Enums.mitra_status | Enummitra_statusFieldRefInput<$PrismaModel>
    in?: $Enums.mitra_status[]
    notIn?: $Enums.mitra_status[]
    not?: NestedEnummitra_statusFilter<$PrismaModel> | $Enums.mitra_status
  }

  export type UsersRelationFilter = {
    is?: usersWhereInput
    isNot?: usersWhereInput
  }

  export type LapanganListRelationFilter = {
    every?: LapanganWhereInput
    some?: LapanganWhereInput
    none?: LapanganWhereInput
  }

  export type Pendapatan_mitraListRelationFilter = {
    every?: pendapatan_mitraWhereInput
    some?: pendapatan_mitraWhereInput
    none?: pendapatan_mitraWhereInput
  }

  export type Pencairan_pendapatanListRelationFilter = {
    every?: pencairan_pendapatanWhereInput
    some?: pencairan_pendapatanWhereInput
    none?: pencairan_pendapatanWhereInput
  }

  export type LapanganOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type pendapatan_mitraOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type pencairan_pendapatanOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MitraCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    nama_usaha?: SortOrder
    alamat_usaha?: SortOrder
    no_ktp?: SortOrder
    foto_ktp?: SortOrder
    withdraw_type?: SortOrder
    withdraw_day?: SortOrder
    bank_mitra?: SortOrder
    no_rekening_mitra?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
  }

  export type MitraAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    withdraw_day?: SortOrder
  }

  export type MitraMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    nama_usaha?: SortOrder
    alamat_usaha?: SortOrder
    no_ktp?: SortOrder
    foto_ktp?: SortOrder
    withdraw_type?: SortOrder
    withdraw_day?: SortOrder
    bank_mitra?: SortOrder
    no_rekening_mitra?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
  }

  export type MitraMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    nama_usaha?: SortOrder
    alamat_usaha?: SortOrder
    no_ktp?: SortOrder
    foto_ktp?: SortOrder
    withdraw_type?: SortOrder
    withdraw_day?: SortOrder
    bank_mitra?: SortOrder
    no_rekening_mitra?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
  }

  export type MitraSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    withdraw_day?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type Enummitra_statusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.mitra_status | Enummitra_statusFieldRefInput<$PrismaModel>
    in?: $Enums.mitra_status[]
    notIn?: $Enums.mitra_status[]
    not?: NestedEnummitra_statusWithAggregatesFilter<$PrismaModel> | $Enums.mitra_status
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnummitra_statusFilter<$PrismaModel>
    _max?: NestedEnummitra_statusFilter<$PrismaModel>
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type otp_codesCountOrderByAggregateInput = {
    id?: SortOrder
    user_email?: SortOrder
    kode_otp?: SortOrder
    expired_at?: SortOrder
    digunakan?: SortOrder
    created_at?: SortOrder
  }

  export type otp_codesAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type otp_codesMaxOrderByAggregateInput = {
    id?: SortOrder
    user_email?: SortOrder
    kode_otp?: SortOrder
    expired_at?: SortOrder
    digunakan?: SortOrder
    created_at?: SortOrder
  }

  export type otp_codesMinOrderByAggregateInput = {
    id?: SortOrder
    user_email?: SortOrder
    kode_otp?: SortOrder
    expired_at?: SortOrder
    digunakan?: SortOrder
    created_at?: SortOrder
  }

  export type otp_codesSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type Enumlapangan_statusFilter<$PrismaModel = never> = {
    equals?: $Enums.lapangan_status | Enumlapangan_statusFieldRefInput<$PrismaModel>
    in?: $Enums.lapangan_status[]
    notIn?: $Enums.lapangan_status[]
    not?: NestedEnumlapangan_statusFilter<$PrismaModel> | $Enums.lapangan_status
  }

  export type MitraRelationFilter = {
    is?: MitraWhereInput
    isNot?: MitraWhereInput
  }

  export type LapanganDetailNullableRelationFilter = {
    is?: LapanganDetailWhereInput | null
    isNot?: LapanganDetailWhereInput | null
  }

  export type LapanganGambarListRelationFilter = {
    every?: LapanganGambarWhereInput
    some?: LapanganGambarWhereInput
    none?: LapanganGambarWhereInput
  }

  export type JadwalLapanganListRelationFilter = {
    every?: JadwalLapanganWhereInput
    some?: JadwalLapanganWhereInput
    none?: JadwalLapanganWhereInput
  }

  export type LapanganGambarOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type JadwalLapanganOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LapanganCountOrderByAggregateInput = {
    id?: SortOrder
    mitra_id?: SortOrder
    nama?: SortOrder
    slug?: SortOrder
    lokasi?: SortOrder
    harga?: SortOrder
    gambar?: SortOrder
    rating?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
  }

  export type LapanganAvgOrderByAggregateInput = {
    id?: SortOrder
    mitra_id?: SortOrder
    harga?: SortOrder
    rating?: SortOrder
  }

  export type LapanganMaxOrderByAggregateInput = {
    id?: SortOrder
    mitra_id?: SortOrder
    nama?: SortOrder
    slug?: SortOrder
    lokasi?: SortOrder
    harga?: SortOrder
    gambar?: SortOrder
    rating?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
  }

  export type LapanganMinOrderByAggregateInput = {
    id?: SortOrder
    mitra_id?: SortOrder
    nama?: SortOrder
    slug?: SortOrder
    lokasi?: SortOrder
    harga?: SortOrder
    gambar?: SortOrder
    rating?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
  }

  export type LapanganSumOrderByAggregateInput = {
    id?: SortOrder
    mitra_id?: SortOrder
    harga?: SortOrder
    rating?: SortOrder
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type Enumlapangan_statusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.lapangan_status | Enumlapangan_statusFieldRefInput<$PrismaModel>
    in?: $Enums.lapangan_status[]
    notIn?: $Enums.lapangan_status[]
    not?: NestedEnumlapangan_statusWithAggregatesFilter<$PrismaModel> | $Enums.lapangan_status
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumlapangan_statusFilter<$PrismaModel>
    _max?: NestedEnumlapangan_statusFilter<$PrismaModel>
  }
  export type JsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type LapanganRelationFilter = {
    is?: LapanganWhereInput
    isNot?: LapanganWhereInput
  }

  export type LapanganDetailCountOrderByAggregateInput = {
    id?: SortOrder
    lapangan_id?: SortOrder
    alamat?: SortOrder
    maps?: SortOrder
    deskripsi?: SortOrder
    type?: SortOrder
    fasilitas?: SortOrder
    interval?: SortOrder
    breakTime?: SortOrder
  }

  export type LapanganDetailAvgOrderByAggregateInput = {
    id?: SortOrder
    lapangan_id?: SortOrder
    interval?: SortOrder
    breakTime?: SortOrder
  }

  export type LapanganDetailMaxOrderByAggregateInput = {
    id?: SortOrder
    lapangan_id?: SortOrder
    alamat?: SortOrder
    maps?: SortOrder
    deskripsi?: SortOrder
    type?: SortOrder
    interval?: SortOrder
    breakTime?: SortOrder
  }

  export type LapanganDetailMinOrderByAggregateInput = {
    id?: SortOrder
    lapangan_id?: SortOrder
    alamat?: SortOrder
    maps?: SortOrder
    deskripsi?: SortOrder
    type?: SortOrder
    interval?: SortOrder
    breakTime?: SortOrder
  }

  export type LapanganDetailSumOrderByAggregateInput = {
    id?: SortOrder
    lapangan_id?: SortOrder
    interval?: SortOrder
    breakTime?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type LapanganGambarCountOrderByAggregateInput = {
    id?: SortOrder
    lapangan_id?: SortOrder
    file_name?: SortOrder
    created_at?: SortOrder
  }

  export type LapanganGambarAvgOrderByAggregateInput = {
    id?: SortOrder
    lapangan_id?: SortOrder
  }

  export type LapanganGambarMaxOrderByAggregateInput = {
    id?: SortOrder
    lapangan_id?: SortOrder
    file_name?: SortOrder
    created_at?: SortOrder
  }

  export type LapanganGambarMinOrderByAggregateInput = {
    id?: SortOrder
    lapangan_id?: SortOrder
    file_name?: SortOrder
    created_at?: SortOrder
  }

  export type LapanganGambarSumOrderByAggregateInput = {
    id?: SortOrder
    lapangan_id?: SortOrder
  }

  export type Enumjadwal_statusFilter<$PrismaModel = never> = {
    equals?: $Enums.jadwal_status | Enumjadwal_statusFieldRefInput<$PrismaModel>
    in?: $Enums.jadwal_status[]
    notIn?: $Enums.jadwal_status[]
    not?: NestedEnumjadwal_statusFilter<$PrismaModel> | $Enums.jadwal_status
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type JadwalLapanganLapangan_idTanggalSlotCompoundUniqueInput = {
    lapangan_id: number
    tanggal: Date | string
    slot: string
  }

  export type JadwalLapanganCountOrderByAggregateInput = {
    id?: SortOrder
    lapangan_id?: SortOrder
    tanggal?: SortOrder
    slot?: SortOrder
    status?: SortOrder
    locked_until?: SortOrder
  }

  export type JadwalLapanganAvgOrderByAggregateInput = {
    id?: SortOrder
    lapangan_id?: SortOrder
  }

  export type JadwalLapanganMaxOrderByAggregateInput = {
    id?: SortOrder
    lapangan_id?: SortOrder
    tanggal?: SortOrder
    slot?: SortOrder
    status?: SortOrder
    locked_until?: SortOrder
  }

  export type JadwalLapanganMinOrderByAggregateInput = {
    id?: SortOrder
    lapangan_id?: SortOrder
    tanggal?: SortOrder
    slot?: SortOrder
    status?: SortOrder
    locked_until?: SortOrder
  }

  export type JadwalLapanganSumOrderByAggregateInput = {
    id?: SortOrder
    lapangan_id?: SortOrder
  }

  export type Enumjadwal_statusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.jadwal_status | Enumjadwal_statusFieldRefInput<$PrismaModel>
    in?: $Enums.jadwal_status[]
    notIn?: $Enums.jadwal_status[]
    not?: NestedEnumjadwal_statusWithAggregatesFilter<$PrismaModel> | $Enums.jadwal_status
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumjadwal_statusFilter<$PrismaModel>
    _max?: NestedEnumjadwal_statusFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type JadwalLapanganRelationFilter = {
    is?: JadwalLapanganWhereInput
    isNot?: JadwalLapanganWhereInput
  }

  export type TransaksiNullableRelationFilter = {
    is?: transaksiWhereInput | null
    isNot?: transaksiWhereInput | null
  }

  export type RefundNullableRelationFilter = {
    is?: refundWhereInput | null
    isNot?: refundWhereInput | null
  }

  export type Wallet_historyListRelationFilter = {
    every?: wallet_historyWhereInput
    some?: wallet_historyWhereInput
    none?: wallet_historyWhereInput
  }

  export type wallet_historyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type order_bookingCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    lapangan_id?: SortOrder
    jadwalLapanganId?: SortOrder
    tanggal?: SortOrder
    jam_mulai?: SortOrder
    jam_selesai?: SortOrder
    total_harga?: SortOrder
    status?: SortOrder
    sewa_raket?: SortOrder
    biaya_raket?: SortOrder
    created_at?: SortOrder
    expired_at?: SortOrder
  }

  export type order_bookingAvgOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    lapangan_id?: SortOrder
    jadwalLapanganId?: SortOrder
    total_harga?: SortOrder
    biaya_raket?: SortOrder
  }

  export type order_bookingMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    lapangan_id?: SortOrder
    jadwalLapanganId?: SortOrder
    tanggal?: SortOrder
    jam_mulai?: SortOrder
    jam_selesai?: SortOrder
    total_harga?: SortOrder
    status?: SortOrder
    sewa_raket?: SortOrder
    biaya_raket?: SortOrder
    created_at?: SortOrder
    expired_at?: SortOrder
  }

  export type order_bookingMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    lapangan_id?: SortOrder
    jadwalLapanganId?: SortOrder
    tanggal?: SortOrder
    jam_mulai?: SortOrder
    jam_selesai?: SortOrder
    total_harga?: SortOrder
    status?: SortOrder
    sewa_raket?: SortOrder
    biaya_raket?: SortOrder
    created_at?: SortOrder
    expired_at?: SortOrder
  }

  export type order_bookingSumOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    lapangan_id?: SortOrder
    jadwalLapanganId?: SortOrder
    total_harga?: SortOrder
    biaya_raket?: SortOrder
  }

  export type Enumtransaksi_status_pembayaranFilter<$PrismaModel = never> = {
    equals?: $Enums.transaksi_status_pembayaran | Enumtransaksi_status_pembayaranFieldRefInput<$PrismaModel>
    in?: $Enums.transaksi_status_pembayaran[]
    notIn?: $Enums.transaksi_status_pembayaran[]
    not?: NestedEnumtransaksi_status_pembayaranFilter<$PrismaModel> | $Enums.transaksi_status_pembayaran
  }

  export type Order_bookingNullableRelationFilter = {
    is?: order_bookingWhereInput | null
    isNot?: order_bookingWhereInput | null
  }

  export type Sewa_raketListRelationFilter = {
    every?: sewa_raketWhereInput
    some?: sewa_raketWhereInput
    none?: sewa_raketWhereInput
  }

  export type sewa_raketOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type transaksiCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    lapangan_id?: SortOrder
    jadwal_id?: SortOrder
    order_id?: SortOrder
    total_harga?: SortOrder
    status_pembayaran?: SortOrder
    created_at?: SortOrder
  }

  export type transaksiAvgOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    lapangan_id?: SortOrder
    jadwal_id?: SortOrder
    order_id?: SortOrder
    total_harga?: SortOrder
  }

  export type transaksiMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    lapangan_id?: SortOrder
    jadwal_id?: SortOrder
    order_id?: SortOrder
    total_harga?: SortOrder
    status_pembayaran?: SortOrder
    created_at?: SortOrder
  }

  export type transaksiMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    lapangan_id?: SortOrder
    jadwal_id?: SortOrder
    order_id?: SortOrder
    total_harga?: SortOrder
    status_pembayaran?: SortOrder
    created_at?: SortOrder
  }

  export type transaksiSumOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    lapangan_id?: SortOrder
    jadwal_id?: SortOrder
    order_id?: SortOrder
    total_harga?: SortOrder
  }

  export type Enumtransaksi_status_pembayaranWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.transaksi_status_pembayaran | Enumtransaksi_status_pembayaranFieldRefInput<$PrismaModel>
    in?: $Enums.transaksi_status_pembayaran[]
    notIn?: $Enums.transaksi_status_pembayaran[]
    not?: NestedEnumtransaksi_status_pembayaranWithAggregatesFilter<$PrismaModel> | $Enums.transaksi_status_pembayaran
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumtransaksi_status_pembayaranFilter<$PrismaModel>
    _max?: NestedEnumtransaksi_status_pembayaranFilter<$PrismaModel>
  }

  export type raket_padelCountOrderByAggregateInput = {
    id?: SortOrder
    nama?: SortOrder
    harga?: SortOrder
  }

  export type raket_padelAvgOrderByAggregateInput = {
    id?: SortOrder
    harga?: SortOrder
  }

  export type raket_padelMaxOrderByAggregateInput = {
    id?: SortOrder
    nama?: SortOrder
    harga?: SortOrder
  }

  export type raket_padelMinOrderByAggregateInput = {
    id?: SortOrder
    nama?: SortOrder
    harga?: SortOrder
  }

  export type raket_padelSumOrderByAggregateInput = {
    id?: SortOrder
    harga?: SortOrder
  }

  export type TransaksiRelationFilter = {
    is?: transaksiWhereInput
    isNot?: transaksiWhereInput
  }

  export type Raket_padelRelationFilter = {
    is?: raket_padelWhereInput
    isNot?: raket_padelWhereInput
  }

  export type sewa_raketCountOrderByAggregateInput = {
    id?: SortOrder
    transaksi_id?: SortOrder
    raket_id?: SortOrder
    jumlah?: SortOrder
    total_harga?: SortOrder
  }

  export type sewa_raketAvgOrderByAggregateInput = {
    id?: SortOrder
    transaksi_id?: SortOrder
    raket_id?: SortOrder
    jumlah?: SortOrder
    total_harga?: SortOrder
  }

  export type sewa_raketMaxOrderByAggregateInput = {
    id?: SortOrder
    transaksi_id?: SortOrder
    raket_id?: SortOrder
    jumlah?: SortOrder
    total_harga?: SortOrder
  }

  export type sewa_raketMinOrderByAggregateInput = {
    id?: SortOrder
    transaksi_id?: SortOrder
    raket_id?: SortOrder
    jumlah?: SortOrder
    total_harga?: SortOrder
  }

  export type sewa_raketSumOrderByAggregateInput = {
    id?: SortOrder
    transaksi_id?: SortOrder
    raket_id?: SortOrder
    jumlah?: SortOrder
    total_harga?: SortOrder
  }

  export type wallet_userCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    saldo?: SortOrder
    updated_at?: SortOrder
  }

  export type wallet_userAvgOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    saldo?: SortOrder
  }

  export type wallet_userMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    saldo?: SortOrder
    updated_at?: SortOrder
  }

  export type wallet_userMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    saldo?: SortOrder
    updated_at?: SortOrder
  }

  export type wallet_userSumOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    saldo?: SortOrder
  }

  export type Enumwallet_tipeFilter<$PrismaModel = never> = {
    equals?: $Enums.wallet_tipe | Enumwallet_tipeFieldRefInput<$PrismaModel>
    in?: $Enums.wallet_tipe[]
    notIn?: $Enums.wallet_tipe[]
    not?: NestedEnumwallet_tipeFilter<$PrismaModel> | $Enums.wallet_tipe
  }

  export type Wallet_userRelationFilter = {
    is?: wallet_userWhereInput
    isNot?: wallet_userWhereInput
  }

  export type wallet_historyCountOrderByAggregateInput = {
    id?: SortOrder
    wallet_id?: SortOrder
    jumlah?: SortOrder
    saldo_akhir?: SortOrder
    tipe?: SortOrder
    transaksi_id?: SortOrder
    order_id?: SortOrder
    created_at?: SortOrder
  }

  export type wallet_historyAvgOrderByAggregateInput = {
    id?: SortOrder
    wallet_id?: SortOrder
    jumlah?: SortOrder
    saldo_akhir?: SortOrder
    transaksi_id?: SortOrder
    order_id?: SortOrder
  }

  export type wallet_historyMaxOrderByAggregateInput = {
    id?: SortOrder
    wallet_id?: SortOrder
    jumlah?: SortOrder
    saldo_akhir?: SortOrder
    tipe?: SortOrder
    transaksi_id?: SortOrder
    order_id?: SortOrder
    created_at?: SortOrder
  }

  export type wallet_historyMinOrderByAggregateInput = {
    id?: SortOrder
    wallet_id?: SortOrder
    jumlah?: SortOrder
    saldo_akhir?: SortOrder
    tipe?: SortOrder
    transaksi_id?: SortOrder
    order_id?: SortOrder
    created_at?: SortOrder
  }

  export type wallet_historySumOrderByAggregateInput = {
    id?: SortOrder
    wallet_id?: SortOrder
    jumlah?: SortOrder
    saldo_akhir?: SortOrder
    transaksi_id?: SortOrder
    order_id?: SortOrder
  }

  export type Enumwallet_tipeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.wallet_tipe | Enumwallet_tipeFieldRefInput<$PrismaModel>
    in?: $Enums.wallet_tipe[]
    notIn?: $Enums.wallet_tipe[]
    not?: NestedEnumwallet_tipeWithAggregatesFilter<$PrismaModel> | $Enums.wallet_tipe
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumwallet_tipeFilter<$PrismaModel>
    _max?: NestedEnumwallet_tipeFilter<$PrismaModel>
  }

  export type Enumrefund_statusFilter<$PrismaModel = never> = {
    equals?: $Enums.refund_status | Enumrefund_statusFieldRefInput<$PrismaModel>
    in?: $Enums.refund_status[]
    notIn?: $Enums.refund_status[]
    not?: NestedEnumrefund_statusFilter<$PrismaModel> | $Enums.refund_status
  }

  export type Order_bookingRelationFilter = {
    is?: order_bookingWhereInput
    isNot?: order_bookingWhereInput
  }

  export type refundCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    transaksi_id?: SortOrder
    order_id?: SortOrder
    jumlah?: SortOrder
    alasan?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    processed_at?: SortOrder
  }

  export type refundAvgOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    transaksi_id?: SortOrder
    order_id?: SortOrder
    jumlah?: SortOrder
  }

  export type refundMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    transaksi_id?: SortOrder
    order_id?: SortOrder
    jumlah?: SortOrder
    alasan?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    processed_at?: SortOrder
  }

  export type refundMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    transaksi_id?: SortOrder
    order_id?: SortOrder
    jumlah?: SortOrder
    alasan?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    processed_at?: SortOrder
  }

  export type refundSumOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    transaksi_id?: SortOrder
    order_id?: SortOrder
    jumlah?: SortOrder
  }

  export type Enumrefund_statusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.refund_status | Enumrefund_statusFieldRefInput<$PrismaModel>
    in?: $Enums.refund_status[]
    notIn?: $Enums.refund_status[]
    not?: NestedEnumrefund_statusWithAggregatesFilter<$PrismaModel> | $Enums.refund_status
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumrefund_statusFilter<$PrismaModel>
    _max?: NestedEnumrefund_statusFilter<$PrismaModel>
  }

  export type notifikasiCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    pesan?: SortOrder
    dibaca?: SortOrder
    created_at?: SortOrder
  }

  export type notifikasiAvgOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
  }

  export type notifikasiMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    pesan?: SortOrder
    dibaca?: SortOrder
    created_at?: SortOrder
  }

  export type notifikasiMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    pesan?: SortOrder
    dibaca?: SortOrder
    created_at?: SortOrder
  }

  export type notifikasiSumOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
  }

  export type ulasanCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    lapangan_id?: SortOrder
    rating?: SortOrder
    komentar?: SortOrder
    created_at?: SortOrder
  }

  export type ulasanAvgOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    lapangan_id?: SortOrder
    rating?: SortOrder
  }

  export type ulasanMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    lapangan_id?: SortOrder
    rating?: SortOrder
    komentar?: SortOrder
    created_at?: SortOrder
  }

  export type ulasanMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    lapangan_id?: SortOrder
    rating?: SortOrder
    komentar?: SortOrder
    created_at?: SortOrder
  }

  export type ulasanSumOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    lapangan_id?: SortOrder
    rating?: SortOrder
  }

  export type pendapatan_mitraCountOrderByAggregateInput = {
    id?: SortOrder
    mitra_id?: SortOrder
    transaksi_id?: SortOrder
    jumlah?: SortOrder
    created_at?: SortOrder
  }

  export type pendapatan_mitraAvgOrderByAggregateInput = {
    id?: SortOrder
    mitra_id?: SortOrder
    transaksi_id?: SortOrder
    jumlah?: SortOrder
  }

  export type pendapatan_mitraMaxOrderByAggregateInput = {
    id?: SortOrder
    mitra_id?: SortOrder
    transaksi_id?: SortOrder
    jumlah?: SortOrder
    created_at?: SortOrder
  }

  export type pendapatan_mitraMinOrderByAggregateInput = {
    id?: SortOrder
    mitra_id?: SortOrder
    transaksi_id?: SortOrder
    jumlah?: SortOrder
    created_at?: SortOrder
  }

  export type pendapatan_mitraSumOrderByAggregateInput = {
    id?: SortOrder
    mitra_id?: SortOrder
    transaksi_id?: SortOrder
    jumlah?: SortOrder
  }

  export type Enumpencairan_statusFilter<$PrismaModel = never> = {
    equals?: $Enums.pencairan_status | Enumpencairan_statusFieldRefInput<$PrismaModel>
    in?: $Enums.pencairan_status[]
    notIn?: $Enums.pencairan_status[]
    not?: NestedEnumpencairan_statusFilter<$PrismaModel> | $Enums.pencairan_status
  }

  export type pencairan_pendapatanCountOrderByAggregateInput = {
    id?: SortOrder
    mitra_id?: SortOrder
    jumlah?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
  }

  export type pencairan_pendapatanAvgOrderByAggregateInput = {
    id?: SortOrder
    mitra_id?: SortOrder
    jumlah?: SortOrder
  }

  export type pencairan_pendapatanMaxOrderByAggregateInput = {
    id?: SortOrder
    mitra_id?: SortOrder
    jumlah?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
  }

  export type pencairan_pendapatanMinOrderByAggregateInput = {
    id?: SortOrder
    mitra_id?: SortOrder
    jumlah?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
  }

  export type pencairan_pendapatanSumOrderByAggregateInput = {
    id?: SortOrder
    mitra_id?: SortOrder
    jumlah?: SortOrder
  }

  export type Enumpencairan_statusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.pencairan_status | Enumpencairan_statusFieldRefInput<$PrismaModel>
    in?: $Enums.pencairan_status[]
    notIn?: $Enums.pencairan_status[]
    not?: NestedEnumpencairan_statusWithAggregatesFilter<$PrismaModel> | $Enums.pencairan_status
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumpencairan_statusFilter<$PrismaModel>
    _max?: NestedEnumpencairan_statusFilter<$PrismaModel>
  }

  export type MitraCreateNestedOneWithoutUserInput = {
    create?: XOR<MitraCreateWithoutUserInput, MitraUncheckedCreateWithoutUserInput>
    connectOrCreate?: MitraCreateOrConnectWithoutUserInput
    connect?: MitraWhereUniqueInput
  }

  export type order_bookingCreateNestedManyWithoutUserInput = {
    create?: XOR<order_bookingCreateWithoutUserInput, order_bookingUncheckedCreateWithoutUserInput> | order_bookingCreateWithoutUserInput[] | order_bookingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: order_bookingCreateOrConnectWithoutUserInput | order_bookingCreateOrConnectWithoutUserInput[]
    createMany?: order_bookingCreateManyUserInputEnvelope
    connect?: order_bookingWhereUniqueInput | order_bookingWhereUniqueInput[]
  }

  export type transaksiCreateNestedManyWithoutUserInput = {
    create?: XOR<transaksiCreateWithoutUserInput, transaksiUncheckedCreateWithoutUserInput> | transaksiCreateWithoutUserInput[] | transaksiUncheckedCreateWithoutUserInput[]
    connectOrCreate?: transaksiCreateOrConnectWithoutUserInput | transaksiCreateOrConnectWithoutUserInput[]
    createMany?: transaksiCreateManyUserInputEnvelope
    connect?: transaksiWhereUniqueInput | transaksiWhereUniqueInput[]
  }

  export type notifikasiCreateNestedManyWithoutUserInput = {
    create?: XOR<notifikasiCreateWithoutUserInput, notifikasiUncheckedCreateWithoutUserInput> | notifikasiCreateWithoutUserInput[] | notifikasiUncheckedCreateWithoutUserInput[]
    connectOrCreate?: notifikasiCreateOrConnectWithoutUserInput | notifikasiCreateOrConnectWithoutUserInput[]
    createMany?: notifikasiCreateManyUserInputEnvelope
    connect?: notifikasiWhereUniqueInput | notifikasiWhereUniqueInput[]
  }

  export type ulasanCreateNestedManyWithoutUserInput = {
    create?: XOR<ulasanCreateWithoutUserInput, ulasanUncheckedCreateWithoutUserInput> | ulasanCreateWithoutUserInput[] | ulasanUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ulasanCreateOrConnectWithoutUserInput | ulasanCreateOrConnectWithoutUserInput[]
    createMany?: ulasanCreateManyUserInputEnvelope
    connect?: ulasanWhereUniqueInput | ulasanWhereUniqueInput[]
  }

  export type wallet_userCreateNestedOneWithoutUserInput = {
    create?: XOR<wallet_userCreateWithoutUserInput, wallet_userUncheckedCreateWithoutUserInput>
    connectOrCreate?: wallet_userCreateOrConnectWithoutUserInput
    connect?: wallet_userWhereUniqueInput
  }

  export type refundCreateNestedManyWithoutUserInput = {
    create?: XOR<refundCreateWithoutUserInput, refundUncheckedCreateWithoutUserInput> | refundCreateWithoutUserInput[] | refundUncheckedCreateWithoutUserInput[]
    connectOrCreate?: refundCreateOrConnectWithoutUserInput | refundCreateOrConnectWithoutUserInput[]
    createMany?: refundCreateManyUserInputEnvelope
    connect?: refundWhereUniqueInput | refundWhereUniqueInput[]
  }

  export type MitraUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<MitraCreateWithoutUserInput, MitraUncheckedCreateWithoutUserInput>
    connectOrCreate?: MitraCreateOrConnectWithoutUserInput
    connect?: MitraWhereUniqueInput
  }

  export type order_bookingUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<order_bookingCreateWithoutUserInput, order_bookingUncheckedCreateWithoutUserInput> | order_bookingCreateWithoutUserInput[] | order_bookingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: order_bookingCreateOrConnectWithoutUserInput | order_bookingCreateOrConnectWithoutUserInput[]
    createMany?: order_bookingCreateManyUserInputEnvelope
    connect?: order_bookingWhereUniqueInput | order_bookingWhereUniqueInput[]
  }

  export type transaksiUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<transaksiCreateWithoutUserInput, transaksiUncheckedCreateWithoutUserInput> | transaksiCreateWithoutUserInput[] | transaksiUncheckedCreateWithoutUserInput[]
    connectOrCreate?: transaksiCreateOrConnectWithoutUserInput | transaksiCreateOrConnectWithoutUserInput[]
    createMany?: transaksiCreateManyUserInputEnvelope
    connect?: transaksiWhereUniqueInput | transaksiWhereUniqueInput[]
  }

  export type notifikasiUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<notifikasiCreateWithoutUserInput, notifikasiUncheckedCreateWithoutUserInput> | notifikasiCreateWithoutUserInput[] | notifikasiUncheckedCreateWithoutUserInput[]
    connectOrCreate?: notifikasiCreateOrConnectWithoutUserInput | notifikasiCreateOrConnectWithoutUserInput[]
    createMany?: notifikasiCreateManyUserInputEnvelope
    connect?: notifikasiWhereUniqueInput | notifikasiWhereUniqueInput[]
  }

  export type ulasanUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ulasanCreateWithoutUserInput, ulasanUncheckedCreateWithoutUserInput> | ulasanCreateWithoutUserInput[] | ulasanUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ulasanCreateOrConnectWithoutUserInput | ulasanCreateOrConnectWithoutUserInput[]
    createMany?: ulasanCreateManyUserInputEnvelope
    connect?: ulasanWhereUniqueInput | ulasanWhereUniqueInput[]
  }

  export type wallet_userUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<wallet_userCreateWithoutUserInput, wallet_userUncheckedCreateWithoutUserInput>
    connectOrCreate?: wallet_userCreateOrConnectWithoutUserInput
    connect?: wallet_userWhereUniqueInput
  }

  export type refundUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<refundCreateWithoutUserInput, refundUncheckedCreateWithoutUserInput> | refundCreateWithoutUserInput[] | refundUncheckedCreateWithoutUserInput[]
    connectOrCreate?: refundCreateOrConnectWithoutUserInput | refundCreateOrConnectWithoutUserInput[]
    createMany?: refundCreateManyUserInputEnvelope
    connect?: refundWhereUniqueInput | refundWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type Enumusers_roleFieldUpdateOperationsInput = {
    set?: $Enums.users_role
  }

  export type Enumusers_statusFieldUpdateOperationsInput = {
    set?: $Enums.users_status
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type MitraUpdateOneWithoutUserNestedInput = {
    create?: XOR<MitraCreateWithoutUserInput, MitraUncheckedCreateWithoutUserInput>
    connectOrCreate?: MitraCreateOrConnectWithoutUserInput
    upsert?: MitraUpsertWithoutUserInput
    disconnect?: MitraWhereInput | boolean
    delete?: MitraWhereInput | boolean
    connect?: MitraWhereUniqueInput
    update?: XOR<XOR<MitraUpdateToOneWithWhereWithoutUserInput, MitraUpdateWithoutUserInput>, MitraUncheckedUpdateWithoutUserInput>
  }

  export type order_bookingUpdateManyWithoutUserNestedInput = {
    create?: XOR<order_bookingCreateWithoutUserInput, order_bookingUncheckedCreateWithoutUserInput> | order_bookingCreateWithoutUserInput[] | order_bookingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: order_bookingCreateOrConnectWithoutUserInput | order_bookingCreateOrConnectWithoutUserInput[]
    upsert?: order_bookingUpsertWithWhereUniqueWithoutUserInput | order_bookingUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: order_bookingCreateManyUserInputEnvelope
    set?: order_bookingWhereUniqueInput | order_bookingWhereUniqueInput[]
    disconnect?: order_bookingWhereUniqueInput | order_bookingWhereUniqueInput[]
    delete?: order_bookingWhereUniqueInput | order_bookingWhereUniqueInput[]
    connect?: order_bookingWhereUniqueInput | order_bookingWhereUniqueInput[]
    update?: order_bookingUpdateWithWhereUniqueWithoutUserInput | order_bookingUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: order_bookingUpdateManyWithWhereWithoutUserInput | order_bookingUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: order_bookingScalarWhereInput | order_bookingScalarWhereInput[]
  }

  export type transaksiUpdateManyWithoutUserNestedInput = {
    create?: XOR<transaksiCreateWithoutUserInput, transaksiUncheckedCreateWithoutUserInput> | transaksiCreateWithoutUserInput[] | transaksiUncheckedCreateWithoutUserInput[]
    connectOrCreate?: transaksiCreateOrConnectWithoutUserInput | transaksiCreateOrConnectWithoutUserInput[]
    upsert?: transaksiUpsertWithWhereUniqueWithoutUserInput | transaksiUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: transaksiCreateManyUserInputEnvelope
    set?: transaksiWhereUniqueInput | transaksiWhereUniqueInput[]
    disconnect?: transaksiWhereUniqueInput | transaksiWhereUniqueInput[]
    delete?: transaksiWhereUniqueInput | transaksiWhereUniqueInput[]
    connect?: transaksiWhereUniqueInput | transaksiWhereUniqueInput[]
    update?: transaksiUpdateWithWhereUniqueWithoutUserInput | transaksiUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: transaksiUpdateManyWithWhereWithoutUserInput | transaksiUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: transaksiScalarWhereInput | transaksiScalarWhereInput[]
  }

  export type notifikasiUpdateManyWithoutUserNestedInput = {
    create?: XOR<notifikasiCreateWithoutUserInput, notifikasiUncheckedCreateWithoutUserInput> | notifikasiCreateWithoutUserInput[] | notifikasiUncheckedCreateWithoutUserInput[]
    connectOrCreate?: notifikasiCreateOrConnectWithoutUserInput | notifikasiCreateOrConnectWithoutUserInput[]
    upsert?: notifikasiUpsertWithWhereUniqueWithoutUserInput | notifikasiUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: notifikasiCreateManyUserInputEnvelope
    set?: notifikasiWhereUniqueInput | notifikasiWhereUniqueInput[]
    disconnect?: notifikasiWhereUniqueInput | notifikasiWhereUniqueInput[]
    delete?: notifikasiWhereUniqueInput | notifikasiWhereUniqueInput[]
    connect?: notifikasiWhereUniqueInput | notifikasiWhereUniqueInput[]
    update?: notifikasiUpdateWithWhereUniqueWithoutUserInput | notifikasiUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: notifikasiUpdateManyWithWhereWithoutUserInput | notifikasiUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: notifikasiScalarWhereInput | notifikasiScalarWhereInput[]
  }

  export type ulasanUpdateManyWithoutUserNestedInput = {
    create?: XOR<ulasanCreateWithoutUserInput, ulasanUncheckedCreateWithoutUserInput> | ulasanCreateWithoutUserInput[] | ulasanUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ulasanCreateOrConnectWithoutUserInput | ulasanCreateOrConnectWithoutUserInput[]
    upsert?: ulasanUpsertWithWhereUniqueWithoutUserInput | ulasanUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ulasanCreateManyUserInputEnvelope
    set?: ulasanWhereUniqueInput | ulasanWhereUniqueInput[]
    disconnect?: ulasanWhereUniqueInput | ulasanWhereUniqueInput[]
    delete?: ulasanWhereUniqueInput | ulasanWhereUniqueInput[]
    connect?: ulasanWhereUniqueInput | ulasanWhereUniqueInput[]
    update?: ulasanUpdateWithWhereUniqueWithoutUserInput | ulasanUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ulasanUpdateManyWithWhereWithoutUserInput | ulasanUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ulasanScalarWhereInput | ulasanScalarWhereInput[]
  }

  export type wallet_userUpdateOneWithoutUserNestedInput = {
    create?: XOR<wallet_userCreateWithoutUserInput, wallet_userUncheckedCreateWithoutUserInput>
    connectOrCreate?: wallet_userCreateOrConnectWithoutUserInput
    upsert?: wallet_userUpsertWithoutUserInput
    disconnect?: wallet_userWhereInput | boolean
    delete?: wallet_userWhereInput | boolean
    connect?: wallet_userWhereUniqueInput
    update?: XOR<XOR<wallet_userUpdateToOneWithWhereWithoutUserInput, wallet_userUpdateWithoutUserInput>, wallet_userUncheckedUpdateWithoutUserInput>
  }

  export type refundUpdateManyWithoutUserNestedInput = {
    create?: XOR<refundCreateWithoutUserInput, refundUncheckedCreateWithoutUserInput> | refundCreateWithoutUserInput[] | refundUncheckedCreateWithoutUserInput[]
    connectOrCreate?: refundCreateOrConnectWithoutUserInput | refundCreateOrConnectWithoutUserInput[]
    upsert?: refundUpsertWithWhereUniqueWithoutUserInput | refundUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: refundCreateManyUserInputEnvelope
    set?: refundWhereUniqueInput | refundWhereUniqueInput[]
    disconnect?: refundWhereUniqueInput | refundWhereUniqueInput[]
    delete?: refundWhereUniqueInput | refundWhereUniqueInput[]
    connect?: refundWhereUniqueInput | refundWhereUniqueInput[]
    update?: refundUpdateWithWhereUniqueWithoutUserInput | refundUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: refundUpdateManyWithWhereWithoutUserInput | refundUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: refundScalarWhereInput | refundScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type MitraUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<MitraCreateWithoutUserInput, MitraUncheckedCreateWithoutUserInput>
    connectOrCreate?: MitraCreateOrConnectWithoutUserInput
    upsert?: MitraUpsertWithoutUserInput
    disconnect?: MitraWhereInput | boolean
    delete?: MitraWhereInput | boolean
    connect?: MitraWhereUniqueInput
    update?: XOR<XOR<MitraUpdateToOneWithWhereWithoutUserInput, MitraUpdateWithoutUserInput>, MitraUncheckedUpdateWithoutUserInput>
  }

  export type order_bookingUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<order_bookingCreateWithoutUserInput, order_bookingUncheckedCreateWithoutUserInput> | order_bookingCreateWithoutUserInput[] | order_bookingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: order_bookingCreateOrConnectWithoutUserInput | order_bookingCreateOrConnectWithoutUserInput[]
    upsert?: order_bookingUpsertWithWhereUniqueWithoutUserInput | order_bookingUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: order_bookingCreateManyUserInputEnvelope
    set?: order_bookingWhereUniqueInput | order_bookingWhereUniqueInput[]
    disconnect?: order_bookingWhereUniqueInput | order_bookingWhereUniqueInput[]
    delete?: order_bookingWhereUniqueInput | order_bookingWhereUniqueInput[]
    connect?: order_bookingWhereUniqueInput | order_bookingWhereUniqueInput[]
    update?: order_bookingUpdateWithWhereUniqueWithoutUserInput | order_bookingUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: order_bookingUpdateManyWithWhereWithoutUserInput | order_bookingUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: order_bookingScalarWhereInput | order_bookingScalarWhereInput[]
  }

  export type transaksiUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<transaksiCreateWithoutUserInput, transaksiUncheckedCreateWithoutUserInput> | transaksiCreateWithoutUserInput[] | transaksiUncheckedCreateWithoutUserInput[]
    connectOrCreate?: transaksiCreateOrConnectWithoutUserInput | transaksiCreateOrConnectWithoutUserInput[]
    upsert?: transaksiUpsertWithWhereUniqueWithoutUserInput | transaksiUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: transaksiCreateManyUserInputEnvelope
    set?: transaksiWhereUniqueInput | transaksiWhereUniqueInput[]
    disconnect?: transaksiWhereUniqueInput | transaksiWhereUniqueInput[]
    delete?: transaksiWhereUniqueInput | transaksiWhereUniqueInput[]
    connect?: transaksiWhereUniqueInput | transaksiWhereUniqueInput[]
    update?: transaksiUpdateWithWhereUniqueWithoutUserInput | transaksiUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: transaksiUpdateManyWithWhereWithoutUserInput | transaksiUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: transaksiScalarWhereInput | transaksiScalarWhereInput[]
  }

  export type notifikasiUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<notifikasiCreateWithoutUserInput, notifikasiUncheckedCreateWithoutUserInput> | notifikasiCreateWithoutUserInput[] | notifikasiUncheckedCreateWithoutUserInput[]
    connectOrCreate?: notifikasiCreateOrConnectWithoutUserInput | notifikasiCreateOrConnectWithoutUserInput[]
    upsert?: notifikasiUpsertWithWhereUniqueWithoutUserInput | notifikasiUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: notifikasiCreateManyUserInputEnvelope
    set?: notifikasiWhereUniqueInput | notifikasiWhereUniqueInput[]
    disconnect?: notifikasiWhereUniqueInput | notifikasiWhereUniqueInput[]
    delete?: notifikasiWhereUniqueInput | notifikasiWhereUniqueInput[]
    connect?: notifikasiWhereUniqueInput | notifikasiWhereUniqueInput[]
    update?: notifikasiUpdateWithWhereUniqueWithoutUserInput | notifikasiUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: notifikasiUpdateManyWithWhereWithoutUserInput | notifikasiUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: notifikasiScalarWhereInput | notifikasiScalarWhereInput[]
  }

  export type ulasanUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ulasanCreateWithoutUserInput, ulasanUncheckedCreateWithoutUserInput> | ulasanCreateWithoutUserInput[] | ulasanUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ulasanCreateOrConnectWithoutUserInput | ulasanCreateOrConnectWithoutUserInput[]
    upsert?: ulasanUpsertWithWhereUniqueWithoutUserInput | ulasanUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ulasanCreateManyUserInputEnvelope
    set?: ulasanWhereUniqueInput | ulasanWhereUniqueInput[]
    disconnect?: ulasanWhereUniqueInput | ulasanWhereUniqueInput[]
    delete?: ulasanWhereUniqueInput | ulasanWhereUniqueInput[]
    connect?: ulasanWhereUniqueInput | ulasanWhereUniqueInput[]
    update?: ulasanUpdateWithWhereUniqueWithoutUserInput | ulasanUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ulasanUpdateManyWithWhereWithoutUserInput | ulasanUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ulasanScalarWhereInput | ulasanScalarWhereInput[]
  }

  export type wallet_userUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<wallet_userCreateWithoutUserInput, wallet_userUncheckedCreateWithoutUserInput>
    connectOrCreate?: wallet_userCreateOrConnectWithoutUserInput
    upsert?: wallet_userUpsertWithoutUserInput
    disconnect?: wallet_userWhereInput | boolean
    delete?: wallet_userWhereInput | boolean
    connect?: wallet_userWhereUniqueInput
    update?: XOR<XOR<wallet_userUpdateToOneWithWhereWithoutUserInput, wallet_userUpdateWithoutUserInput>, wallet_userUncheckedUpdateWithoutUserInput>
  }

  export type refundUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<refundCreateWithoutUserInput, refundUncheckedCreateWithoutUserInput> | refundCreateWithoutUserInput[] | refundUncheckedCreateWithoutUserInput[]
    connectOrCreate?: refundCreateOrConnectWithoutUserInput | refundCreateOrConnectWithoutUserInput[]
    upsert?: refundUpsertWithWhereUniqueWithoutUserInput | refundUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: refundCreateManyUserInputEnvelope
    set?: refundWhereUniqueInput | refundWhereUniqueInput[]
    disconnect?: refundWhereUniqueInput | refundWhereUniqueInput[]
    delete?: refundWhereUniqueInput | refundWhereUniqueInput[]
    connect?: refundWhereUniqueInput | refundWhereUniqueInput[]
    update?: refundUpdateWithWhereUniqueWithoutUserInput | refundUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: refundUpdateManyWithWhereWithoutUserInput | refundUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: refundScalarWhereInput | refundScalarWhereInput[]
  }

  export type usersCreateNestedOneWithoutMitraInput = {
    create?: XOR<usersCreateWithoutMitraInput, usersUncheckedCreateWithoutMitraInput>
    connectOrCreate?: usersCreateOrConnectWithoutMitraInput
    connect?: usersWhereUniqueInput
  }

  export type LapanganCreateNestedManyWithoutMitraInput = {
    create?: XOR<LapanganCreateWithoutMitraInput, LapanganUncheckedCreateWithoutMitraInput> | LapanganCreateWithoutMitraInput[] | LapanganUncheckedCreateWithoutMitraInput[]
    connectOrCreate?: LapanganCreateOrConnectWithoutMitraInput | LapanganCreateOrConnectWithoutMitraInput[]
    createMany?: LapanganCreateManyMitraInputEnvelope
    connect?: LapanganWhereUniqueInput | LapanganWhereUniqueInput[]
  }

  export type pendapatan_mitraCreateNestedManyWithoutMitraInput = {
    create?: XOR<pendapatan_mitraCreateWithoutMitraInput, pendapatan_mitraUncheckedCreateWithoutMitraInput> | pendapatan_mitraCreateWithoutMitraInput[] | pendapatan_mitraUncheckedCreateWithoutMitraInput[]
    connectOrCreate?: pendapatan_mitraCreateOrConnectWithoutMitraInput | pendapatan_mitraCreateOrConnectWithoutMitraInput[]
    createMany?: pendapatan_mitraCreateManyMitraInputEnvelope
    connect?: pendapatan_mitraWhereUniqueInput | pendapatan_mitraWhereUniqueInput[]
  }

  export type pencairan_pendapatanCreateNestedManyWithoutMitraInput = {
    create?: XOR<pencairan_pendapatanCreateWithoutMitraInput, pencairan_pendapatanUncheckedCreateWithoutMitraInput> | pencairan_pendapatanCreateWithoutMitraInput[] | pencairan_pendapatanUncheckedCreateWithoutMitraInput[]
    connectOrCreate?: pencairan_pendapatanCreateOrConnectWithoutMitraInput | pencairan_pendapatanCreateOrConnectWithoutMitraInput[]
    createMany?: pencairan_pendapatanCreateManyMitraInputEnvelope
    connect?: pencairan_pendapatanWhereUniqueInput | pencairan_pendapatanWhereUniqueInput[]
  }

  export type LapanganUncheckedCreateNestedManyWithoutMitraInput = {
    create?: XOR<LapanganCreateWithoutMitraInput, LapanganUncheckedCreateWithoutMitraInput> | LapanganCreateWithoutMitraInput[] | LapanganUncheckedCreateWithoutMitraInput[]
    connectOrCreate?: LapanganCreateOrConnectWithoutMitraInput | LapanganCreateOrConnectWithoutMitraInput[]
    createMany?: LapanganCreateManyMitraInputEnvelope
    connect?: LapanganWhereUniqueInput | LapanganWhereUniqueInput[]
  }

  export type pendapatan_mitraUncheckedCreateNestedManyWithoutMitraInput = {
    create?: XOR<pendapatan_mitraCreateWithoutMitraInput, pendapatan_mitraUncheckedCreateWithoutMitraInput> | pendapatan_mitraCreateWithoutMitraInput[] | pendapatan_mitraUncheckedCreateWithoutMitraInput[]
    connectOrCreate?: pendapatan_mitraCreateOrConnectWithoutMitraInput | pendapatan_mitraCreateOrConnectWithoutMitraInput[]
    createMany?: pendapatan_mitraCreateManyMitraInputEnvelope
    connect?: pendapatan_mitraWhereUniqueInput | pendapatan_mitraWhereUniqueInput[]
  }

  export type pencairan_pendapatanUncheckedCreateNestedManyWithoutMitraInput = {
    create?: XOR<pencairan_pendapatanCreateWithoutMitraInput, pencairan_pendapatanUncheckedCreateWithoutMitraInput> | pencairan_pendapatanCreateWithoutMitraInput[] | pencairan_pendapatanUncheckedCreateWithoutMitraInput[]
    connectOrCreate?: pencairan_pendapatanCreateOrConnectWithoutMitraInput | pencairan_pendapatanCreateOrConnectWithoutMitraInput[]
    createMany?: pencairan_pendapatanCreateManyMitraInputEnvelope
    connect?: pencairan_pendapatanWhereUniqueInput | pencairan_pendapatanWhereUniqueInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type Enummitra_statusFieldUpdateOperationsInput = {
    set?: $Enums.mitra_status
  }

  export type usersUpdateOneRequiredWithoutMitraNestedInput = {
    create?: XOR<usersCreateWithoutMitraInput, usersUncheckedCreateWithoutMitraInput>
    connectOrCreate?: usersCreateOrConnectWithoutMitraInput
    upsert?: usersUpsertWithoutMitraInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutMitraInput, usersUpdateWithoutMitraInput>, usersUncheckedUpdateWithoutMitraInput>
  }

  export type LapanganUpdateManyWithoutMitraNestedInput = {
    create?: XOR<LapanganCreateWithoutMitraInput, LapanganUncheckedCreateWithoutMitraInput> | LapanganCreateWithoutMitraInput[] | LapanganUncheckedCreateWithoutMitraInput[]
    connectOrCreate?: LapanganCreateOrConnectWithoutMitraInput | LapanganCreateOrConnectWithoutMitraInput[]
    upsert?: LapanganUpsertWithWhereUniqueWithoutMitraInput | LapanganUpsertWithWhereUniqueWithoutMitraInput[]
    createMany?: LapanganCreateManyMitraInputEnvelope
    set?: LapanganWhereUniqueInput | LapanganWhereUniqueInput[]
    disconnect?: LapanganWhereUniqueInput | LapanganWhereUniqueInput[]
    delete?: LapanganWhereUniqueInput | LapanganWhereUniqueInput[]
    connect?: LapanganWhereUniqueInput | LapanganWhereUniqueInput[]
    update?: LapanganUpdateWithWhereUniqueWithoutMitraInput | LapanganUpdateWithWhereUniqueWithoutMitraInput[]
    updateMany?: LapanganUpdateManyWithWhereWithoutMitraInput | LapanganUpdateManyWithWhereWithoutMitraInput[]
    deleteMany?: LapanganScalarWhereInput | LapanganScalarWhereInput[]
  }

  export type pendapatan_mitraUpdateManyWithoutMitraNestedInput = {
    create?: XOR<pendapatan_mitraCreateWithoutMitraInput, pendapatan_mitraUncheckedCreateWithoutMitraInput> | pendapatan_mitraCreateWithoutMitraInput[] | pendapatan_mitraUncheckedCreateWithoutMitraInput[]
    connectOrCreate?: pendapatan_mitraCreateOrConnectWithoutMitraInput | pendapatan_mitraCreateOrConnectWithoutMitraInput[]
    upsert?: pendapatan_mitraUpsertWithWhereUniqueWithoutMitraInput | pendapatan_mitraUpsertWithWhereUniqueWithoutMitraInput[]
    createMany?: pendapatan_mitraCreateManyMitraInputEnvelope
    set?: pendapatan_mitraWhereUniqueInput | pendapatan_mitraWhereUniqueInput[]
    disconnect?: pendapatan_mitraWhereUniqueInput | pendapatan_mitraWhereUniqueInput[]
    delete?: pendapatan_mitraWhereUniqueInput | pendapatan_mitraWhereUniqueInput[]
    connect?: pendapatan_mitraWhereUniqueInput | pendapatan_mitraWhereUniqueInput[]
    update?: pendapatan_mitraUpdateWithWhereUniqueWithoutMitraInput | pendapatan_mitraUpdateWithWhereUniqueWithoutMitraInput[]
    updateMany?: pendapatan_mitraUpdateManyWithWhereWithoutMitraInput | pendapatan_mitraUpdateManyWithWhereWithoutMitraInput[]
    deleteMany?: pendapatan_mitraScalarWhereInput | pendapatan_mitraScalarWhereInput[]
  }

  export type pencairan_pendapatanUpdateManyWithoutMitraNestedInput = {
    create?: XOR<pencairan_pendapatanCreateWithoutMitraInput, pencairan_pendapatanUncheckedCreateWithoutMitraInput> | pencairan_pendapatanCreateWithoutMitraInput[] | pencairan_pendapatanUncheckedCreateWithoutMitraInput[]
    connectOrCreate?: pencairan_pendapatanCreateOrConnectWithoutMitraInput | pencairan_pendapatanCreateOrConnectWithoutMitraInput[]
    upsert?: pencairan_pendapatanUpsertWithWhereUniqueWithoutMitraInput | pencairan_pendapatanUpsertWithWhereUniqueWithoutMitraInput[]
    createMany?: pencairan_pendapatanCreateManyMitraInputEnvelope
    set?: pencairan_pendapatanWhereUniqueInput | pencairan_pendapatanWhereUniqueInput[]
    disconnect?: pencairan_pendapatanWhereUniqueInput | pencairan_pendapatanWhereUniqueInput[]
    delete?: pencairan_pendapatanWhereUniqueInput | pencairan_pendapatanWhereUniqueInput[]
    connect?: pencairan_pendapatanWhereUniqueInput | pencairan_pendapatanWhereUniqueInput[]
    update?: pencairan_pendapatanUpdateWithWhereUniqueWithoutMitraInput | pencairan_pendapatanUpdateWithWhereUniqueWithoutMitraInput[]
    updateMany?: pencairan_pendapatanUpdateManyWithWhereWithoutMitraInput | pencairan_pendapatanUpdateManyWithWhereWithoutMitraInput[]
    deleteMany?: pencairan_pendapatanScalarWhereInput | pencairan_pendapatanScalarWhereInput[]
  }

  export type LapanganUncheckedUpdateManyWithoutMitraNestedInput = {
    create?: XOR<LapanganCreateWithoutMitraInput, LapanganUncheckedCreateWithoutMitraInput> | LapanganCreateWithoutMitraInput[] | LapanganUncheckedCreateWithoutMitraInput[]
    connectOrCreate?: LapanganCreateOrConnectWithoutMitraInput | LapanganCreateOrConnectWithoutMitraInput[]
    upsert?: LapanganUpsertWithWhereUniqueWithoutMitraInput | LapanganUpsertWithWhereUniqueWithoutMitraInput[]
    createMany?: LapanganCreateManyMitraInputEnvelope
    set?: LapanganWhereUniqueInput | LapanganWhereUniqueInput[]
    disconnect?: LapanganWhereUniqueInput | LapanganWhereUniqueInput[]
    delete?: LapanganWhereUniqueInput | LapanganWhereUniqueInput[]
    connect?: LapanganWhereUniqueInput | LapanganWhereUniqueInput[]
    update?: LapanganUpdateWithWhereUniqueWithoutMitraInput | LapanganUpdateWithWhereUniqueWithoutMitraInput[]
    updateMany?: LapanganUpdateManyWithWhereWithoutMitraInput | LapanganUpdateManyWithWhereWithoutMitraInput[]
    deleteMany?: LapanganScalarWhereInput | LapanganScalarWhereInput[]
  }

  export type pendapatan_mitraUncheckedUpdateManyWithoutMitraNestedInput = {
    create?: XOR<pendapatan_mitraCreateWithoutMitraInput, pendapatan_mitraUncheckedCreateWithoutMitraInput> | pendapatan_mitraCreateWithoutMitraInput[] | pendapatan_mitraUncheckedCreateWithoutMitraInput[]
    connectOrCreate?: pendapatan_mitraCreateOrConnectWithoutMitraInput | pendapatan_mitraCreateOrConnectWithoutMitraInput[]
    upsert?: pendapatan_mitraUpsertWithWhereUniqueWithoutMitraInput | pendapatan_mitraUpsertWithWhereUniqueWithoutMitraInput[]
    createMany?: pendapatan_mitraCreateManyMitraInputEnvelope
    set?: pendapatan_mitraWhereUniqueInput | pendapatan_mitraWhereUniqueInput[]
    disconnect?: pendapatan_mitraWhereUniqueInput | pendapatan_mitraWhereUniqueInput[]
    delete?: pendapatan_mitraWhereUniqueInput | pendapatan_mitraWhereUniqueInput[]
    connect?: pendapatan_mitraWhereUniqueInput | pendapatan_mitraWhereUniqueInput[]
    update?: pendapatan_mitraUpdateWithWhereUniqueWithoutMitraInput | pendapatan_mitraUpdateWithWhereUniqueWithoutMitraInput[]
    updateMany?: pendapatan_mitraUpdateManyWithWhereWithoutMitraInput | pendapatan_mitraUpdateManyWithWhereWithoutMitraInput[]
    deleteMany?: pendapatan_mitraScalarWhereInput | pendapatan_mitraScalarWhereInput[]
  }

  export type pencairan_pendapatanUncheckedUpdateManyWithoutMitraNestedInput = {
    create?: XOR<pencairan_pendapatanCreateWithoutMitraInput, pencairan_pendapatanUncheckedCreateWithoutMitraInput> | pencairan_pendapatanCreateWithoutMitraInput[] | pencairan_pendapatanUncheckedCreateWithoutMitraInput[]
    connectOrCreate?: pencairan_pendapatanCreateOrConnectWithoutMitraInput | pencairan_pendapatanCreateOrConnectWithoutMitraInput[]
    upsert?: pencairan_pendapatanUpsertWithWhereUniqueWithoutMitraInput | pencairan_pendapatanUpsertWithWhereUniqueWithoutMitraInput[]
    createMany?: pencairan_pendapatanCreateManyMitraInputEnvelope
    set?: pencairan_pendapatanWhereUniqueInput | pencairan_pendapatanWhereUniqueInput[]
    disconnect?: pencairan_pendapatanWhereUniqueInput | pencairan_pendapatanWhereUniqueInput[]
    delete?: pencairan_pendapatanWhereUniqueInput | pencairan_pendapatanWhereUniqueInput[]
    connect?: pencairan_pendapatanWhereUniqueInput | pencairan_pendapatanWhereUniqueInput[]
    update?: pencairan_pendapatanUpdateWithWhereUniqueWithoutMitraInput | pencairan_pendapatanUpdateWithWhereUniqueWithoutMitraInput[]
    updateMany?: pencairan_pendapatanUpdateManyWithWhereWithoutMitraInput | pencairan_pendapatanUpdateManyWithWhereWithoutMitraInput[]
    deleteMany?: pencairan_pendapatanScalarWhereInput | pencairan_pendapatanScalarWhereInput[]
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type MitraCreateNestedOneWithoutLapanganInput = {
    create?: XOR<MitraCreateWithoutLapanganInput, MitraUncheckedCreateWithoutLapanganInput>
    connectOrCreate?: MitraCreateOrConnectWithoutLapanganInput
    connect?: MitraWhereUniqueInput
  }

  export type LapanganDetailCreateNestedOneWithoutLapanganInput = {
    create?: XOR<LapanganDetailCreateWithoutLapanganInput, LapanganDetailUncheckedCreateWithoutLapanganInput>
    connectOrCreate?: LapanganDetailCreateOrConnectWithoutLapanganInput
    connect?: LapanganDetailWhereUniqueInput
  }

  export type LapanganGambarCreateNestedManyWithoutLapanganInput = {
    create?: XOR<LapanganGambarCreateWithoutLapanganInput, LapanganGambarUncheckedCreateWithoutLapanganInput> | LapanganGambarCreateWithoutLapanganInput[] | LapanganGambarUncheckedCreateWithoutLapanganInput[]
    connectOrCreate?: LapanganGambarCreateOrConnectWithoutLapanganInput | LapanganGambarCreateOrConnectWithoutLapanganInput[]
    createMany?: LapanganGambarCreateManyLapanganInputEnvelope
    connect?: LapanganGambarWhereUniqueInput | LapanganGambarWhereUniqueInput[]
  }

  export type JadwalLapanganCreateNestedManyWithoutLapanganInput = {
    create?: XOR<JadwalLapanganCreateWithoutLapanganInput, JadwalLapanganUncheckedCreateWithoutLapanganInput> | JadwalLapanganCreateWithoutLapanganInput[] | JadwalLapanganUncheckedCreateWithoutLapanganInput[]
    connectOrCreate?: JadwalLapanganCreateOrConnectWithoutLapanganInput | JadwalLapanganCreateOrConnectWithoutLapanganInput[]
    createMany?: JadwalLapanganCreateManyLapanganInputEnvelope
    connect?: JadwalLapanganWhereUniqueInput | JadwalLapanganWhereUniqueInput[]
  }

  export type order_bookingCreateNestedManyWithoutLapanganInput = {
    create?: XOR<order_bookingCreateWithoutLapanganInput, order_bookingUncheckedCreateWithoutLapanganInput> | order_bookingCreateWithoutLapanganInput[] | order_bookingUncheckedCreateWithoutLapanganInput[]
    connectOrCreate?: order_bookingCreateOrConnectWithoutLapanganInput | order_bookingCreateOrConnectWithoutLapanganInput[]
    createMany?: order_bookingCreateManyLapanganInputEnvelope
    connect?: order_bookingWhereUniqueInput | order_bookingWhereUniqueInput[]
  }

  export type transaksiCreateNestedManyWithoutLapanganInput = {
    create?: XOR<transaksiCreateWithoutLapanganInput, transaksiUncheckedCreateWithoutLapanganInput> | transaksiCreateWithoutLapanganInput[] | transaksiUncheckedCreateWithoutLapanganInput[]
    connectOrCreate?: transaksiCreateOrConnectWithoutLapanganInput | transaksiCreateOrConnectWithoutLapanganInput[]
    createMany?: transaksiCreateManyLapanganInputEnvelope
    connect?: transaksiWhereUniqueInput | transaksiWhereUniqueInput[]
  }

  export type ulasanCreateNestedManyWithoutLapanganInput = {
    create?: XOR<ulasanCreateWithoutLapanganInput, ulasanUncheckedCreateWithoutLapanganInput> | ulasanCreateWithoutLapanganInput[] | ulasanUncheckedCreateWithoutLapanganInput[]
    connectOrCreate?: ulasanCreateOrConnectWithoutLapanganInput | ulasanCreateOrConnectWithoutLapanganInput[]
    createMany?: ulasanCreateManyLapanganInputEnvelope
    connect?: ulasanWhereUniqueInput | ulasanWhereUniqueInput[]
  }

  export type LapanganDetailUncheckedCreateNestedOneWithoutLapanganInput = {
    create?: XOR<LapanganDetailCreateWithoutLapanganInput, LapanganDetailUncheckedCreateWithoutLapanganInput>
    connectOrCreate?: LapanganDetailCreateOrConnectWithoutLapanganInput
    connect?: LapanganDetailWhereUniqueInput
  }

  export type LapanganGambarUncheckedCreateNestedManyWithoutLapanganInput = {
    create?: XOR<LapanganGambarCreateWithoutLapanganInput, LapanganGambarUncheckedCreateWithoutLapanganInput> | LapanganGambarCreateWithoutLapanganInput[] | LapanganGambarUncheckedCreateWithoutLapanganInput[]
    connectOrCreate?: LapanganGambarCreateOrConnectWithoutLapanganInput | LapanganGambarCreateOrConnectWithoutLapanganInput[]
    createMany?: LapanganGambarCreateManyLapanganInputEnvelope
    connect?: LapanganGambarWhereUniqueInput | LapanganGambarWhereUniqueInput[]
  }

  export type JadwalLapanganUncheckedCreateNestedManyWithoutLapanganInput = {
    create?: XOR<JadwalLapanganCreateWithoutLapanganInput, JadwalLapanganUncheckedCreateWithoutLapanganInput> | JadwalLapanganCreateWithoutLapanganInput[] | JadwalLapanganUncheckedCreateWithoutLapanganInput[]
    connectOrCreate?: JadwalLapanganCreateOrConnectWithoutLapanganInput | JadwalLapanganCreateOrConnectWithoutLapanganInput[]
    createMany?: JadwalLapanganCreateManyLapanganInputEnvelope
    connect?: JadwalLapanganWhereUniqueInput | JadwalLapanganWhereUniqueInput[]
  }

  export type order_bookingUncheckedCreateNestedManyWithoutLapanganInput = {
    create?: XOR<order_bookingCreateWithoutLapanganInput, order_bookingUncheckedCreateWithoutLapanganInput> | order_bookingCreateWithoutLapanganInput[] | order_bookingUncheckedCreateWithoutLapanganInput[]
    connectOrCreate?: order_bookingCreateOrConnectWithoutLapanganInput | order_bookingCreateOrConnectWithoutLapanganInput[]
    createMany?: order_bookingCreateManyLapanganInputEnvelope
    connect?: order_bookingWhereUniqueInput | order_bookingWhereUniqueInput[]
  }

  export type transaksiUncheckedCreateNestedManyWithoutLapanganInput = {
    create?: XOR<transaksiCreateWithoutLapanganInput, transaksiUncheckedCreateWithoutLapanganInput> | transaksiCreateWithoutLapanganInput[] | transaksiUncheckedCreateWithoutLapanganInput[]
    connectOrCreate?: transaksiCreateOrConnectWithoutLapanganInput | transaksiCreateOrConnectWithoutLapanganInput[]
    createMany?: transaksiCreateManyLapanganInputEnvelope
    connect?: transaksiWhereUniqueInput | transaksiWhereUniqueInput[]
  }

  export type ulasanUncheckedCreateNestedManyWithoutLapanganInput = {
    create?: XOR<ulasanCreateWithoutLapanganInput, ulasanUncheckedCreateWithoutLapanganInput> | ulasanCreateWithoutLapanganInput[] | ulasanUncheckedCreateWithoutLapanganInput[]
    connectOrCreate?: ulasanCreateOrConnectWithoutLapanganInput | ulasanCreateOrConnectWithoutLapanganInput[]
    createMany?: ulasanCreateManyLapanganInputEnvelope
    connect?: ulasanWhereUniqueInput | ulasanWhereUniqueInput[]
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type Enumlapangan_statusFieldUpdateOperationsInput = {
    set?: $Enums.lapangan_status
  }

  export type MitraUpdateOneRequiredWithoutLapanganNestedInput = {
    create?: XOR<MitraCreateWithoutLapanganInput, MitraUncheckedCreateWithoutLapanganInput>
    connectOrCreate?: MitraCreateOrConnectWithoutLapanganInput
    upsert?: MitraUpsertWithoutLapanganInput
    connect?: MitraWhereUniqueInput
    update?: XOR<XOR<MitraUpdateToOneWithWhereWithoutLapanganInput, MitraUpdateWithoutLapanganInput>, MitraUncheckedUpdateWithoutLapanganInput>
  }

  export type LapanganDetailUpdateOneWithoutLapanganNestedInput = {
    create?: XOR<LapanganDetailCreateWithoutLapanganInput, LapanganDetailUncheckedCreateWithoutLapanganInput>
    connectOrCreate?: LapanganDetailCreateOrConnectWithoutLapanganInput
    upsert?: LapanganDetailUpsertWithoutLapanganInput
    disconnect?: LapanganDetailWhereInput | boolean
    delete?: LapanganDetailWhereInput | boolean
    connect?: LapanganDetailWhereUniqueInput
    update?: XOR<XOR<LapanganDetailUpdateToOneWithWhereWithoutLapanganInput, LapanganDetailUpdateWithoutLapanganInput>, LapanganDetailUncheckedUpdateWithoutLapanganInput>
  }

  export type LapanganGambarUpdateManyWithoutLapanganNestedInput = {
    create?: XOR<LapanganGambarCreateWithoutLapanganInput, LapanganGambarUncheckedCreateWithoutLapanganInput> | LapanganGambarCreateWithoutLapanganInput[] | LapanganGambarUncheckedCreateWithoutLapanganInput[]
    connectOrCreate?: LapanganGambarCreateOrConnectWithoutLapanganInput | LapanganGambarCreateOrConnectWithoutLapanganInput[]
    upsert?: LapanganGambarUpsertWithWhereUniqueWithoutLapanganInput | LapanganGambarUpsertWithWhereUniqueWithoutLapanganInput[]
    createMany?: LapanganGambarCreateManyLapanganInputEnvelope
    set?: LapanganGambarWhereUniqueInput | LapanganGambarWhereUniqueInput[]
    disconnect?: LapanganGambarWhereUniqueInput | LapanganGambarWhereUniqueInput[]
    delete?: LapanganGambarWhereUniqueInput | LapanganGambarWhereUniqueInput[]
    connect?: LapanganGambarWhereUniqueInput | LapanganGambarWhereUniqueInput[]
    update?: LapanganGambarUpdateWithWhereUniqueWithoutLapanganInput | LapanganGambarUpdateWithWhereUniqueWithoutLapanganInput[]
    updateMany?: LapanganGambarUpdateManyWithWhereWithoutLapanganInput | LapanganGambarUpdateManyWithWhereWithoutLapanganInput[]
    deleteMany?: LapanganGambarScalarWhereInput | LapanganGambarScalarWhereInput[]
  }

  export type JadwalLapanganUpdateManyWithoutLapanganNestedInput = {
    create?: XOR<JadwalLapanganCreateWithoutLapanganInput, JadwalLapanganUncheckedCreateWithoutLapanganInput> | JadwalLapanganCreateWithoutLapanganInput[] | JadwalLapanganUncheckedCreateWithoutLapanganInput[]
    connectOrCreate?: JadwalLapanganCreateOrConnectWithoutLapanganInput | JadwalLapanganCreateOrConnectWithoutLapanganInput[]
    upsert?: JadwalLapanganUpsertWithWhereUniqueWithoutLapanganInput | JadwalLapanganUpsertWithWhereUniqueWithoutLapanganInput[]
    createMany?: JadwalLapanganCreateManyLapanganInputEnvelope
    set?: JadwalLapanganWhereUniqueInput | JadwalLapanganWhereUniqueInput[]
    disconnect?: JadwalLapanganWhereUniqueInput | JadwalLapanganWhereUniqueInput[]
    delete?: JadwalLapanganWhereUniqueInput | JadwalLapanganWhereUniqueInput[]
    connect?: JadwalLapanganWhereUniqueInput | JadwalLapanganWhereUniqueInput[]
    update?: JadwalLapanganUpdateWithWhereUniqueWithoutLapanganInput | JadwalLapanganUpdateWithWhereUniqueWithoutLapanganInput[]
    updateMany?: JadwalLapanganUpdateManyWithWhereWithoutLapanganInput | JadwalLapanganUpdateManyWithWhereWithoutLapanganInput[]
    deleteMany?: JadwalLapanganScalarWhereInput | JadwalLapanganScalarWhereInput[]
  }

  export type order_bookingUpdateManyWithoutLapanganNestedInput = {
    create?: XOR<order_bookingCreateWithoutLapanganInput, order_bookingUncheckedCreateWithoutLapanganInput> | order_bookingCreateWithoutLapanganInput[] | order_bookingUncheckedCreateWithoutLapanganInput[]
    connectOrCreate?: order_bookingCreateOrConnectWithoutLapanganInput | order_bookingCreateOrConnectWithoutLapanganInput[]
    upsert?: order_bookingUpsertWithWhereUniqueWithoutLapanganInput | order_bookingUpsertWithWhereUniqueWithoutLapanganInput[]
    createMany?: order_bookingCreateManyLapanganInputEnvelope
    set?: order_bookingWhereUniqueInput | order_bookingWhereUniqueInput[]
    disconnect?: order_bookingWhereUniqueInput | order_bookingWhereUniqueInput[]
    delete?: order_bookingWhereUniqueInput | order_bookingWhereUniqueInput[]
    connect?: order_bookingWhereUniqueInput | order_bookingWhereUniqueInput[]
    update?: order_bookingUpdateWithWhereUniqueWithoutLapanganInput | order_bookingUpdateWithWhereUniqueWithoutLapanganInput[]
    updateMany?: order_bookingUpdateManyWithWhereWithoutLapanganInput | order_bookingUpdateManyWithWhereWithoutLapanganInput[]
    deleteMany?: order_bookingScalarWhereInput | order_bookingScalarWhereInput[]
  }

  export type transaksiUpdateManyWithoutLapanganNestedInput = {
    create?: XOR<transaksiCreateWithoutLapanganInput, transaksiUncheckedCreateWithoutLapanganInput> | transaksiCreateWithoutLapanganInput[] | transaksiUncheckedCreateWithoutLapanganInput[]
    connectOrCreate?: transaksiCreateOrConnectWithoutLapanganInput | transaksiCreateOrConnectWithoutLapanganInput[]
    upsert?: transaksiUpsertWithWhereUniqueWithoutLapanganInput | transaksiUpsertWithWhereUniqueWithoutLapanganInput[]
    createMany?: transaksiCreateManyLapanganInputEnvelope
    set?: transaksiWhereUniqueInput | transaksiWhereUniqueInput[]
    disconnect?: transaksiWhereUniqueInput | transaksiWhereUniqueInput[]
    delete?: transaksiWhereUniqueInput | transaksiWhereUniqueInput[]
    connect?: transaksiWhereUniqueInput | transaksiWhereUniqueInput[]
    update?: transaksiUpdateWithWhereUniqueWithoutLapanganInput | transaksiUpdateWithWhereUniqueWithoutLapanganInput[]
    updateMany?: transaksiUpdateManyWithWhereWithoutLapanganInput | transaksiUpdateManyWithWhereWithoutLapanganInput[]
    deleteMany?: transaksiScalarWhereInput | transaksiScalarWhereInput[]
  }

  export type ulasanUpdateManyWithoutLapanganNestedInput = {
    create?: XOR<ulasanCreateWithoutLapanganInput, ulasanUncheckedCreateWithoutLapanganInput> | ulasanCreateWithoutLapanganInput[] | ulasanUncheckedCreateWithoutLapanganInput[]
    connectOrCreate?: ulasanCreateOrConnectWithoutLapanganInput | ulasanCreateOrConnectWithoutLapanganInput[]
    upsert?: ulasanUpsertWithWhereUniqueWithoutLapanganInput | ulasanUpsertWithWhereUniqueWithoutLapanganInput[]
    createMany?: ulasanCreateManyLapanganInputEnvelope
    set?: ulasanWhereUniqueInput | ulasanWhereUniqueInput[]
    disconnect?: ulasanWhereUniqueInput | ulasanWhereUniqueInput[]
    delete?: ulasanWhereUniqueInput | ulasanWhereUniqueInput[]
    connect?: ulasanWhereUniqueInput | ulasanWhereUniqueInput[]
    update?: ulasanUpdateWithWhereUniqueWithoutLapanganInput | ulasanUpdateWithWhereUniqueWithoutLapanganInput[]
    updateMany?: ulasanUpdateManyWithWhereWithoutLapanganInput | ulasanUpdateManyWithWhereWithoutLapanganInput[]
    deleteMany?: ulasanScalarWhereInput | ulasanScalarWhereInput[]
  }

  export type LapanganDetailUncheckedUpdateOneWithoutLapanganNestedInput = {
    create?: XOR<LapanganDetailCreateWithoutLapanganInput, LapanganDetailUncheckedCreateWithoutLapanganInput>
    connectOrCreate?: LapanganDetailCreateOrConnectWithoutLapanganInput
    upsert?: LapanganDetailUpsertWithoutLapanganInput
    disconnect?: LapanganDetailWhereInput | boolean
    delete?: LapanganDetailWhereInput | boolean
    connect?: LapanganDetailWhereUniqueInput
    update?: XOR<XOR<LapanganDetailUpdateToOneWithWhereWithoutLapanganInput, LapanganDetailUpdateWithoutLapanganInput>, LapanganDetailUncheckedUpdateWithoutLapanganInput>
  }

  export type LapanganGambarUncheckedUpdateManyWithoutLapanganNestedInput = {
    create?: XOR<LapanganGambarCreateWithoutLapanganInput, LapanganGambarUncheckedCreateWithoutLapanganInput> | LapanganGambarCreateWithoutLapanganInput[] | LapanganGambarUncheckedCreateWithoutLapanganInput[]
    connectOrCreate?: LapanganGambarCreateOrConnectWithoutLapanganInput | LapanganGambarCreateOrConnectWithoutLapanganInput[]
    upsert?: LapanganGambarUpsertWithWhereUniqueWithoutLapanganInput | LapanganGambarUpsertWithWhereUniqueWithoutLapanganInput[]
    createMany?: LapanganGambarCreateManyLapanganInputEnvelope
    set?: LapanganGambarWhereUniqueInput | LapanganGambarWhereUniqueInput[]
    disconnect?: LapanganGambarWhereUniqueInput | LapanganGambarWhereUniqueInput[]
    delete?: LapanganGambarWhereUniqueInput | LapanganGambarWhereUniqueInput[]
    connect?: LapanganGambarWhereUniqueInput | LapanganGambarWhereUniqueInput[]
    update?: LapanganGambarUpdateWithWhereUniqueWithoutLapanganInput | LapanganGambarUpdateWithWhereUniqueWithoutLapanganInput[]
    updateMany?: LapanganGambarUpdateManyWithWhereWithoutLapanganInput | LapanganGambarUpdateManyWithWhereWithoutLapanganInput[]
    deleteMany?: LapanganGambarScalarWhereInput | LapanganGambarScalarWhereInput[]
  }

  export type JadwalLapanganUncheckedUpdateManyWithoutLapanganNestedInput = {
    create?: XOR<JadwalLapanganCreateWithoutLapanganInput, JadwalLapanganUncheckedCreateWithoutLapanganInput> | JadwalLapanganCreateWithoutLapanganInput[] | JadwalLapanganUncheckedCreateWithoutLapanganInput[]
    connectOrCreate?: JadwalLapanganCreateOrConnectWithoutLapanganInput | JadwalLapanganCreateOrConnectWithoutLapanganInput[]
    upsert?: JadwalLapanganUpsertWithWhereUniqueWithoutLapanganInput | JadwalLapanganUpsertWithWhereUniqueWithoutLapanganInput[]
    createMany?: JadwalLapanganCreateManyLapanganInputEnvelope
    set?: JadwalLapanganWhereUniqueInput | JadwalLapanganWhereUniqueInput[]
    disconnect?: JadwalLapanganWhereUniqueInput | JadwalLapanganWhereUniqueInput[]
    delete?: JadwalLapanganWhereUniqueInput | JadwalLapanganWhereUniqueInput[]
    connect?: JadwalLapanganWhereUniqueInput | JadwalLapanganWhereUniqueInput[]
    update?: JadwalLapanganUpdateWithWhereUniqueWithoutLapanganInput | JadwalLapanganUpdateWithWhereUniqueWithoutLapanganInput[]
    updateMany?: JadwalLapanganUpdateManyWithWhereWithoutLapanganInput | JadwalLapanganUpdateManyWithWhereWithoutLapanganInput[]
    deleteMany?: JadwalLapanganScalarWhereInput | JadwalLapanganScalarWhereInput[]
  }

  export type order_bookingUncheckedUpdateManyWithoutLapanganNestedInput = {
    create?: XOR<order_bookingCreateWithoutLapanganInput, order_bookingUncheckedCreateWithoutLapanganInput> | order_bookingCreateWithoutLapanganInput[] | order_bookingUncheckedCreateWithoutLapanganInput[]
    connectOrCreate?: order_bookingCreateOrConnectWithoutLapanganInput | order_bookingCreateOrConnectWithoutLapanganInput[]
    upsert?: order_bookingUpsertWithWhereUniqueWithoutLapanganInput | order_bookingUpsertWithWhereUniqueWithoutLapanganInput[]
    createMany?: order_bookingCreateManyLapanganInputEnvelope
    set?: order_bookingWhereUniqueInput | order_bookingWhereUniqueInput[]
    disconnect?: order_bookingWhereUniqueInput | order_bookingWhereUniqueInput[]
    delete?: order_bookingWhereUniqueInput | order_bookingWhereUniqueInput[]
    connect?: order_bookingWhereUniqueInput | order_bookingWhereUniqueInput[]
    update?: order_bookingUpdateWithWhereUniqueWithoutLapanganInput | order_bookingUpdateWithWhereUniqueWithoutLapanganInput[]
    updateMany?: order_bookingUpdateManyWithWhereWithoutLapanganInput | order_bookingUpdateManyWithWhereWithoutLapanganInput[]
    deleteMany?: order_bookingScalarWhereInput | order_bookingScalarWhereInput[]
  }

  export type transaksiUncheckedUpdateManyWithoutLapanganNestedInput = {
    create?: XOR<transaksiCreateWithoutLapanganInput, transaksiUncheckedCreateWithoutLapanganInput> | transaksiCreateWithoutLapanganInput[] | transaksiUncheckedCreateWithoutLapanganInput[]
    connectOrCreate?: transaksiCreateOrConnectWithoutLapanganInput | transaksiCreateOrConnectWithoutLapanganInput[]
    upsert?: transaksiUpsertWithWhereUniqueWithoutLapanganInput | transaksiUpsertWithWhereUniqueWithoutLapanganInput[]
    createMany?: transaksiCreateManyLapanganInputEnvelope
    set?: transaksiWhereUniqueInput | transaksiWhereUniqueInput[]
    disconnect?: transaksiWhereUniqueInput | transaksiWhereUniqueInput[]
    delete?: transaksiWhereUniqueInput | transaksiWhereUniqueInput[]
    connect?: transaksiWhereUniqueInput | transaksiWhereUniqueInput[]
    update?: transaksiUpdateWithWhereUniqueWithoutLapanganInput | transaksiUpdateWithWhereUniqueWithoutLapanganInput[]
    updateMany?: transaksiUpdateManyWithWhereWithoutLapanganInput | transaksiUpdateManyWithWhereWithoutLapanganInput[]
    deleteMany?: transaksiScalarWhereInput | transaksiScalarWhereInput[]
  }

  export type ulasanUncheckedUpdateManyWithoutLapanganNestedInput = {
    create?: XOR<ulasanCreateWithoutLapanganInput, ulasanUncheckedCreateWithoutLapanganInput> | ulasanCreateWithoutLapanganInput[] | ulasanUncheckedCreateWithoutLapanganInput[]
    connectOrCreate?: ulasanCreateOrConnectWithoutLapanganInput | ulasanCreateOrConnectWithoutLapanganInput[]
    upsert?: ulasanUpsertWithWhereUniqueWithoutLapanganInput | ulasanUpsertWithWhereUniqueWithoutLapanganInput[]
    createMany?: ulasanCreateManyLapanganInputEnvelope
    set?: ulasanWhereUniqueInput | ulasanWhereUniqueInput[]
    disconnect?: ulasanWhereUniqueInput | ulasanWhereUniqueInput[]
    delete?: ulasanWhereUniqueInput | ulasanWhereUniqueInput[]
    connect?: ulasanWhereUniqueInput | ulasanWhereUniqueInput[]
    update?: ulasanUpdateWithWhereUniqueWithoutLapanganInput | ulasanUpdateWithWhereUniqueWithoutLapanganInput[]
    updateMany?: ulasanUpdateManyWithWhereWithoutLapanganInput | ulasanUpdateManyWithWhereWithoutLapanganInput[]
    deleteMany?: ulasanScalarWhereInput | ulasanScalarWhereInput[]
  }

  export type LapanganCreateNestedOneWithoutDetailInput = {
    create?: XOR<LapanganCreateWithoutDetailInput, LapanganUncheckedCreateWithoutDetailInput>
    connectOrCreate?: LapanganCreateOrConnectWithoutDetailInput
    connect?: LapanganWhereUniqueInput
  }

  export type LapanganUpdateOneRequiredWithoutDetailNestedInput = {
    create?: XOR<LapanganCreateWithoutDetailInput, LapanganUncheckedCreateWithoutDetailInput>
    connectOrCreate?: LapanganCreateOrConnectWithoutDetailInput
    upsert?: LapanganUpsertWithoutDetailInput
    connect?: LapanganWhereUniqueInput
    update?: XOR<XOR<LapanganUpdateToOneWithWhereWithoutDetailInput, LapanganUpdateWithoutDetailInput>, LapanganUncheckedUpdateWithoutDetailInput>
  }

  export type LapanganCreateNestedOneWithoutGambarListInput = {
    create?: XOR<LapanganCreateWithoutGambarListInput, LapanganUncheckedCreateWithoutGambarListInput>
    connectOrCreate?: LapanganCreateOrConnectWithoutGambarListInput
    connect?: LapanganWhereUniqueInput
  }

  export type LapanganUpdateOneRequiredWithoutGambarListNestedInput = {
    create?: XOR<LapanganCreateWithoutGambarListInput, LapanganUncheckedCreateWithoutGambarListInput>
    connectOrCreate?: LapanganCreateOrConnectWithoutGambarListInput
    upsert?: LapanganUpsertWithoutGambarListInput
    connect?: LapanganWhereUniqueInput
    update?: XOR<XOR<LapanganUpdateToOneWithWhereWithoutGambarListInput, LapanganUpdateWithoutGambarListInput>, LapanganUncheckedUpdateWithoutGambarListInput>
  }

  export type LapanganCreateNestedOneWithoutJadwalInput = {
    create?: XOR<LapanganCreateWithoutJadwalInput, LapanganUncheckedCreateWithoutJadwalInput>
    connectOrCreate?: LapanganCreateOrConnectWithoutJadwalInput
    connect?: LapanganWhereUniqueInput
  }

  export type order_bookingCreateNestedManyWithoutJadwalLapanganInput = {
    create?: XOR<order_bookingCreateWithoutJadwalLapanganInput, order_bookingUncheckedCreateWithoutJadwalLapanganInput> | order_bookingCreateWithoutJadwalLapanganInput[] | order_bookingUncheckedCreateWithoutJadwalLapanganInput[]
    connectOrCreate?: order_bookingCreateOrConnectWithoutJadwalLapanganInput | order_bookingCreateOrConnectWithoutJadwalLapanganInput[]
    createMany?: order_bookingCreateManyJadwalLapanganInputEnvelope
    connect?: order_bookingWhereUniqueInput | order_bookingWhereUniqueInput[]
  }

  export type transaksiCreateNestedManyWithoutJadwalInput = {
    create?: XOR<transaksiCreateWithoutJadwalInput, transaksiUncheckedCreateWithoutJadwalInput> | transaksiCreateWithoutJadwalInput[] | transaksiUncheckedCreateWithoutJadwalInput[]
    connectOrCreate?: transaksiCreateOrConnectWithoutJadwalInput | transaksiCreateOrConnectWithoutJadwalInput[]
    createMany?: transaksiCreateManyJadwalInputEnvelope
    connect?: transaksiWhereUniqueInput | transaksiWhereUniqueInput[]
  }

  export type order_bookingUncheckedCreateNestedManyWithoutJadwalLapanganInput = {
    create?: XOR<order_bookingCreateWithoutJadwalLapanganInput, order_bookingUncheckedCreateWithoutJadwalLapanganInput> | order_bookingCreateWithoutJadwalLapanganInput[] | order_bookingUncheckedCreateWithoutJadwalLapanganInput[]
    connectOrCreate?: order_bookingCreateOrConnectWithoutJadwalLapanganInput | order_bookingCreateOrConnectWithoutJadwalLapanganInput[]
    createMany?: order_bookingCreateManyJadwalLapanganInputEnvelope
    connect?: order_bookingWhereUniqueInput | order_bookingWhereUniqueInput[]
  }

  export type transaksiUncheckedCreateNestedManyWithoutJadwalInput = {
    create?: XOR<transaksiCreateWithoutJadwalInput, transaksiUncheckedCreateWithoutJadwalInput> | transaksiCreateWithoutJadwalInput[] | transaksiUncheckedCreateWithoutJadwalInput[]
    connectOrCreate?: transaksiCreateOrConnectWithoutJadwalInput | transaksiCreateOrConnectWithoutJadwalInput[]
    createMany?: transaksiCreateManyJadwalInputEnvelope
    connect?: transaksiWhereUniqueInput | transaksiWhereUniqueInput[]
  }

  export type Enumjadwal_statusFieldUpdateOperationsInput = {
    set?: $Enums.jadwal_status
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type LapanganUpdateOneRequiredWithoutJadwalNestedInput = {
    create?: XOR<LapanganCreateWithoutJadwalInput, LapanganUncheckedCreateWithoutJadwalInput>
    connectOrCreate?: LapanganCreateOrConnectWithoutJadwalInput
    upsert?: LapanganUpsertWithoutJadwalInput
    connect?: LapanganWhereUniqueInput
    update?: XOR<XOR<LapanganUpdateToOneWithWhereWithoutJadwalInput, LapanganUpdateWithoutJadwalInput>, LapanganUncheckedUpdateWithoutJadwalInput>
  }

  export type order_bookingUpdateManyWithoutJadwalLapanganNestedInput = {
    create?: XOR<order_bookingCreateWithoutJadwalLapanganInput, order_bookingUncheckedCreateWithoutJadwalLapanganInput> | order_bookingCreateWithoutJadwalLapanganInput[] | order_bookingUncheckedCreateWithoutJadwalLapanganInput[]
    connectOrCreate?: order_bookingCreateOrConnectWithoutJadwalLapanganInput | order_bookingCreateOrConnectWithoutJadwalLapanganInput[]
    upsert?: order_bookingUpsertWithWhereUniqueWithoutJadwalLapanganInput | order_bookingUpsertWithWhereUniqueWithoutJadwalLapanganInput[]
    createMany?: order_bookingCreateManyJadwalLapanganInputEnvelope
    set?: order_bookingWhereUniqueInput | order_bookingWhereUniqueInput[]
    disconnect?: order_bookingWhereUniqueInput | order_bookingWhereUniqueInput[]
    delete?: order_bookingWhereUniqueInput | order_bookingWhereUniqueInput[]
    connect?: order_bookingWhereUniqueInput | order_bookingWhereUniqueInput[]
    update?: order_bookingUpdateWithWhereUniqueWithoutJadwalLapanganInput | order_bookingUpdateWithWhereUniqueWithoutJadwalLapanganInput[]
    updateMany?: order_bookingUpdateManyWithWhereWithoutJadwalLapanganInput | order_bookingUpdateManyWithWhereWithoutJadwalLapanganInput[]
    deleteMany?: order_bookingScalarWhereInput | order_bookingScalarWhereInput[]
  }

  export type transaksiUpdateManyWithoutJadwalNestedInput = {
    create?: XOR<transaksiCreateWithoutJadwalInput, transaksiUncheckedCreateWithoutJadwalInput> | transaksiCreateWithoutJadwalInput[] | transaksiUncheckedCreateWithoutJadwalInput[]
    connectOrCreate?: transaksiCreateOrConnectWithoutJadwalInput | transaksiCreateOrConnectWithoutJadwalInput[]
    upsert?: transaksiUpsertWithWhereUniqueWithoutJadwalInput | transaksiUpsertWithWhereUniqueWithoutJadwalInput[]
    createMany?: transaksiCreateManyJadwalInputEnvelope
    set?: transaksiWhereUniqueInput | transaksiWhereUniqueInput[]
    disconnect?: transaksiWhereUniqueInput | transaksiWhereUniqueInput[]
    delete?: transaksiWhereUniqueInput | transaksiWhereUniqueInput[]
    connect?: transaksiWhereUniqueInput | transaksiWhereUniqueInput[]
    update?: transaksiUpdateWithWhereUniqueWithoutJadwalInput | transaksiUpdateWithWhereUniqueWithoutJadwalInput[]
    updateMany?: transaksiUpdateManyWithWhereWithoutJadwalInput | transaksiUpdateManyWithWhereWithoutJadwalInput[]
    deleteMany?: transaksiScalarWhereInput | transaksiScalarWhereInput[]
  }

  export type order_bookingUncheckedUpdateManyWithoutJadwalLapanganNestedInput = {
    create?: XOR<order_bookingCreateWithoutJadwalLapanganInput, order_bookingUncheckedCreateWithoutJadwalLapanganInput> | order_bookingCreateWithoutJadwalLapanganInput[] | order_bookingUncheckedCreateWithoutJadwalLapanganInput[]
    connectOrCreate?: order_bookingCreateOrConnectWithoutJadwalLapanganInput | order_bookingCreateOrConnectWithoutJadwalLapanganInput[]
    upsert?: order_bookingUpsertWithWhereUniqueWithoutJadwalLapanganInput | order_bookingUpsertWithWhereUniqueWithoutJadwalLapanganInput[]
    createMany?: order_bookingCreateManyJadwalLapanganInputEnvelope
    set?: order_bookingWhereUniqueInput | order_bookingWhereUniqueInput[]
    disconnect?: order_bookingWhereUniqueInput | order_bookingWhereUniqueInput[]
    delete?: order_bookingWhereUniqueInput | order_bookingWhereUniqueInput[]
    connect?: order_bookingWhereUniqueInput | order_bookingWhereUniqueInput[]
    update?: order_bookingUpdateWithWhereUniqueWithoutJadwalLapanganInput | order_bookingUpdateWithWhereUniqueWithoutJadwalLapanganInput[]
    updateMany?: order_bookingUpdateManyWithWhereWithoutJadwalLapanganInput | order_bookingUpdateManyWithWhereWithoutJadwalLapanganInput[]
    deleteMany?: order_bookingScalarWhereInput | order_bookingScalarWhereInput[]
  }

  export type transaksiUncheckedUpdateManyWithoutJadwalNestedInput = {
    create?: XOR<transaksiCreateWithoutJadwalInput, transaksiUncheckedCreateWithoutJadwalInput> | transaksiCreateWithoutJadwalInput[] | transaksiUncheckedCreateWithoutJadwalInput[]
    connectOrCreate?: transaksiCreateOrConnectWithoutJadwalInput | transaksiCreateOrConnectWithoutJadwalInput[]
    upsert?: transaksiUpsertWithWhereUniqueWithoutJadwalInput | transaksiUpsertWithWhereUniqueWithoutJadwalInput[]
    createMany?: transaksiCreateManyJadwalInputEnvelope
    set?: transaksiWhereUniqueInput | transaksiWhereUniqueInput[]
    disconnect?: transaksiWhereUniqueInput | transaksiWhereUniqueInput[]
    delete?: transaksiWhereUniqueInput | transaksiWhereUniqueInput[]
    connect?: transaksiWhereUniqueInput | transaksiWhereUniqueInput[]
    update?: transaksiUpdateWithWhereUniqueWithoutJadwalInput | transaksiUpdateWithWhereUniqueWithoutJadwalInput[]
    updateMany?: transaksiUpdateManyWithWhereWithoutJadwalInput | transaksiUpdateManyWithWhereWithoutJadwalInput[]
    deleteMany?: transaksiScalarWhereInput | transaksiScalarWhereInput[]
  }

  export type usersCreateNestedOneWithoutOrdersInput = {
    create?: XOR<usersCreateWithoutOrdersInput, usersUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: usersCreateOrConnectWithoutOrdersInput
    connect?: usersWhereUniqueInput
  }

  export type LapanganCreateNestedOneWithoutOrdersInput = {
    create?: XOR<LapanganCreateWithoutOrdersInput, LapanganUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: LapanganCreateOrConnectWithoutOrdersInput
    connect?: LapanganWhereUniqueInput
  }

  export type JadwalLapanganCreateNestedOneWithoutOrdersInput = {
    create?: XOR<JadwalLapanganCreateWithoutOrdersInput, JadwalLapanganUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: JadwalLapanganCreateOrConnectWithoutOrdersInput
    connect?: JadwalLapanganWhereUniqueInput
  }

  export type transaksiCreateNestedOneWithoutOrderInput = {
    create?: XOR<transaksiCreateWithoutOrderInput, transaksiUncheckedCreateWithoutOrderInput>
    connectOrCreate?: transaksiCreateOrConnectWithoutOrderInput
    connect?: transaksiWhereUniqueInput
  }

  export type refundCreateNestedOneWithoutOrderInput = {
    create?: XOR<refundCreateWithoutOrderInput, refundUncheckedCreateWithoutOrderInput>
    connectOrCreate?: refundCreateOrConnectWithoutOrderInput
    connect?: refundWhereUniqueInput
  }

  export type wallet_historyCreateNestedManyWithoutOrderInput = {
    create?: XOR<wallet_historyCreateWithoutOrderInput, wallet_historyUncheckedCreateWithoutOrderInput> | wallet_historyCreateWithoutOrderInput[] | wallet_historyUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: wallet_historyCreateOrConnectWithoutOrderInput | wallet_historyCreateOrConnectWithoutOrderInput[]
    createMany?: wallet_historyCreateManyOrderInputEnvelope
    connect?: wallet_historyWhereUniqueInput | wallet_historyWhereUniqueInput[]
  }

  export type transaksiUncheckedCreateNestedOneWithoutOrderInput = {
    create?: XOR<transaksiCreateWithoutOrderInput, transaksiUncheckedCreateWithoutOrderInput>
    connectOrCreate?: transaksiCreateOrConnectWithoutOrderInput
    connect?: transaksiWhereUniqueInput
  }

  export type refundUncheckedCreateNestedOneWithoutOrderInput = {
    create?: XOR<refundCreateWithoutOrderInput, refundUncheckedCreateWithoutOrderInput>
    connectOrCreate?: refundCreateOrConnectWithoutOrderInput
    connect?: refundWhereUniqueInput
  }

  export type wallet_historyUncheckedCreateNestedManyWithoutOrderInput = {
    create?: XOR<wallet_historyCreateWithoutOrderInput, wallet_historyUncheckedCreateWithoutOrderInput> | wallet_historyCreateWithoutOrderInput[] | wallet_historyUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: wallet_historyCreateOrConnectWithoutOrderInput | wallet_historyCreateOrConnectWithoutOrderInput[]
    createMany?: wallet_historyCreateManyOrderInputEnvelope
    connect?: wallet_historyWhereUniqueInput | wallet_historyWhereUniqueInput[]
  }

  export type usersUpdateOneRequiredWithoutOrdersNestedInput = {
    create?: XOR<usersCreateWithoutOrdersInput, usersUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: usersCreateOrConnectWithoutOrdersInput
    upsert?: usersUpsertWithoutOrdersInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutOrdersInput, usersUpdateWithoutOrdersInput>, usersUncheckedUpdateWithoutOrdersInput>
  }

  export type LapanganUpdateOneRequiredWithoutOrdersNestedInput = {
    create?: XOR<LapanganCreateWithoutOrdersInput, LapanganUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: LapanganCreateOrConnectWithoutOrdersInput
    upsert?: LapanganUpsertWithoutOrdersInput
    connect?: LapanganWhereUniqueInput
    update?: XOR<XOR<LapanganUpdateToOneWithWhereWithoutOrdersInput, LapanganUpdateWithoutOrdersInput>, LapanganUncheckedUpdateWithoutOrdersInput>
  }

  export type JadwalLapanganUpdateOneRequiredWithoutOrdersNestedInput = {
    create?: XOR<JadwalLapanganCreateWithoutOrdersInput, JadwalLapanganUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: JadwalLapanganCreateOrConnectWithoutOrdersInput
    upsert?: JadwalLapanganUpsertWithoutOrdersInput
    connect?: JadwalLapanganWhereUniqueInput
    update?: XOR<XOR<JadwalLapanganUpdateToOneWithWhereWithoutOrdersInput, JadwalLapanganUpdateWithoutOrdersInput>, JadwalLapanganUncheckedUpdateWithoutOrdersInput>
  }

  export type transaksiUpdateOneWithoutOrderNestedInput = {
    create?: XOR<transaksiCreateWithoutOrderInput, transaksiUncheckedCreateWithoutOrderInput>
    connectOrCreate?: transaksiCreateOrConnectWithoutOrderInput
    upsert?: transaksiUpsertWithoutOrderInput
    disconnect?: transaksiWhereInput | boolean
    delete?: transaksiWhereInput | boolean
    connect?: transaksiWhereUniqueInput
    update?: XOR<XOR<transaksiUpdateToOneWithWhereWithoutOrderInput, transaksiUpdateWithoutOrderInput>, transaksiUncheckedUpdateWithoutOrderInput>
  }

  export type refundUpdateOneWithoutOrderNestedInput = {
    create?: XOR<refundCreateWithoutOrderInput, refundUncheckedCreateWithoutOrderInput>
    connectOrCreate?: refundCreateOrConnectWithoutOrderInput
    upsert?: refundUpsertWithoutOrderInput
    disconnect?: refundWhereInput | boolean
    delete?: refundWhereInput | boolean
    connect?: refundWhereUniqueInput
    update?: XOR<XOR<refundUpdateToOneWithWhereWithoutOrderInput, refundUpdateWithoutOrderInput>, refundUncheckedUpdateWithoutOrderInput>
  }

  export type wallet_historyUpdateManyWithoutOrderNestedInput = {
    create?: XOR<wallet_historyCreateWithoutOrderInput, wallet_historyUncheckedCreateWithoutOrderInput> | wallet_historyCreateWithoutOrderInput[] | wallet_historyUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: wallet_historyCreateOrConnectWithoutOrderInput | wallet_historyCreateOrConnectWithoutOrderInput[]
    upsert?: wallet_historyUpsertWithWhereUniqueWithoutOrderInput | wallet_historyUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: wallet_historyCreateManyOrderInputEnvelope
    set?: wallet_historyWhereUniqueInput | wallet_historyWhereUniqueInput[]
    disconnect?: wallet_historyWhereUniqueInput | wallet_historyWhereUniqueInput[]
    delete?: wallet_historyWhereUniqueInput | wallet_historyWhereUniqueInput[]
    connect?: wallet_historyWhereUniqueInput | wallet_historyWhereUniqueInput[]
    update?: wallet_historyUpdateWithWhereUniqueWithoutOrderInput | wallet_historyUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: wallet_historyUpdateManyWithWhereWithoutOrderInput | wallet_historyUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: wallet_historyScalarWhereInput | wallet_historyScalarWhereInput[]
  }

  export type transaksiUncheckedUpdateOneWithoutOrderNestedInput = {
    create?: XOR<transaksiCreateWithoutOrderInput, transaksiUncheckedCreateWithoutOrderInput>
    connectOrCreate?: transaksiCreateOrConnectWithoutOrderInput
    upsert?: transaksiUpsertWithoutOrderInput
    disconnect?: transaksiWhereInput | boolean
    delete?: transaksiWhereInput | boolean
    connect?: transaksiWhereUniqueInput
    update?: XOR<XOR<transaksiUpdateToOneWithWhereWithoutOrderInput, transaksiUpdateWithoutOrderInput>, transaksiUncheckedUpdateWithoutOrderInput>
  }

  export type refundUncheckedUpdateOneWithoutOrderNestedInput = {
    create?: XOR<refundCreateWithoutOrderInput, refundUncheckedCreateWithoutOrderInput>
    connectOrCreate?: refundCreateOrConnectWithoutOrderInput
    upsert?: refundUpsertWithoutOrderInput
    disconnect?: refundWhereInput | boolean
    delete?: refundWhereInput | boolean
    connect?: refundWhereUniqueInput
    update?: XOR<XOR<refundUpdateToOneWithWhereWithoutOrderInput, refundUpdateWithoutOrderInput>, refundUncheckedUpdateWithoutOrderInput>
  }

  export type wallet_historyUncheckedUpdateManyWithoutOrderNestedInput = {
    create?: XOR<wallet_historyCreateWithoutOrderInput, wallet_historyUncheckedCreateWithoutOrderInput> | wallet_historyCreateWithoutOrderInput[] | wallet_historyUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: wallet_historyCreateOrConnectWithoutOrderInput | wallet_historyCreateOrConnectWithoutOrderInput[]
    upsert?: wallet_historyUpsertWithWhereUniqueWithoutOrderInput | wallet_historyUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: wallet_historyCreateManyOrderInputEnvelope
    set?: wallet_historyWhereUniqueInput | wallet_historyWhereUniqueInput[]
    disconnect?: wallet_historyWhereUniqueInput | wallet_historyWhereUniqueInput[]
    delete?: wallet_historyWhereUniqueInput | wallet_historyWhereUniqueInput[]
    connect?: wallet_historyWhereUniqueInput | wallet_historyWhereUniqueInput[]
    update?: wallet_historyUpdateWithWhereUniqueWithoutOrderInput | wallet_historyUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: wallet_historyUpdateManyWithWhereWithoutOrderInput | wallet_historyUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: wallet_historyScalarWhereInput | wallet_historyScalarWhereInput[]
  }

  export type usersCreateNestedOneWithoutTransaksiInput = {
    create?: XOR<usersCreateWithoutTransaksiInput, usersUncheckedCreateWithoutTransaksiInput>
    connectOrCreate?: usersCreateOrConnectWithoutTransaksiInput
    connect?: usersWhereUniqueInput
  }

  export type LapanganCreateNestedOneWithoutTransaksiInput = {
    create?: XOR<LapanganCreateWithoutTransaksiInput, LapanganUncheckedCreateWithoutTransaksiInput>
    connectOrCreate?: LapanganCreateOrConnectWithoutTransaksiInput
    connect?: LapanganWhereUniqueInput
  }

  export type JadwalLapanganCreateNestedOneWithoutTransaksiInput = {
    create?: XOR<JadwalLapanganCreateWithoutTransaksiInput, JadwalLapanganUncheckedCreateWithoutTransaksiInput>
    connectOrCreate?: JadwalLapanganCreateOrConnectWithoutTransaksiInput
    connect?: JadwalLapanganWhereUniqueInput
  }

  export type order_bookingCreateNestedOneWithoutTransaksiInput = {
    create?: XOR<order_bookingCreateWithoutTransaksiInput, order_bookingUncheckedCreateWithoutTransaksiInput>
    connectOrCreate?: order_bookingCreateOrConnectWithoutTransaksiInput
    connect?: order_bookingWhereUniqueInput
  }

  export type refundCreateNestedOneWithoutTransaksiInput = {
    create?: XOR<refundCreateWithoutTransaksiInput, refundUncheckedCreateWithoutTransaksiInput>
    connectOrCreate?: refundCreateOrConnectWithoutTransaksiInput
    connect?: refundWhereUniqueInput
  }

  export type sewa_raketCreateNestedManyWithoutTransaksiInput = {
    create?: XOR<sewa_raketCreateWithoutTransaksiInput, sewa_raketUncheckedCreateWithoutTransaksiInput> | sewa_raketCreateWithoutTransaksiInput[] | sewa_raketUncheckedCreateWithoutTransaksiInput[]
    connectOrCreate?: sewa_raketCreateOrConnectWithoutTransaksiInput | sewa_raketCreateOrConnectWithoutTransaksiInput[]
    createMany?: sewa_raketCreateManyTransaksiInputEnvelope
    connect?: sewa_raketWhereUniqueInput | sewa_raketWhereUniqueInput[]
  }

  export type refundUncheckedCreateNestedOneWithoutTransaksiInput = {
    create?: XOR<refundCreateWithoutTransaksiInput, refundUncheckedCreateWithoutTransaksiInput>
    connectOrCreate?: refundCreateOrConnectWithoutTransaksiInput
    connect?: refundWhereUniqueInput
  }

  export type sewa_raketUncheckedCreateNestedManyWithoutTransaksiInput = {
    create?: XOR<sewa_raketCreateWithoutTransaksiInput, sewa_raketUncheckedCreateWithoutTransaksiInput> | sewa_raketCreateWithoutTransaksiInput[] | sewa_raketUncheckedCreateWithoutTransaksiInput[]
    connectOrCreate?: sewa_raketCreateOrConnectWithoutTransaksiInput | sewa_raketCreateOrConnectWithoutTransaksiInput[]
    createMany?: sewa_raketCreateManyTransaksiInputEnvelope
    connect?: sewa_raketWhereUniqueInput | sewa_raketWhereUniqueInput[]
  }

  export type Enumtransaksi_status_pembayaranFieldUpdateOperationsInput = {
    set?: $Enums.transaksi_status_pembayaran
  }

  export type usersUpdateOneRequiredWithoutTransaksiNestedInput = {
    create?: XOR<usersCreateWithoutTransaksiInput, usersUncheckedCreateWithoutTransaksiInput>
    connectOrCreate?: usersCreateOrConnectWithoutTransaksiInput
    upsert?: usersUpsertWithoutTransaksiInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutTransaksiInput, usersUpdateWithoutTransaksiInput>, usersUncheckedUpdateWithoutTransaksiInput>
  }

  export type LapanganUpdateOneRequiredWithoutTransaksiNestedInput = {
    create?: XOR<LapanganCreateWithoutTransaksiInput, LapanganUncheckedCreateWithoutTransaksiInput>
    connectOrCreate?: LapanganCreateOrConnectWithoutTransaksiInput
    upsert?: LapanganUpsertWithoutTransaksiInput
    connect?: LapanganWhereUniqueInput
    update?: XOR<XOR<LapanganUpdateToOneWithWhereWithoutTransaksiInput, LapanganUpdateWithoutTransaksiInput>, LapanganUncheckedUpdateWithoutTransaksiInput>
  }

  export type JadwalLapanganUpdateOneRequiredWithoutTransaksiNestedInput = {
    create?: XOR<JadwalLapanganCreateWithoutTransaksiInput, JadwalLapanganUncheckedCreateWithoutTransaksiInput>
    connectOrCreate?: JadwalLapanganCreateOrConnectWithoutTransaksiInput
    upsert?: JadwalLapanganUpsertWithoutTransaksiInput
    connect?: JadwalLapanganWhereUniqueInput
    update?: XOR<XOR<JadwalLapanganUpdateToOneWithWhereWithoutTransaksiInput, JadwalLapanganUpdateWithoutTransaksiInput>, JadwalLapanganUncheckedUpdateWithoutTransaksiInput>
  }

  export type order_bookingUpdateOneWithoutTransaksiNestedInput = {
    create?: XOR<order_bookingCreateWithoutTransaksiInput, order_bookingUncheckedCreateWithoutTransaksiInput>
    connectOrCreate?: order_bookingCreateOrConnectWithoutTransaksiInput
    upsert?: order_bookingUpsertWithoutTransaksiInput
    disconnect?: order_bookingWhereInput | boolean
    delete?: order_bookingWhereInput | boolean
    connect?: order_bookingWhereUniqueInput
    update?: XOR<XOR<order_bookingUpdateToOneWithWhereWithoutTransaksiInput, order_bookingUpdateWithoutTransaksiInput>, order_bookingUncheckedUpdateWithoutTransaksiInput>
  }

  export type refundUpdateOneWithoutTransaksiNestedInput = {
    create?: XOR<refundCreateWithoutTransaksiInput, refundUncheckedCreateWithoutTransaksiInput>
    connectOrCreate?: refundCreateOrConnectWithoutTransaksiInput
    upsert?: refundUpsertWithoutTransaksiInput
    disconnect?: refundWhereInput | boolean
    delete?: refundWhereInput | boolean
    connect?: refundWhereUniqueInput
    update?: XOR<XOR<refundUpdateToOneWithWhereWithoutTransaksiInput, refundUpdateWithoutTransaksiInput>, refundUncheckedUpdateWithoutTransaksiInput>
  }

  export type sewa_raketUpdateManyWithoutTransaksiNestedInput = {
    create?: XOR<sewa_raketCreateWithoutTransaksiInput, sewa_raketUncheckedCreateWithoutTransaksiInput> | sewa_raketCreateWithoutTransaksiInput[] | sewa_raketUncheckedCreateWithoutTransaksiInput[]
    connectOrCreate?: sewa_raketCreateOrConnectWithoutTransaksiInput | sewa_raketCreateOrConnectWithoutTransaksiInput[]
    upsert?: sewa_raketUpsertWithWhereUniqueWithoutTransaksiInput | sewa_raketUpsertWithWhereUniqueWithoutTransaksiInput[]
    createMany?: sewa_raketCreateManyTransaksiInputEnvelope
    set?: sewa_raketWhereUniqueInput | sewa_raketWhereUniqueInput[]
    disconnect?: sewa_raketWhereUniqueInput | sewa_raketWhereUniqueInput[]
    delete?: sewa_raketWhereUniqueInput | sewa_raketWhereUniqueInput[]
    connect?: sewa_raketWhereUniqueInput | sewa_raketWhereUniqueInput[]
    update?: sewa_raketUpdateWithWhereUniqueWithoutTransaksiInput | sewa_raketUpdateWithWhereUniqueWithoutTransaksiInput[]
    updateMany?: sewa_raketUpdateManyWithWhereWithoutTransaksiInput | sewa_raketUpdateManyWithWhereWithoutTransaksiInput[]
    deleteMany?: sewa_raketScalarWhereInput | sewa_raketScalarWhereInput[]
  }

  export type refundUncheckedUpdateOneWithoutTransaksiNestedInput = {
    create?: XOR<refundCreateWithoutTransaksiInput, refundUncheckedCreateWithoutTransaksiInput>
    connectOrCreate?: refundCreateOrConnectWithoutTransaksiInput
    upsert?: refundUpsertWithoutTransaksiInput
    disconnect?: refundWhereInput | boolean
    delete?: refundWhereInput | boolean
    connect?: refundWhereUniqueInput
    update?: XOR<XOR<refundUpdateToOneWithWhereWithoutTransaksiInput, refundUpdateWithoutTransaksiInput>, refundUncheckedUpdateWithoutTransaksiInput>
  }

  export type sewa_raketUncheckedUpdateManyWithoutTransaksiNestedInput = {
    create?: XOR<sewa_raketCreateWithoutTransaksiInput, sewa_raketUncheckedCreateWithoutTransaksiInput> | sewa_raketCreateWithoutTransaksiInput[] | sewa_raketUncheckedCreateWithoutTransaksiInput[]
    connectOrCreate?: sewa_raketCreateOrConnectWithoutTransaksiInput | sewa_raketCreateOrConnectWithoutTransaksiInput[]
    upsert?: sewa_raketUpsertWithWhereUniqueWithoutTransaksiInput | sewa_raketUpsertWithWhereUniqueWithoutTransaksiInput[]
    createMany?: sewa_raketCreateManyTransaksiInputEnvelope
    set?: sewa_raketWhereUniqueInput | sewa_raketWhereUniqueInput[]
    disconnect?: sewa_raketWhereUniqueInput | sewa_raketWhereUniqueInput[]
    delete?: sewa_raketWhereUniqueInput | sewa_raketWhereUniqueInput[]
    connect?: sewa_raketWhereUniqueInput | sewa_raketWhereUniqueInput[]
    update?: sewa_raketUpdateWithWhereUniqueWithoutTransaksiInput | sewa_raketUpdateWithWhereUniqueWithoutTransaksiInput[]
    updateMany?: sewa_raketUpdateManyWithWhereWithoutTransaksiInput | sewa_raketUpdateManyWithWhereWithoutTransaksiInput[]
    deleteMany?: sewa_raketScalarWhereInput | sewa_raketScalarWhereInput[]
  }

  export type sewa_raketCreateNestedManyWithoutRaketInput = {
    create?: XOR<sewa_raketCreateWithoutRaketInput, sewa_raketUncheckedCreateWithoutRaketInput> | sewa_raketCreateWithoutRaketInput[] | sewa_raketUncheckedCreateWithoutRaketInput[]
    connectOrCreate?: sewa_raketCreateOrConnectWithoutRaketInput | sewa_raketCreateOrConnectWithoutRaketInput[]
    createMany?: sewa_raketCreateManyRaketInputEnvelope
    connect?: sewa_raketWhereUniqueInput | sewa_raketWhereUniqueInput[]
  }

  export type sewa_raketUncheckedCreateNestedManyWithoutRaketInput = {
    create?: XOR<sewa_raketCreateWithoutRaketInput, sewa_raketUncheckedCreateWithoutRaketInput> | sewa_raketCreateWithoutRaketInput[] | sewa_raketUncheckedCreateWithoutRaketInput[]
    connectOrCreate?: sewa_raketCreateOrConnectWithoutRaketInput | sewa_raketCreateOrConnectWithoutRaketInput[]
    createMany?: sewa_raketCreateManyRaketInputEnvelope
    connect?: sewa_raketWhereUniqueInput | sewa_raketWhereUniqueInput[]
  }

  export type sewa_raketUpdateManyWithoutRaketNestedInput = {
    create?: XOR<sewa_raketCreateWithoutRaketInput, sewa_raketUncheckedCreateWithoutRaketInput> | sewa_raketCreateWithoutRaketInput[] | sewa_raketUncheckedCreateWithoutRaketInput[]
    connectOrCreate?: sewa_raketCreateOrConnectWithoutRaketInput | sewa_raketCreateOrConnectWithoutRaketInput[]
    upsert?: sewa_raketUpsertWithWhereUniqueWithoutRaketInput | sewa_raketUpsertWithWhereUniqueWithoutRaketInput[]
    createMany?: sewa_raketCreateManyRaketInputEnvelope
    set?: sewa_raketWhereUniqueInput | sewa_raketWhereUniqueInput[]
    disconnect?: sewa_raketWhereUniqueInput | sewa_raketWhereUniqueInput[]
    delete?: sewa_raketWhereUniqueInput | sewa_raketWhereUniqueInput[]
    connect?: sewa_raketWhereUniqueInput | sewa_raketWhereUniqueInput[]
    update?: sewa_raketUpdateWithWhereUniqueWithoutRaketInput | sewa_raketUpdateWithWhereUniqueWithoutRaketInput[]
    updateMany?: sewa_raketUpdateManyWithWhereWithoutRaketInput | sewa_raketUpdateManyWithWhereWithoutRaketInput[]
    deleteMany?: sewa_raketScalarWhereInput | sewa_raketScalarWhereInput[]
  }

  export type sewa_raketUncheckedUpdateManyWithoutRaketNestedInput = {
    create?: XOR<sewa_raketCreateWithoutRaketInput, sewa_raketUncheckedCreateWithoutRaketInput> | sewa_raketCreateWithoutRaketInput[] | sewa_raketUncheckedCreateWithoutRaketInput[]
    connectOrCreate?: sewa_raketCreateOrConnectWithoutRaketInput | sewa_raketCreateOrConnectWithoutRaketInput[]
    upsert?: sewa_raketUpsertWithWhereUniqueWithoutRaketInput | sewa_raketUpsertWithWhereUniqueWithoutRaketInput[]
    createMany?: sewa_raketCreateManyRaketInputEnvelope
    set?: sewa_raketWhereUniqueInput | sewa_raketWhereUniqueInput[]
    disconnect?: sewa_raketWhereUniqueInput | sewa_raketWhereUniqueInput[]
    delete?: sewa_raketWhereUniqueInput | sewa_raketWhereUniqueInput[]
    connect?: sewa_raketWhereUniqueInput | sewa_raketWhereUniqueInput[]
    update?: sewa_raketUpdateWithWhereUniqueWithoutRaketInput | sewa_raketUpdateWithWhereUniqueWithoutRaketInput[]
    updateMany?: sewa_raketUpdateManyWithWhereWithoutRaketInput | sewa_raketUpdateManyWithWhereWithoutRaketInput[]
    deleteMany?: sewa_raketScalarWhereInput | sewa_raketScalarWhereInput[]
  }

  export type transaksiCreateNestedOneWithoutSewa_raketInput = {
    create?: XOR<transaksiCreateWithoutSewa_raketInput, transaksiUncheckedCreateWithoutSewa_raketInput>
    connectOrCreate?: transaksiCreateOrConnectWithoutSewa_raketInput
    connect?: transaksiWhereUniqueInput
  }

  export type raket_padelCreateNestedOneWithoutSewa_raketInput = {
    create?: XOR<raket_padelCreateWithoutSewa_raketInput, raket_padelUncheckedCreateWithoutSewa_raketInput>
    connectOrCreate?: raket_padelCreateOrConnectWithoutSewa_raketInput
    connect?: raket_padelWhereUniqueInput
  }

  export type transaksiUpdateOneRequiredWithoutSewa_raketNestedInput = {
    create?: XOR<transaksiCreateWithoutSewa_raketInput, transaksiUncheckedCreateWithoutSewa_raketInput>
    connectOrCreate?: transaksiCreateOrConnectWithoutSewa_raketInput
    upsert?: transaksiUpsertWithoutSewa_raketInput
    connect?: transaksiWhereUniqueInput
    update?: XOR<XOR<transaksiUpdateToOneWithWhereWithoutSewa_raketInput, transaksiUpdateWithoutSewa_raketInput>, transaksiUncheckedUpdateWithoutSewa_raketInput>
  }

  export type raket_padelUpdateOneRequiredWithoutSewa_raketNestedInput = {
    create?: XOR<raket_padelCreateWithoutSewa_raketInput, raket_padelUncheckedCreateWithoutSewa_raketInput>
    connectOrCreate?: raket_padelCreateOrConnectWithoutSewa_raketInput
    upsert?: raket_padelUpsertWithoutSewa_raketInput
    connect?: raket_padelWhereUniqueInput
    update?: XOR<XOR<raket_padelUpdateToOneWithWhereWithoutSewa_raketInput, raket_padelUpdateWithoutSewa_raketInput>, raket_padelUncheckedUpdateWithoutSewa_raketInput>
  }

  export type usersCreateNestedOneWithoutWalletInput = {
    create?: XOR<usersCreateWithoutWalletInput, usersUncheckedCreateWithoutWalletInput>
    connectOrCreate?: usersCreateOrConnectWithoutWalletInput
    connect?: usersWhereUniqueInput
  }

  export type wallet_historyCreateNestedManyWithoutWalletInput = {
    create?: XOR<wallet_historyCreateWithoutWalletInput, wallet_historyUncheckedCreateWithoutWalletInput> | wallet_historyCreateWithoutWalletInput[] | wallet_historyUncheckedCreateWithoutWalletInput[]
    connectOrCreate?: wallet_historyCreateOrConnectWithoutWalletInput | wallet_historyCreateOrConnectWithoutWalletInput[]
    createMany?: wallet_historyCreateManyWalletInputEnvelope
    connect?: wallet_historyWhereUniqueInput | wallet_historyWhereUniqueInput[]
  }

  export type wallet_historyUncheckedCreateNestedManyWithoutWalletInput = {
    create?: XOR<wallet_historyCreateWithoutWalletInput, wallet_historyUncheckedCreateWithoutWalletInput> | wallet_historyCreateWithoutWalletInput[] | wallet_historyUncheckedCreateWithoutWalletInput[]
    connectOrCreate?: wallet_historyCreateOrConnectWithoutWalletInput | wallet_historyCreateOrConnectWithoutWalletInput[]
    createMany?: wallet_historyCreateManyWalletInputEnvelope
    connect?: wallet_historyWhereUniqueInput | wallet_historyWhereUniqueInput[]
  }

  export type usersUpdateOneRequiredWithoutWalletNestedInput = {
    create?: XOR<usersCreateWithoutWalletInput, usersUncheckedCreateWithoutWalletInput>
    connectOrCreate?: usersCreateOrConnectWithoutWalletInput
    upsert?: usersUpsertWithoutWalletInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutWalletInput, usersUpdateWithoutWalletInput>, usersUncheckedUpdateWithoutWalletInput>
  }

  export type wallet_historyUpdateManyWithoutWalletNestedInput = {
    create?: XOR<wallet_historyCreateWithoutWalletInput, wallet_historyUncheckedCreateWithoutWalletInput> | wallet_historyCreateWithoutWalletInput[] | wallet_historyUncheckedCreateWithoutWalletInput[]
    connectOrCreate?: wallet_historyCreateOrConnectWithoutWalletInput | wallet_historyCreateOrConnectWithoutWalletInput[]
    upsert?: wallet_historyUpsertWithWhereUniqueWithoutWalletInput | wallet_historyUpsertWithWhereUniqueWithoutWalletInput[]
    createMany?: wallet_historyCreateManyWalletInputEnvelope
    set?: wallet_historyWhereUniqueInput | wallet_historyWhereUniqueInput[]
    disconnect?: wallet_historyWhereUniqueInput | wallet_historyWhereUniqueInput[]
    delete?: wallet_historyWhereUniqueInput | wallet_historyWhereUniqueInput[]
    connect?: wallet_historyWhereUniqueInput | wallet_historyWhereUniqueInput[]
    update?: wallet_historyUpdateWithWhereUniqueWithoutWalletInput | wallet_historyUpdateWithWhereUniqueWithoutWalletInput[]
    updateMany?: wallet_historyUpdateManyWithWhereWithoutWalletInput | wallet_historyUpdateManyWithWhereWithoutWalletInput[]
    deleteMany?: wallet_historyScalarWhereInput | wallet_historyScalarWhereInput[]
  }

  export type wallet_historyUncheckedUpdateManyWithoutWalletNestedInput = {
    create?: XOR<wallet_historyCreateWithoutWalletInput, wallet_historyUncheckedCreateWithoutWalletInput> | wallet_historyCreateWithoutWalletInput[] | wallet_historyUncheckedCreateWithoutWalletInput[]
    connectOrCreate?: wallet_historyCreateOrConnectWithoutWalletInput | wallet_historyCreateOrConnectWithoutWalletInput[]
    upsert?: wallet_historyUpsertWithWhereUniqueWithoutWalletInput | wallet_historyUpsertWithWhereUniqueWithoutWalletInput[]
    createMany?: wallet_historyCreateManyWalletInputEnvelope
    set?: wallet_historyWhereUniqueInput | wallet_historyWhereUniqueInput[]
    disconnect?: wallet_historyWhereUniqueInput | wallet_historyWhereUniqueInput[]
    delete?: wallet_historyWhereUniqueInput | wallet_historyWhereUniqueInput[]
    connect?: wallet_historyWhereUniqueInput | wallet_historyWhereUniqueInput[]
    update?: wallet_historyUpdateWithWhereUniqueWithoutWalletInput | wallet_historyUpdateWithWhereUniqueWithoutWalletInput[]
    updateMany?: wallet_historyUpdateManyWithWhereWithoutWalletInput | wallet_historyUpdateManyWithWhereWithoutWalletInput[]
    deleteMany?: wallet_historyScalarWhereInput | wallet_historyScalarWhereInput[]
  }

  export type wallet_userCreateNestedOneWithoutHistoryInput = {
    create?: XOR<wallet_userCreateWithoutHistoryInput, wallet_userUncheckedCreateWithoutHistoryInput>
    connectOrCreate?: wallet_userCreateOrConnectWithoutHistoryInput
    connect?: wallet_userWhereUniqueInput
  }

  export type order_bookingCreateNestedOneWithoutWallet_historiesInput = {
    create?: XOR<order_bookingCreateWithoutWallet_historiesInput, order_bookingUncheckedCreateWithoutWallet_historiesInput>
    connectOrCreate?: order_bookingCreateOrConnectWithoutWallet_historiesInput
    connect?: order_bookingWhereUniqueInput
  }

  export type Enumwallet_tipeFieldUpdateOperationsInput = {
    set?: $Enums.wallet_tipe
  }

  export type wallet_userUpdateOneRequiredWithoutHistoryNestedInput = {
    create?: XOR<wallet_userCreateWithoutHistoryInput, wallet_userUncheckedCreateWithoutHistoryInput>
    connectOrCreate?: wallet_userCreateOrConnectWithoutHistoryInput
    upsert?: wallet_userUpsertWithoutHistoryInput
    connect?: wallet_userWhereUniqueInput
    update?: XOR<XOR<wallet_userUpdateToOneWithWhereWithoutHistoryInput, wallet_userUpdateWithoutHistoryInput>, wallet_userUncheckedUpdateWithoutHistoryInput>
  }

  export type order_bookingUpdateOneWithoutWallet_historiesNestedInput = {
    create?: XOR<order_bookingCreateWithoutWallet_historiesInput, order_bookingUncheckedCreateWithoutWallet_historiesInput>
    connectOrCreate?: order_bookingCreateOrConnectWithoutWallet_historiesInput
    upsert?: order_bookingUpsertWithoutWallet_historiesInput
    disconnect?: order_bookingWhereInput | boolean
    delete?: order_bookingWhereInput | boolean
    connect?: order_bookingWhereUniqueInput
    update?: XOR<XOR<order_bookingUpdateToOneWithWhereWithoutWallet_historiesInput, order_bookingUpdateWithoutWallet_historiesInput>, order_bookingUncheckedUpdateWithoutWallet_historiesInput>
  }

  export type usersCreateNestedOneWithoutRefundInput = {
    create?: XOR<usersCreateWithoutRefundInput, usersUncheckedCreateWithoutRefundInput>
    connectOrCreate?: usersCreateOrConnectWithoutRefundInput
    connect?: usersWhereUniqueInput
  }

  export type transaksiCreateNestedOneWithoutRefundInput = {
    create?: XOR<transaksiCreateWithoutRefundInput, transaksiUncheckedCreateWithoutRefundInput>
    connectOrCreate?: transaksiCreateOrConnectWithoutRefundInput
    connect?: transaksiWhereUniqueInput
  }

  export type order_bookingCreateNestedOneWithoutRefundInput = {
    create?: XOR<order_bookingCreateWithoutRefundInput, order_bookingUncheckedCreateWithoutRefundInput>
    connectOrCreate?: order_bookingCreateOrConnectWithoutRefundInput
    connect?: order_bookingWhereUniqueInput
  }

  export type Enumrefund_statusFieldUpdateOperationsInput = {
    set?: $Enums.refund_status
  }

  export type usersUpdateOneRequiredWithoutRefundNestedInput = {
    create?: XOR<usersCreateWithoutRefundInput, usersUncheckedCreateWithoutRefundInput>
    connectOrCreate?: usersCreateOrConnectWithoutRefundInput
    upsert?: usersUpsertWithoutRefundInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutRefundInput, usersUpdateWithoutRefundInput>, usersUncheckedUpdateWithoutRefundInput>
  }

  export type transaksiUpdateOneRequiredWithoutRefundNestedInput = {
    create?: XOR<transaksiCreateWithoutRefundInput, transaksiUncheckedCreateWithoutRefundInput>
    connectOrCreate?: transaksiCreateOrConnectWithoutRefundInput
    upsert?: transaksiUpsertWithoutRefundInput
    connect?: transaksiWhereUniqueInput
    update?: XOR<XOR<transaksiUpdateToOneWithWhereWithoutRefundInput, transaksiUpdateWithoutRefundInput>, transaksiUncheckedUpdateWithoutRefundInput>
  }

  export type order_bookingUpdateOneRequiredWithoutRefundNestedInput = {
    create?: XOR<order_bookingCreateWithoutRefundInput, order_bookingUncheckedCreateWithoutRefundInput>
    connectOrCreate?: order_bookingCreateOrConnectWithoutRefundInput
    upsert?: order_bookingUpsertWithoutRefundInput
    connect?: order_bookingWhereUniqueInput
    update?: XOR<XOR<order_bookingUpdateToOneWithWhereWithoutRefundInput, order_bookingUpdateWithoutRefundInput>, order_bookingUncheckedUpdateWithoutRefundInput>
  }

  export type usersCreateNestedOneWithoutNotifikasiInput = {
    create?: XOR<usersCreateWithoutNotifikasiInput, usersUncheckedCreateWithoutNotifikasiInput>
    connectOrCreate?: usersCreateOrConnectWithoutNotifikasiInput
    connect?: usersWhereUniqueInput
  }

  export type usersUpdateOneRequiredWithoutNotifikasiNestedInput = {
    create?: XOR<usersCreateWithoutNotifikasiInput, usersUncheckedCreateWithoutNotifikasiInput>
    connectOrCreate?: usersCreateOrConnectWithoutNotifikasiInput
    upsert?: usersUpsertWithoutNotifikasiInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutNotifikasiInput, usersUpdateWithoutNotifikasiInput>, usersUncheckedUpdateWithoutNotifikasiInput>
  }

  export type usersCreateNestedOneWithoutUlasanInput = {
    create?: XOR<usersCreateWithoutUlasanInput, usersUncheckedCreateWithoutUlasanInput>
    connectOrCreate?: usersCreateOrConnectWithoutUlasanInput
    connect?: usersWhereUniqueInput
  }

  export type LapanganCreateNestedOneWithoutUlasanInput = {
    create?: XOR<LapanganCreateWithoutUlasanInput, LapanganUncheckedCreateWithoutUlasanInput>
    connectOrCreate?: LapanganCreateOrConnectWithoutUlasanInput
    connect?: LapanganWhereUniqueInput
  }

  export type usersUpdateOneRequiredWithoutUlasanNestedInput = {
    create?: XOR<usersCreateWithoutUlasanInput, usersUncheckedCreateWithoutUlasanInput>
    connectOrCreate?: usersCreateOrConnectWithoutUlasanInput
    upsert?: usersUpsertWithoutUlasanInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutUlasanInput, usersUpdateWithoutUlasanInput>, usersUncheckedUpdateWithoutUlasanInput>
  }

  export type LapanganUpdateOneRequiredWithoutUlasanNestedInput = {
    create?: XOR<LapanganCreateWithoutUlasanInput, LapanganUncheckedCreateWithoutUlasanInput>
    connectOrCreate?: LapanganCreateOrConnectWithoutUlasanInput
    upsert?: LapanganUpsertWithoutUlasanInput
    connect?: LapanganWhereUniqueInput
    update?: XOR<XOR<LapanganUpdateToOneWithWhereWithoutUlasanInput, LapanganUpdateWithoutUlasanInput>, LapanganUncheckedUpdateWithoutUlasanInput>
  }

  export type MitraCreateNestedOneWithoutPendapatanInput = {
    create?: XOR<MitraCreateWithoutPendapatanInput, MitraUncheckedCreateWithoutPendapatanInput>
    connectOrCreate?: MitraCreateOrConnectWithoutPendapatanInput
    connect?: MitraWhereUniqueInput
  }

  export type MitraUpdateOneRequiredWithoutPendapatanNestedInput = {
    create?: XOR<MitraCreateWithoutPendapatanInput, MitraUncheckedCreateWithoutPendapatanInput>
    connectOrCreate?: MitraCreateOrConnectWithoutPendapatanInput
    upsert?: MitraUpsertWithoutPendapatanInput
    connect?: MitraWhereUniqueInput
    update?: XOR<XOR<MitraUpdateToOneWithWhereWithoutPendapatanInput, MitraUpdateWithoutPendapatanInput>, MitraUncheckedUpdateWithoutPendapatanInput>
  }

  export type MitraCreateNestedOneWithoutPencairanInput = {
    create?: XOR<MitraCreateWithoutPencairanInput, MitraUncheckedCreateWithoutPencairanInput>
    connectOrCreate?: MitraCreateOrConnectWithoutPencairanInput
    connect?: MitraWhereUniqueInput
  }

  export type Enumpencairan_statusFieldUpdateOperationsInput = {
    set?: $Enums.pencairan_status
  }

  export type MitraUpdateOneRequiredWithoutPencairanNestedInput = {
    create?: XOR<MitraCreateWithoutPencairanInput, MitraUncheckedCreateWithoutPencairanInput>
    connectOrCreate?: MitraCreateOrConnectWithoutPencairanInput
    upsert?: MitraUpsertWithoutPencairanInput
    connect?: MitraWhereUniqueInput
    update?: XOR<XOR<MitraUpdateToOneWithWhereWithoutPencairanInput, MitraUpdateWithoutPencairanInput>, MitraUncheckedUpdateWithoutPencairanInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedEnumusers_roleFilter<$PrismaModel = never> = {
    equals?: $Enums.users_role | Enumusers_roleFieldRefInput<$PrismaModel>
    in?: $Enums.users_role[]
    notIn?: $Enums.users_role[]
    not?: NestedEnumusers_roleFilter<$PrismaModel> | $Enums.users_role
  }

  export type NestedEnumusers_statusFilter<$PrismaModel = never> = {
    equals?: $Enums.users_status | Enumusers_statusFieldRefInput<$PrismaModel>
    in?: $Enums.users_status[]
    notIn?: $Enums.users_status[]
    not?: NestedEnumusers_statusFilter<$PrismaModel> | $Enums.users_status
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumusers_roleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.users_role | Enumusers_roleFieldRefInput<$PrismaModel>
    in?: $Enums.users_role[]
    notIn?: $Enums.users_role[]
    not?: NestedEnumusers_roleWithAggregatesFilter<$PrismaModel> | $Enums.users_role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumusers_roleFilter<$PrismaModel>
    _max?: NestedEnumusers_roleFilter<$PrismaModel>
  }

  export type NestedEnumusers_statusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.users_status | Enumusers_statusFieldRefInput<$PrismaModel>
    in?: $Enums.users_status[]
    notIn?: $Enums.users_status[]
    not?: NestedEnumusers_statusWithAggregatesFilter<$PrismaModel> | $Enums.users_status
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumusers_statusFilter<$PrismaModel>
    _max?: NestedEnumusers_statusFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnummitra_statusFilter<$PrismaModel = never> = {
    equals?: $Enums.mitra_status | Enummitra_statusFieldRefInput<$PrismaModel>
    in?: $Enums.mitra_status[]
    notIn?: $Enums.mitra_status[]
    not?: NestedEnummitra_statusFilter<$PrismaModel> | $Enums.mitra_status
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnummitra_statusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.mitra_status | Enummitra_statusFieldRefInput<$PrismaModel>
    in?: $Enums.mitra_status[]
    notIn?: $Enums.mitra_status[]
    not?: NestedEnummitra_statusWithAggregatesFilter<$PrismaModel> | $Enums.mitra_status
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnummitra_statusFilter<$PrismaModel>
    _max?: NestedEnummitra_statusFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedEnumlapangan_statusFilter<$PrismaModel = never> = {
    equals?: $Enums.lapangan_status | Enumlapangan_statusFieldRefInput<$PrismaModel>
    in?: $Enums.lapangan_status[]
    notIn?: $Enums.lapangan_status[]
    not?: NestedEnumlapangan_statusFilter<$PrismaModel> | $Enums.lapangan_status
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedEnumlapangan_statusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.lapangan_status | Enumlapangan_statusFieldRefInput<$PrismaModel>
    in?: $Enums.lapangan_status[]
    notIn?: $Enums.lapangan_status[]
    not?: NestedEnumlapangan_statusWithAggregatesFilter<$PrismaModel> | $Enums.lapangan_status
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumlapangan_statusFilter<$PrismaModel>
    _max?: NestedEnumlapangan_statusFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumjadwal_statusFilter<$PrismaModel = never> = {
    equals?: $Enums.jadwal_status | Enumjadwal_statusFieldRefInput<$PrismaModel>
    in?: $Enums.jadwal_status[]
    notIn?: $Enums.jadwal_status[]
    not?: NestedEnumjadwal_statusFilter<$PrismaModel> | $Enums.jadwal_status
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedEnumjadwal_statusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.jadwal_status | Enumjadwal_statusFieldRefInput<$PrismaModel>
    in?: $Enums.jadwal_status[]
    notIn?: $Enums.jadwal_status[]
    not?: NestedEnumjadwal_statusWithAggregatesFilter<$PrismaModel> | $Enums.jadwal_status
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumjadwal_statusFilter<$PrismaModel>
    _max?: NestedEnumjadwal_statusFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumtransaksi_status_pembayaranFilter<$PrismaModel = never> = {
    equals?: $Enums.transaksi_status_pembayaran | Enumtransaksi_status_pembayaranFieldRefInput<$PrismaModel>
    in?: $Enums.transaksi_status_pembayaran[]
    notIn?: $Enums.transaksi_status_pembayaran[]
    not?: NestedEnumtransaksi_status_pembayaranFilter<$PrismaModel> | $Enums.transaksi_status_pembayaran
  }

  export type NestedEnumtransaksi_status_pembayaranWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.transaksi_status_pembayaran | Enumtransaksi_status_pembayaranFieldRefInput<$PrismaModel>
    in?: $Enums.transaksi_status_pembayaran[]
    notIn?: $Enums.transaksi_status_pembayaran[]
    not?: NestedEnumtransaksi_status_pembayaranWithAggregatesFilter<$PrismaModel> | $Enums.transaksi_status_pembayaran
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumtransaksi_status_pembayaranFilter<$PrismaModel>
    _max?: NestedEnumtransaksi_status_pembayaranFilter<$PrismaModel>
  }

  export type NestedEnumwallet_tipeFilter<$PrismaModel = never> = {
    equals?: $Enums.wallet_tipe | Enumwallet_tipeFieldRefInput<$PrismaModel>
    in?: $Enums.wallet_tipe[]
    notIn?: $Enums.wallet_tipe[]
    not?: NestedEnumwallet_tipeFilter<$PrismaModel> | $Enums.wallet_tipe
  }

  export type NestedEnumwallet_tipeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.wallet_tipe | Enumwallet_tipeFieldRefInput<$PrismaModel>
    in?: $Enums.wallet_tipe[]
    notIn?: $Enums.wallet_tipe[]
    not?: NestedEnumwallet_tipeWithAggregatesFilter<$PrismaModel> | $Enums.wallet_tipe
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumwallet_tipeFilter<$PrismaModel>
    _max?: NestedEnumwallet_tipeFilter<$PrismaModel>
  }

  export type NestedEnumrefund_statusFilter<$PrismaModel = never> = {
    equals?: $Enums.refund_status | Enumrefund_statusFieldRefInput<$PrismaModel>
    in?: $Enums.refund_status[]
    notIn?: $Enums.refund_status[]
    not?: NestedEnumrefund_statusFilter<$PrismaModel> | $Enums.refund_status
  }

  export type NestedEnumrefund_statusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.refund_status | Enumrefund_statusFieldRefInput<$PrismaModel>
    in?: $Enums.refund_status[]
    notIn?: $Enums.refund_status[]
    not?: NestedEnumrefund_statusWithAggregatesFilter<$PrismaModel> | $Enums.refund_status
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumrefund_statusFilter<$PrismaModel>
    _max?: NestedEnumrefund_statusFilter<$PrismaModel>
  }

  export type NestedEnumpencairan_statusFilter<$PrismaModel = never> = {
    equals?: $Enums.pencairan_status | Enumpencairan_statusFieldRefInput<$PrismaModel>
    in?: $Enums.pencairan_status[]
    notIn?: $Enums.pencairan_status[]
    not?: NestedEnumpencairan_statusFilter<$PrismaModel> | $Enums.pencairan_status
  }

  export type NestedEnumpencairan_statusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.pencairan_status | Enumpencairan_statusFieldRefInput<$PrismaModel>
    in?: $Enums.pencairan_status[]
    notIn?: $Enums.pencairan_status[]
    not?: NestedEnumpencairan_statusWithAggregatesFilter<$PrismaModel> | $Enums.pencairan_status
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumpencairan_statusFilter<$PrismaModel>
    _max?: NestedEnumpencairan_statusFilter<$PrismaModel>
  }

  export type MitraCreateWithoutUserInput = {
    nama_usaha: string
    alamat_usaha: string
    no_ktp: string
    foto_ktp: string
    withdraw_type?: string | null
    withdraw_day?: number | null
    bank_mitra?: string | null
    no_rekening_mitra?: string | null
    status?: $Enums.mitra_status
    created_at?: Date | string
    lapangan?: LapanganCreateNestedManyWithoutMitraInput
    pendapatan?: pendapatan_mitraCreateNestedManyWithoutMitraInput
    pencairan?: pencairan_pendapatanCreateNestedManyWithoutMitraInput
  }

  export type MitraUncheckedCreateWithoutUserInput = {
    id?: number
    nama_usaha: string
    alamat_usaha: string
    no_ktp: string
    foto_ktp: string
    withdraw_type?: string | null
    withdraw_day?: number | null
    bank_mitra?: string | null
    no_rekening_mitra?: string | null
    status?: $Enums.mitra_status
    created_at?: Date | string
    lapangan?: LapanganUncheckedCreateNestedManyWithoutMitraInput
    pendapatan?: pendapatan_mitraUncheckedCreateNestedManyWithoutMitraInput
    pencairan?: pencairan_pendapatanUncheckedCreateNestedManyWithoutMitraInput
  }

  export type MitraCreateOrConnectWithoutUserInput = {
    where: MitraWhereUniqueInput
    create: XOR<MitraCreateWithoutUserInput, MitraUncheckedCreateWithoutUserInput>
  }

  export type order_bookingCreateWithoutUserInput = {
    tanggal: Date | string
    jam_mulai: string
    jam_selesai: string
    total_harga: Decimal | DecimalJsLike | number | string
    status: string
    sewa_raket?: boolean
    biaya_raket?: number
    created_at?: Date | string
    expired_at?: Date | string | null
    lapangan: LapanganCreateNestedOneWithoutOrdersInput
    jadwalLapangan: JadwalLapanganCreateNestedOneWithoutOrdersInput
    transaksi?: transaksiCreateNestedOneWithoutOrderInput
    refund?: refundCreateNestedOneWithoutOrderInput
    wallet_histories?: wallet_historyCreateNestedManyWithoutOrderInput
  }

  export type order_bookingUncheckedCreateWithoutUserInput = {
    id?: number
    lapangan_id: number
    jadwalLapanganId: number
    tanggal: Date | string
    jam_mulai: string
    jam_selesai: string
    total_harga: Decimal | DecimalJsLike | number | string
    status: string
    sewa_raket?: boolean
    biaya_raket?: number
    created_at?: Date | string
    expired_at?: Date | string | null
    transaksi?: transaksiUncheckedCreateNestedOneWithoutOrderInput
    refund?: refundUncheckedCreateNestedOneWithoutOrderInput
    wallet_histories?: wallet_historyUncheckedCreateNestedManyWithoutOrderInput
  }

  export type order_bookingCreateOrConnectWithoutUserInput = {
    where: order_bookingWhereUniqueInput
    create: XOR<order_bookingCreateWithoutUserInput, order_bookingUncheckedCreateWithoutUserInput>
  }

  export type order_bookingCreateManyUserInputEnvelope = {
    data: order_bookingCreateManyUserInput | order_bookingCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type transaksiCreateWithoutUserInput = {
    total_harga: Decimal | DecimalJsLike | number | string
    status_pembayaran?: $Enums.transaksi_status_pembayaran
    created_at?: Date | string
    lapangan: LapanganCreateNestedOneWithoutTransaksiInput
    jadwal: JadwalLapanganCreateNestedOneWithoutTransaksiInput
    order?: order_bookingCreateNestedOneWithoutTransaksiInput
    refund?: refundCreateNestedOneWithoutTransaksiInput
    sewa_raket?: sewa_raketCreateNestedManyWithoutTransaksiInput
  }

  export type transaksiUncheckedCreateWithoutUserInput = {
    id?: number
    lapangan_id: number
    jadwal_id: number
    order_id?: number | null
    total_harga: Decimal | DecimalJsLike | number | string
    status_pembayaran?: $Enums.transaksi_status_pembayaran
    created_at?: Date | string
    refund?: refundUncheckedCreateNestedOneWithoutTransaksiInput
    sewa_raket?: sewa_raketUncheckedCreateNestedManyWithoutTransaksiInput
  }

  export type transaksiCreateOrConnectWithoutUserInput = {
    where: transaksiWhereUniqueInput
    create: XOR<transaksiCreateWithoutUserInput, transaksiUncheckedCreateWithoutUserInput>
  }

  export type transaksiCreateManyUserInputEnvelope = {
    data: transaksiCreateManyUserInput | transaksiCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type notifikasiCreateWithoutUserInput = {
    pesan: string
    dibaca?: boolean
    created_at?: Date | string
  }

  export type notifikasiUncheckedCreateWithoutUserInput = {
    id?: number
    pesan: string
    dibaca?: boolean
    created_at?: Date | string
  }

  export type notifikasiCreateOrConnectWithoutUserInput = {
    where: notifikasiWhereUniqueInput
    create: XOR<notifikasiCreateWithoutUserInput, notifikasiUncheckedCreateWithoutUserInput>
  }

  export type notifikasiCreateManyUserInputEnvelope = {
    data: notifikasiCreateManyUserInput | notifikasiCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ulasanCreateWithoutUserInput = {
    rating: number
    komentar?: string | null
    created_at?: Date | string
    lapangan: LapanganCreateNestedOneWithoutUlasanInput
  }

  export type ulasanUncheckedCreateWithoutUserInput = {
    id?: number
    lapangan_id: number
    rating: number
    komentar?: string | null
    created_at?: Date | string
  }

  export type ulasanCreateOrConnectWithoutUserInput = {
    where: ulasanWhereUniqueInput
    create: XOR<ulasanCreateWithoutUserInput, ulasanUncheckedCreateWithoutUserInput>
  }

  export type ulasanCreateManyUserInputEnvelope = {
    data: ulasanCreateManyUserInput | ulasanCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type wallet_userCreateWithoutUserInput = {
    saldo?: number
    updated_at?: Date | string
    history?: wallet_historyCreateNestedManyWithoutWalletInput
  }

  export type wallet_userUncheckedCreateWithoutUserInput = {
    id?: number
    saldo?: number
    updated_at?: Date | string
    history?: wallet_historyUncheckedCreateNestedManyWithoutWalletInput
  }

  export type wallet_userCreateOrConnectWithoutUserInput = {
    where: wallet_userWhereUniqueInput
    create: XOR<wallet_userCreateWithoutUserInput, wallet_userUncheckedCreateWithoutUserInput>
  }

  export type refundCreateWithoutUserInput = {
    jumlah: Decimal | DecimalJsLike | number | string
    alasan?: string | null
    status?: $Enums.refund_status
    created_at?: Date | string
    processed_at?: Date | string | null
    transaksi: transaksiCreateNestedOneWithoutRefundInput
    order: order_bookingCreateNestedOneWithoutRefundInput
  }

  export type refundUncheckedCreateWithoutUserInput = {
    id?: number
    transaksi_id: number
    order_id: number
    jumlah: Decimal | DecimalJsLike | number | string
    alasan?: string | null
    status?: $Enums.refund_status
    created_at?: Date | string
    processed_at?: Date | string | null
  }

  export type refundCreateOrConnectWithoutUserInput = {
    where: refundWhereUniqueInput
    create: XOR<refundCreateWithoutUserInput, refundUncheckedCreateWithoutUserInput>
  }

  export type refundCreateManyUserInputEnvelope = {
    data: refundCreateManyUserInput | refundCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type MitraUpsertWithoutUserInput = {
    update: XOR<MitraUpdateWithoutUserInput, MitraUncheckedUpdateWithoutUserInput>
    create: XOR<MitraCreateWithoutUserInput, MitraUncheckedCreateWithoutUserInput>
    where?: MitraWhereInput
  }

  export type MitraUpdateToOneWithWhereWithoutUserInput = {
    where?: MitraWhereInput
    data: XOR<MitraUpdateWithoutUserInput, MitraUncheckedUpdateWithoutUserInput>
  }

  export type MitraUpdateWithoutUserInput = {
    nama_usaha?: StringFieldUpdateOperationsInput | string
    alamat_usaha?: StringFieldUpdateOperationsInput | string
    no_ktp?: StringFieldUpdateOperationsInput | string
    foto_ktp?: StringFieldUpdateOperationsInput | string
    withdraw_type?: NullableStringFieldUpdateOperationsInput | string | null
    withdraw_day?: NullableIntFieldUpdateOperationsInput | number | null
    bank_mitra?: NullableStringFieldUpdateOperationsInput | string | null
    no_rekening_mitra?: NullableStringFieldUpdateOperationsInput | string | null
    status?: Enummitra_statusFieldUpdateOperationsInput | $Enums.mitra_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    lapangan?: LapanganUpdateManyWithoutMitraNestedInput
    pendapatan?: pendapatan_mitraUpdateManyWithoutMitraNestedInput
    pencairan?: pencairan_pendapatanUpdateManyWithoutMitraNestedInput
  }

  export type MitraUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    nama_usaha?: StringFieldUpdateOperationsInput | string
    alamat_usaha?: StringFieldUpdateOperationsInput | string
    no_ktp?: StringFieldUpdateOperationsInput | string
    foto_ktp?: StringFieldUpdateOperationsInput | string
    withdraw_type?: NullableStringFieldUpdateOperationsInput | string | null
    withdraw_day?: NullableIntFieldUpdateOperationsInput | number | null
    bank_mitra?: NullableStringFieldUpdateOperationsInput | string | null
    no_rekening_mitra?: NullableStringFieldUpdateOperationsInput | string | null
    status?: Enummitra_statusFieldUpdateOperationsInput | $Enums.mitra_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    lapangan?: LapanganUncheckedUpdateManyWithoutMitraNestedInput
    pendapatan?: pendapatan_mitraUncheckedUpdateManyWithoutMitraNestedInput
    pencairan?: pencairan_pendapatanUncheckedUpdateManyWithoutMitraNestedInput
  }

  export type order_bookingUpsertWithWhereUniqueWithoutUserInput = {
    where: order_bookingWhereUniqueInput
    update: XOR<order_bookingUpdateWithoutUserInput, order_bookingUncheckedUpdateWithoutUserInput>
    create: XOR<order_bookingCreateWithoutUserInput, order_bookingUncheckedCreateWithoutUserInput>
  }

  export type order_bookingUpdateWithWhereUniqueWithoutUserInput = {
    where: order_bookingWhereUniqueInput
    data: XOR<order_bookingUpdateWithoutUserInput, order_bookingUncheckedUpdateWithoutUserInput>
  }

  export type order_bookingUpdateManyWithWhereWithoutUserInput = {
    where: order_bookingScalarWhereInput
    data: XOR<order_bookingUpdateManyMutationInput, order_bookingUncheckedUpdateManyWithoutUserInput>
  }

  export type order_bookingScalarWhereInput = {
    AND?: order_bookingScalarWhereInput | order_bookingScalarWhereInput[]
    OR?: order_bookingScalarWhereInput[]
    NOT?: order_bookingScalarWhereInput | order_bookingScalarWhereInput[]
    id?: IntFilter<"order_booking"> | number
    user_id?: IntFilter<"order_booking"> | number
    lapangan_id?: IntFilter<"order_booking"> | number
    jadwalLapanganId?: IntFilter<"order_booking"> | number
    tanggal?: DateTimeFilter<"order_booking"> | Date | string
    jam_mulai?: StringFilter<"order_booking"> | string
    jam_selesai?: StringFilter<"order_booking"> | string
    total_harga?: DecimalFilter<"order_booking"> | Decimal | DecimalJsLike | number | string
    status?: StringFilter<"order_booking"> | string
    sewa_raket?: BoolFilter<"order_booking"> | boolean
    biaya_raket?: IntFilter<"order_booking"> | number
    created_at?: DateTimeFilter<"order_booking"> | Date | string
    expired_at?: DateTimeNullableFilter<"order_booking"> | Date | string | null
  }

  export type transaksiUpsertWithWhereUniqueWithoutUserInput = {
    where: transaksiWhereUniqueInput
    update: XOR<transaksiUpdateWithoutUserInput, transaksiUncheckedUpdateWithoutUserInput>
    create: XOR<transaksiCreateWithoutUserInput, transaksiUncheckedCreateWithoutUserInput>
  }

  export type transaksiUpdateWithWhereUniqueWithoutUserInput = {
    where: transaksiWhereUniqueInput
    data: XOR<transaksiUpdateWithoutUserInput, transaksiUncheckedUpdateWithoutUserInput>
  }

  export type transaksiUpdateManyWithWhereWithoutUserInput = {
    where: transaksiScalarWhereInput
    data: XOR<transaksiUpdateManyMutationInput, transaksiUncheckedUpdateManyWithoutUserInput>
  }

  export type transaksiScalarWhereInput = {
    AND?: transaksiScalarWhereInput | transaksiScalarWhereInput[]
    OR?: transaksiScalarWhereInput[]
    NOT?: transaksiScalarWhereInput | transaksiScalarWhereInput[]
    id?: IntFilter<"transaksi"> | number
    user_id?: IntFilter<"transaksi"> | number
    lapangan_id?: IntFilter<"transaksi"> | number
    jadwal_id?: IntFilter<"transaksi"> | number
    order_id?: IntNullableFilter<"transaksi"> | number | null
    total_harga?: DecimalFilter<"transaksi"> | Decimal | DecimalJsLike | number | string
    status_pembayaran?: Enumtransaksi_status_pembayaranFilter<"transaksi"> | $Enums.transaksi_status_pembayaran
    created_at?: DateTimeFilter<"transaksi"> | Date | string
  }

  export type notifikasiUpsertWithWhereUniqueWithoutUserInput = {
    where: notifikasiWhereUniqueInput
    update: XOR<notifikasiUpdateWithoutUserInput, notifikasiUncheckedUpdateWithoutUserInput>
    create: XOR<notifikasiCreateWithoutUserInput, notifikasiUncheckedCreateWithoutUserInput>
  }

  export type notifikasiUpdateWithWhereUniqueWithoutUserInput = {
    where: notifikasiWhereUniqueInput
    data: XOR<notifikasiUpdateWithoutUserInput, notifikasiUncheckedUpdateWithoutUserInput>
  }

  export type notifikasiUpdateManyWithWhereWithoutUserInput = {
    where: notifikasiScalarWhereInput
    data: XOR<notifikasiUpdateManyMutationInput, notifikasiUncheckedUpdateManyWithoutUserInput>
  }

  export type notifikasiScalarWhereInput = {
    AND?: notifikasiScalarWhereInput | notifikasiScalarWhereInput[]
    OR?: notifikasiScalarWhereInput[]
    NOT?: notifikasiScalarWhereInput | notifikasiScalarWhereInput[]
    id?: IntFilter<"notifikasi"> | number
    user_id?: IntFilter<"notifikasi"> | number
    pesan?: StringFilter<"notifikasi"> | string
    dibaca?: BoolFilter<"notifikasi"> | boolean
    created_at?: DateTimeFilter<"notifikasi"> | Date | string
  }

  export type ulasanUpsertWithWhereUniqueWithoutUserInput = {
    where: ulasanWhereUniqueInput
    update: XOR<ulasanUpdateWithoutUserInput, ulasanUncheckedUpdateWithoutUserInput>
    create: XOR<ulasanCreateWithoutUserInput, ulasanUncheckedCreateWithoutUserInput>
  }

  export type ulasanUpdateWithWhereUniqueWithoutUserInput = {
    where: ulasanWhereUniqueInput
    data: XOR<ulasanUpdateWithoutUserInput, ulasanUncheckedUpdateWithoutUserInput>
  }

  export type ulasanUpdateManyWithWhereWithoutUserInput = {
    where: ulasanScalarWhereInput
    data: XOR<ulasanUpdateManyMutationInput, ulasanUncheckedUpdateManyWithoutUserInput>
  }

  export type ulasanScalarWhereInput = {
    AND?: ulasanScalarWhereInput | ulasanScalarWhereInput[]
    OR?: ulasanScalarWhereInput[]
    NOT?: ulasanScalarWhereInput | ulasanScalarWhereInput[]
    id?: IntFilter<"ulasan"> | number
    user_id?: IntFilter<"ulasan"> | number
    lapangan_id?: IntFilter<"ulasan"> | number
    rating?: IntFilter<"ulasan"> | number
    komentar?: StringNullableFilter<"ulasan"> | string | null
    created_at?: DateTimeFilter<"ulasan"> | Date | string
  }

  export type wallet_userUpsertWithoutUserInput = {
    update: XOR<wallet_userUpdateWithoutUserInput, wallet_userUncheckedUpdateWithoutUserInput>
    create: XOR<wallet_userCreateWithoutUserInput, wallet_userUncheckedCreateWithoutUserInput>
    where?: wallet_userWhereInput
  }

  export type wallet_userUpdateToOneWithWhereWithoutUserInput = {
    where?: wallet_userWhereInput
    data: XOR<wallet_userUpdateWithoutUserInput, wallet_userUncheckedUpdateWithoutUserInput>
  }

  export type wallet_userUpdateWithoutUserInput = {
    saldo?: IntFieldUpdateOperationsInput | number
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    history?: wallet_historyUpdateManyWithoutWalletNestedInput
  }

  export type wallet_userUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    saldo?: IntFieldUpdateOperationsInput | number
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    history?: wallet_historyUncheckedUpdateManyWithoutWalletNestedInput
  }

  export type refundUpsertWithWhereUniqueWithoutUserInput = {
    where: refundWhereUniqueInput
    update: XOR<refundUpdateWithoutUserInput, refundUncheckedUpdateWithoutUserInput>
    create: XOR<refundCreateWithoutUserInput, refundUncheckedCreateWithoutUserInput>
  }

  export type refundUpdateWithWhereUniqueWithoutUserInput = {
    where: refundWhereUniqueInput
    data: XOR<refundUpdateWithoutUserInput, refundUncheckedUpdateWithoutUserInput>
  }

  export type refundUpdateManyWithWhereWithoutUserInput = {
    where: refundScalarWhereInput
    data: XOR<refundUpdateManyMutationInput, refundUncheckedUpdateManyWithoutUserInput>
  }

  export type refundScalarWhereInput = {
    AND?: refundScalarWhereInput | refundScalarWhereInput[]
    OR?: refundScalarWhereInput[]
    NOT?: refundScalarWhereInput | refundScalarWhereInput[]
    id?: IntFilter<"refund"> | number
    user_id?: IntFilter<"refund"> | number
    transaksi_id?: IntFilter<"refund"> | number
    order_id?: IntFilter<"refund"> | number
    jumlah?: DecimalFilter<"refund"> | Decimal | DecimalJsLike | number | string
    alasan?: StringNullableFilter<"refund"> | string | null
    status?: Enumrefund_statusFilter<"refund"> | $Enums.refund_status
    created_at?: DateTimeFilter<"refund"> | Date | string
    processed_at?: DateTimeNullableFilter<"refund"> | Date | string | null
  }

  export type usersCreateWithoutMitraInput = {
    nama: string
    username: string
    email: string
    password: string
    no_hp?: string | null
    foto?: string | null
    bio?: string | null
    role?: $Enums.users_role
    status?: $Enums.users_status
    created_at?: Date | string
    updated_at?: Date | string
    orders?: order_bookingCreateNestedManyWithoutUserInput
    transaksi?: transaksiCreateNestedManyWithoutUserInput
    notifikasi?: notifikasiCreateNestedManyWithoutUserInput
    ulasan?: ulasanCreateNestedManyWithoutUserInput
    wallet?: wallet_userCreateNestedOneWithoutUserInput
    refund?: refundCreateNestedManyWithoutUserInput
  }

  export type usersUncheckedCreateWithoutMitraInput = {
    id?: number
    nama: string
    username: string
    email: string
    password: string
    no_hp?: string | null
    foto?: string | null
    bio?: string | null
    role?: $Enums.users_role
    status?: $Enums.users_status
    created_at?: Date | string
    updated_at?: Date | string
    orders?: order_bookingUncheckedCreateNestedManyWithoutUserInput
    transaksi?: transaksiUncheckedCreateNestedManyWithoutUserInput
    notifikasi?: notifikasiUncheckedCreateNestedManyWithoutUserInput
    ulasan?: ulasanUncheckedCreateNestedManyWithoutUserInput
    wallet?: wallet_userUncheckedCreateNestedOneWithoutUserInput
    refund?: refundUncheckedCreateNestedManyWithoutUserInput
  }

  export type usersCreateOrConnectWithoutMitraInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutMitraInput, usersUncheckedCreateWithoutMitraInput>
  }

  export type LapanganCreateWithoutMitraInput = {
    nama: string
    slug: string
    lokasi?: string | null
    harga: Decimal | DecimalJsLike | number | string
    gambar?: string | null
    rating?: number | null
    status?: $Enums.lapangan_status
    created_at?: Date | string
    detail?: LapanganDetailCreateNestedOneWithoutLapanganInput
    gambarList?: LapanganGambarCreateNestedManyWithoutLapanganInput
    jadwal?: JadwalLapanganCreateNestedManyWithoutLapanganInput
    orders?: order_bookingCreateNestedManyWithoutLapanganInput
    transaksi?: transaksiCreateNestedManyWithoutLapanganInput
    ulasan?: ulasanCreateNestedManyWithoutLapanganInput
  }

  export type LapanganUncheckedCreateWithoutMitraInput = {
    id?: number
    nama: string
    slug: string
    lokasi?: string | null
    harga: Decimal | DecimalJsLike | number | string
    gambar?: string | null
    rating?: number | null
    status?: $Enums.lapangan_status
    created_at?: Date | string
    detail?: LapanganDetailUncheckedCreateNestedOneWithoutLapanganInput
    gambarList?: LapanganGambarUncheckedCreateNestedManyWithoutLapanganInput
    jadwal?: JadwalLapanganUncheckedCreateNestedManyWithoutLapanganInput
    orders?: order_bookingUncheckedCreateNestedManyWithoutLapanganInput
    transaksi?: transaksiUncheckedCreateNestedManyWithoutLapanganInput
    ulasan?: ulasanUncheckedCreateNestedManyWithoutLapanganInput
  }

  export type LapanganCreateOrConnectWithoutMitraInput = {
    where: LapanganWhereUniqueInput
    create: XOR<LapanganCreateWithoutMitraInput, LapanganUncheckedCreateWithoutMitraInput>
  }

  export type LapanganCreateManyMitraInputEnvelope = {
    data: LapanganCreateManyMitraInput | LapanganCreateManyMitraInput[]
    skipDuplicates?: boolean
  }

  export type pendapatan_mitraCreateWithoutMitraInput = {
    transaksi_id: number
    jumlah: Decimal | DecimalJsLike | number | string
    created_at?: Date | string
  }

  export type pendapatan_mitraUncheckedCreateWithoutMitraInput = {
    id?: number
    transaksi_id: number
    jumlah: Decimal | DecimalJsLike | number | string
    created_at?: Date | string
  }

  export type pendapatan_mitraCreateOrConnectWithoutMitraInput = {
    where: pendapatan_mitraWhereUniqueInput
    create: XOR<pendapatan_mitraCreateWithoutMitraInput, pendapatan_mitraUncheckedCreateWithoutMitraInput>
  }

  export type pendapatan_mitraCreateManyMitraInputEnvelope = {
    data: pendapatan_mitraCreateManyMitraInput | pendapatan_mitraCreateManyMitraInput[]
    skipDuplicates?: boolean
  }

  export type pencairan_pendapatanCreateWithoutMitraInput = {
    jumlah: Decimal | DecimalJsLike | number | string
    status?: $Enums.pencairan_status
    created_at?: Date | string
  }

  export type pencairan_pendapatanUncheckedCreateWithoutMitraInput = {
    id?: number
    jumlah: Decimal | DecimalJsLike | number | string
    status?: $Enums.pencairan_status
    created_at?: Date | string
  }

  export type pencairan_pendapatanCreateOrConnectWithoutMitraInput = {
    where: pencairan_pendapatanWhereUniqueInput
    create: XOR<pencairan_pendapatanCreateWithoutMitraInput, pencairan_pendapatanUncheckedCreateWithoutMitraInput>
  }

  export type pencairan_pendapatanCreateManyMitraInputEnvelope = {
    data: pencairan_pendapatanCreateManyMitraInput | pencairan_pendapatanCreateManyMitraInput[]
    skipDuplicates?: boolean
  }

  export type usersUpsertWithoutMitraInput = {
    update: XOR<usersUpdateWithoutMitraInput, usersUncheckedUpdateWithoutMitraInput>
    create: XOR<usersCreateWithoutMitraInput, usersUncheckedCreateWithoutMitraInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutMitraInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutMitraInput, usersUncheckedUpdateWithoutMitraInput>
  }

  export type usersUpdateWithoutMitraInput = {
    nama?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    no_hp?: NullableStringFieldUpdateOperationsInput | string | null
    foto?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    role?: Enumusers_roleFieldUpdateOperationsInput | $Enums.users_role
    status?: Enumusers_statusFieldUpdateOperationsInput | $Enums.users_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: order_bookingUpdateManyWithoutUserNestedInput
    transaksi?: transaksiUpdateManyWithoutUserNestedInput
    notifikasi?: notifikasiUpdateManyWithoutUserNestedInput
    ulasan?: ulasanUpdateManyWithoutUserNestedInput
    wallet?: wallet_userUpdateOneWithoutUserNestedInput
    refund?: refundUpdateManyWithoutUserNestedInput
  }

  export type usersUncheckedUpdateWithoutMitraInput = {
    id?: IntFieldUpdateOperationsInput | number
    nama?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    no_hp?: NullableStringFieldUpdateOperationsInput | string | null
    foto?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    role?: Enumusers_roleFieldUpdateOperationsInput | $Enums.users_role
    status?: Enumusers_statusFieldUpdateOperationsInput | $Enums.users_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: order_bookingUncheckedUpdateManyWithoutUserNestedInput
    transaksi?: transaksiUncheckedUpdateManyWithoutUserNestedInput
    notifikasi?: notifikasiUncheckedUpdateManyWithoutUserNestedInput
    ulasan?: ulasanUncheckedUpdateManyWithoutUserNestedInput
    wallet?: wallet_userUncheckedUpdateOneWithoutUserNestedInput
    refund?: refundUncheckedUpdateManyWithoutUserNestedInput
  }

  export type LapanganUpsertWithWhereUniqueWithoutMitraInput = {
    where: LapanganWhereUniqueInput
    update: XOR<LapanganUpdateWithoutMitraInput, LapanganUncheckedUpdateWithoutMitraInput>
    create: XOR<LapanganCreateWithoutMitraInput, LapanganUncheckedCreateWithoutMitraInput>
  }

  export type LapanganUpdateWithWhereUniqueWithoutMitraInput = {
    where: LapanganWhereUniqueInput
    data: XOR<LapanganUpdateWithoutMitraInput, LapanganUncheckedUpdateWithoutMitraInput>
  }

  export type LapanganUpdateManyWithWhereWithoutMitraInput = {
    where: LapanganScalarWhereInput
    data: XOR<LapanganUpdateManyMutationInput, LapanganUncheckedUpdateManyWithoutMitraInput>
  }

  export type LapanganScalarWhereInput = {
    AND?: LapanganScalarWhereInput | LapanganScalarWhereInput[]
    OR?: LapanganScalarWhereInput[]
    NOT?: LapanganScalarWhereInput | LapanganScalarWhereInput[]
    id?: IntFilter<"Lapangan"> | number
    mitra_id?: IntFilter<"Lapangan"> | number
    nama?: StringFilter<"Lapangan"> | string
    slug?: StringFilter<"Lapangan"> | string
    lokasi?: StringNullableFilter<"Lapangan"> | string | null
    harga?: DecimalFilter<"Lapangan"> | Decimal | DecimalJsLike | number | string
    gambar?: StringNullableFilter<"Lapangan"> | string | null
    rating?: FloatNullableFilter<"Lapangan"> | number | null
    status?: Enumlapangan_statusFilter<"Lapangan"> | $Enums.lapangan_status
    created_at?: DateTimeFilter<"Lapangan"> | Date | string
  }

  export type pendapatan_mitraUpsertWithWhereUniqueWithoutMitraInput = {
    where: pendapatan_mitraWhereUniqueInput
    update: XOR<pendapatan_mitraUpdateWithoutMitraInput, pendapatan_mitraUncheckedUpdateWithoutMitraInput>
    create: XOR<pendapatan_mitraCreateWithoutMitraInput, pendapatan_mitraUncheckedCreateWithoutMitraInput>
  }

  export type pendapatan_mitraUpdateWithWhereUniqueWithoutMitraInput = {
    where: pendapatan_mitraWhereUniqueInput
    data: XOR<pendapatan_mitraUpdateWithoutMitraInput, pendapatan_mitraUncheckedUpdateWithoutMitraInput>
  }

  export type pendapatan_mitraUpdateManyWithWhereWithoutMitraInput = {
    where: pendapatan_mitraScalarWhereInput
    data: XOR<pendapatan_mitraUpdateManyMutationInput, pendapatan_mitraUncheckedUpdateManyWithoutMitraInput>
  }

  export type pendapatan_mitraScalarWhereInput = {
    AND?: pendapatan_mitraScalarWhereInput | pendapatan_mitraScalarWhereInput[]
    OR?: pendapatan_mitraScalarWhereInput[]
    NOT?: pendapatan_mitraScalarWhereInput | pendapatan_mitraScalarWhereInput[]
    id?: IntFilter<"pendapatan_mitra"> | number
    mitra_id?: IntFilter<"pendapatan_mitra"> | number
    transaksi_id?: IntFilter<"pendapatan_mitra"> | number
    jumlah?: DecimalFilter<"pendapatan_mitra"> | Decimal | DecimalJsLike | number | string
    created_at?: DateTimeFilter<"pendapatan_mitra"> | Date | string
  }

  export type pencairan_pendapatanUpsertWithWhereUniqueWithoutMitraInput = {
    where: pencairan_pendapatanWhereUniqueInput
    update: XOR<pencairan_pendapatanUpdateWithoutMitraInput, pencairan_pendapatanUncheckedUpdateWithoutMitraInput>
    create: XOR<pencairan_pendapatanCreateWithoutMitraInput, pencairan_pendapatanUncheckedCreateWithoutMitraInput>
  }

  export type pencairan_pendapatanUpdateWithWhereUniqueWithoutMitraInput = {
    where: pencairan_pendapatanWhereUniqueInput
    data: XOR<pencairan_pendapatanUpdateWithoutMitraInput, pencairan_pendapatanUncheckedUpdateWithoutMitraInput>
  }

  export type pencairan_pendapatanUpdateManyWithWhereWithoutMitraInput = {
    where: pencairan_pendapatanScalarWhereInput
    data: XOR<pencairan_pendapatanUpdateManyMutationInput, pencairan_pendapatanUncheckedUpdateManyWithoutMitraInput>
  }

  export type pencairan_pendapatanScalarWhereInput = {
    AND?: pencairan_pendapatanScalarWhereInput | pencairan_pendapatanScalarWhereInput[]
    OR?: pencairan_pendapatanScalarWhereInput[]
    NOT?: pencairan_pendapatanScalarWhereInput | pencairan_pendapatanScalarWhereInput[]
    id?: IntFilter<"pencairan_pendapatan"> | number
    mitra_id?: IntFilter<"pencairan_pendapatan"> | number
    jumlah?: DecimalFilter<"pencairan_pendapatan"> | Decimal | DecimalJsLike | number | string
    status?: Enumpencairan_statusFilter<"pencairan_pendapatan"> | $Enums.pencairan_status
    created_at?: DateTimeFilter<"pencairan_pendapatan"> | Date | string
  }

  export type MitraCreateWithoutLapanganInput = {
    nama_usaha: string
    alamat_usaha: string
    no_ktp: string
    foto_ktp: string
    withdraw_type?: string | null
    withdraw_day?: number | null
    bank_mitra?: string | null
    no_rekening_mitra?: string | null
    status?: $Enums.mitra_status
    created_at?: Date | string
    user: usersCreateNestedOneWithoutMitraInput
    pendapatan?: pendapatan_mitraCreateNestedManyWithoutMitraInput
    pencairan?: pencairan_pendapatanCreateNestedManyWithoutMitraInput
  }

  export type MitraUncheckedCreateWithoutLapanganInput = {
    id?: number
    userId: number
    nama_usaha: string
    alamat_usaha: string
    no_ktp: string
    foto_ktp: string
    withdraw_type?: string | null
    withdraw_day?: number | null
    bank_mitra?: string | null
    no_rekening_mitra?: string | null
    status?: $Enums.mitra_status
    created_at?: Date | string
    pendapatan?: pendapatan_mitraUncheckedCreateNestedManyWithoutMitraInput
    pencairan?: pencairan_pendapatanUncheckedCreateNestedManyWithoutMitraInput
  }

  export type MitraCreateOrConnectWithoutLapanganInput = {
    where: MitraWhereUniqueInput
    create: XOR<MitraCreateWithoutLapanganInput, MitraUncheckedCreateWithoutLapanganInput>
  }

  export type LapanganDetailCreateWithoutLapanganInput = {
    alamat: string
    maps: string
    deskripsi: string
    type: string
    fasilitas: JsonNullValueInput | InputJsonValue
    interval?: number
    breakTime?: number
  }

  export type LapanganDetailUncheckedCreateWithoutLapanganInput = {
    id?: number
    alamat: string
    maps: string
    deskripsi: string
    type: string
    fasilitas: JsonNullValueInput | InputJsonValue
    interval?: number
    breakTime?: number
  }

  export type LapanganDetailCreateOrConnectWithoutLapanganInput = {
    where: LapanganDetailWhereUniqueInput
    create: XOR<LapanganDetailCreateWithoutLapanganInput, LapanganDetailUncheckedCreateWithoutLapanganInput>
  }

  export type LapanganGambarCreateWithoutLapanganInput = {
    file_name: string
    created_at?: Date | string
  }

  export type LapanganGambarUncheckedCreateWithoutLapanganInput = {
    id?: number
    file_name: string
    created_at?: Date | string
  }

  export type LapanganGambarCreateOrConnectWithoutLapanganInput = {
    where: LapanganGambarWhereUniqueInput
    create: XOR<LapanganGambarCreateWithoutLapanganInput, LapanganGambarUncheckedCreateWithoutLapanganInput>
  }

  export type LapanganGambarCreateManyLapanganInputEnvelope = {
    data: LapanganGambarCreateManyLapanganInput | LapanganGambarCreateManyLapanganInput[]
    skipDuplicates?: boolean
  }

  export type JadwalLapanganCreateWithoutLapanganInput = {
    tanggal: Date | string
    slot: string
    status?: $Enums.jadwal_status
    locked_until?: Date | string | null
    orders?: order_bookingCreateNestedManyWithoutJadwalLapanganInput
    transaksi?: transaksiCreateNestedManyWithoutJadwalInput
  }

  export type JadwalLapanganUncheckedCreateWithoutLapanganInput = {
    id?: number
    tanggal: Date | string
    slot: string
    status?: $Enums.jadwal_status
    locked_until?: Date | string | null
    orders?: order_bookingUncheckedCreateNestedManyWithoutJadwalLapanganInput
    transaksi?: transaksiUncheckedCreateNestedManyWithoutJadwalInput
  }

  export type JadwalLapanganCreateOrConnectWithoutLapanganInput = {
    where: JadwalLapanganWhereUniqueInput
    create: XOR<JadwalLapanganCreateWithoutLapanganInput, JadwalLapanganUncheckedCreateWithoutLapanganInput>
  }

  export type JadwalLapanganCreateManyLapanganInputEnvelope = {
    data: JadwalLapanganCreateManyLapanganInput | JadwalLapanganCreateManyLapanganInput[]
    skipDuplicates?: boolean
  }

  export type order_bookingCreateWithoutLapanganInput = {
    tanggal: Date | string
    jam_mulai: string
    jam_selesai: string
    total_harga: Decimal | DecimalJsLike | number | string
    status: string
    sewa_raket?: boolean
    biaya_raket?: number
    created_at?: Date | string
    expired_at?: Date | string | null
    user: usersCreateNestedOneWithoutOrdersInput
    jadwalLapangan: JadwalLapanganCreateNestedOneWithoutOrdersInput
    transaksi?: transaksiCreateNestedOneWithoutOrderInput
    refund?: refundCreateNestedOneWithoutOrderInput
    wallet_histories?: wallet_historyCreateNestedManyWithoutOrderInput
  }

  export type order_bookingUncheckedCreateWithoutLapanganInput = {
    id?: number
    user_id: number
    jadwalLapanganId: number
    tanggal: Date | string
    jam_mulai: string
    jam_selesai: string
    total_harga: Decimal | DecimalJsLike | number | string
    status: string
    sewa_raket?: boolean
    biaya_raket?: number
    created_at?: Date | string
    expired_at?: Date | string | null
    transaksi?: transaksiUncheckedCreateNestedOneWithoutOrderInput
    refund?: refundUncheckedCreateNestedOneWithoutOrderInput
    wallet_histories?: wallet_historyUncheckedCreateNestedManyWithoutOrderInput
  }

  export type order_bookingCreateOrConnectWithoutLapanganInput = {
    where: order_bookingWhereUniqueInput
    create: XOR<order_bookingCreateWithoutLapanganInput, order_bookingUncheckedCreateWithoutLapanganInput>
  }

  export type order_bookingCreateManyLapanganInputEnvelope = {
    data: order_bookingCreateManyLapanganInput | order_bookingCreateManyLapanganInput[]
    skipDuplicates?: boolean
  }

  export type transaksiCreateWithoutLapanganInput = {
    total_harga: Decimal | DecimalJsLike | number | string
    status_pembayaran?: $Enums.transaksi_status_pembayaran
    created_at?: Date | string
    user: usersCreateNestedOneWithoutTransaksiInput
    jadwal: JadwalLapanganCreateNestedOneWithoutTransaksiInput
    order?: order_bookingCreateNestedOneWithoutTransaksiInput
    refund?: refundCreateNestedOneWithoutTransaksiInput
    sewa_raket?: sewa_raketCreateNestedManyWithoutTransaksiInput
  }

  export type transaksiUncheckedCreateWithoutLapanganInput = {
    id?: number
    user_id: number
    jadwal_id: number
    order_id?: number | null
    total_harga: Decimal | DecimalJsLike | number | string
    status_pembayaran?: $Enums.transaksi_status_pembayaran
    created_at?: Date | string
    refund?: refundUncheckedCreateNestedOneWithoutTransaksiInput
    sewa_raket?: sewa_raketUncheckedCreateNestedManyWithoutTransaksiInput
  }

  export type transaksiCreateOrConnectWithoutLapanganInput = {
    where: transaksiWhereUniqueInput
    create: XOR<transaksiCreateWithoutLapanganInput, transaksiUncheckedCreateWithoutLapanganInput>
  }

  export type transaksiCreateManyLapanganInputEnvelope = {
    data: transaksiCreateManyLapanganInput | transaksiCreateManyLapanganInput[]
    skipDuplicates?: boolean
  }

  export type ulasanCreateWithoutLapanganInput = {
    rating: number
    komentar?: string | null
    created_at?: Date | string
    user: usersCreateNestedOneWithoutUlasanInput
  }

  export type ulasanUncheckedCreateWithoutLapanganInput = {
    id?: number
    user_id: number
    rating: number
    komentar?: string | null
    created_at?: Date | string
  }

  export type ulasanCreateOrConnectWithoutLapanganInput = {
    where: ulasanWhereUniqueInput
    create: XOR<ulasanCreateWithoutLapanganInput, ulasanUncheckedCreateWithoutLapanganInput>
  }

  export type ulasanCreateManyLapanganInputEnvelope = {
    data: ulasanCreateManyLapanganInput | ulasanCreateManyLapanganInput[]
    skipDuplicates?: boolean
  }

  export type MitraUpsertWithoutLapanganInput = {
    update: XOR<MitraUpdateWithoutLapanganInput, MitraUncheckedUpdateWithoutLapanganInput>
    create: XOR<MitraCreateWithoutLapanganInput, MitraUncheckedCreateWithoutLapanganInput>
    where?: MitraWhereInput
  }

  export type MitraUpdateToOneWithWhereWithoutLapanganInput = {
    where?: MitraWhereInput
    data: XOR<MitraUpdateWithoutLapanganInput, MitraUncheckedUpdateWithoutLapanganInput>
  }

  export type MitraUpdateWithoutLapanganInput = {
    nama_usaha?: StringFieldUpdateOperationsInput | string
    alamat_usaha?: StringFieldUpdateOperationsInput | string
    no_ktp?: StringFieldUpdateOperationsInput | string
    foto_ktp?: StringFieldUpdateOperationsInput | string
    withdraw_type?: NullableStringFieldUpdateOperationsInput | string | null
    withdraw_day?: NullableIntFieldUpdateOperationsInput | number | null
    bank_mitra?: NullableStringFieldUpdateOperationsInput | string | null
    no_rekening_mitra?: NullableStringFieldUpdateOperationsInput | string | null
    status?: Enummitra_statusFieldUpdateOperationsInput | $Enums.mitra_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: usersUpdateOneRequiredWithoutMitraNestedInput
    pendapatan?: pendapatan_mitraUpdateManyWithoutMitraNestedInput
    pencairan?: pencairan_pendapatanUpdateManyWithoutMitraNestedInput
  }

  export type MitraUncheckedUpdateWithoutLapanganInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    nama_usaha?: StringFieldUpdateOperationsInput | string
    alamat_usaha?: StringFieldUpdateOperationsInput | string
    no_ktp?: StringFieldUpdateOperationsInput | string
    foto_ktp?: StringFieldUpdateOperationsInput | string
    withdraw_type?: NullableStringFieldUpdateOperationsInput | string | null
    withdraw_day?: NullableIntFieldUpdateOperationsInput | number | null
    bank_mitra?: NullableStringFieldUpdateOperationsInput | string | null
    no_rekening_mitra?: NullableStringFieldUpdateOperationsInput | string | null
    status?: Enummitra_statusFieldUpdateOperationsInput | $Enums.mitra_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    pendapatan?: pendapatan_mitraUncheckedUpdateManyWithoutMitraNestedInput
    pencairan?: pencairan_pendapatanUncheckedUpdateManyWithoutMitraNestedInput
  }

  export type LapanganDetailUpsertWithoutLapanganInput = {
    update: XOR<LapanganDetailUpdateWithoutLapanganInput, LapanganDetailUncheckedUpdateWithoutLapanganInput>
    create: XOR<LapanganDetailCreateWithoutLapanganInput, LapanganDetailUncheckedCreateWithoutLapanganInput>
    where?: LapanganDetailWhereInput
  }

  export type LapanganDetailUpdateToOneWithWhereWithoutLapanganInput = {
    where?: LapanganDetailWhereInput
    data: XOR<LapanganDetailUpdateWithoutLapanganInput, LapanganDetailUncheckedUpdateWithoutLapanganInput>
  }

  export type LapanganDetailUpdateWithoutLapanganInput = {
    alamat?: StringFieldUpdateOperationsInput | string
    maps?: StringFieldUpdateOperationsInput | string
    deskripsi?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    fasilitas?: JsonNullValueInput | InputJsonValue
    interval?: IntFieldUpdateOperationsInput | number
    breakTime?: IntFieldUpdateOperationsInput | number
  }

  export type LapanganDetailUncheckedUpdateWithoutLapanganInput = {
    id?: IntFieldUpdateOperationsInput | number
    alamat?: StringFieldUpdateOperationsInput | string
    maps?: StringFieldUpdateOperationsInput | string
    deskripsi?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    fasilitas?: JsonNullValueInput | InputJsonValue
    interval?: IntFieldUpdateOperationsInput | number
    breakTime?: IntFieldUpdateOperationsInput | number
  }

  export type LapanganGambarUpsertWithWhereUniqueWithoutLapanganInput = {
    where: LapanganGambarWhereUniqueInput
    update: XOR<LapanganGambarUpdateWithoutLapanganInput, LapanganGambarUncheckedUpdateWithoutLapanganInput>
    create: XOR<LapanganGambarCreateWithoutLapanganInput, LapanganGambarUncheckedCreateWithoutLapanganInput>
  }

  export type LapanganGambarUpdateWithWhereUniqueWithoutLapanganInput = {
    where: LapanganGambarWhereUniqueInput
    data: XOR<LapanganGambarUpdateWithoutLapanganInput, LapanganGambarUncheckedUpdateWithoutLapanganInput>
  }

  export type LapanganGambarUpdateManyWithWhereWithoutLapanganInput = {
    where: LapanganGambarScalarWhereInput
    data: XOR<LapanganGambarUpdateManyMutationInput, LapanganGambarUncheckedUpdateManyWithoutLapanganInput>
  }

  export type LapanganGambarScalarWhereInput = {
    AND?: LapanganGambarScalarWhereInput | LapanganGambarScalarWhereInput[]
    OR?: LapanganGambarScalarWhereInput[]
    NOT?: LapanganGambarScalarWhereInput | LapanganGambarScalarWhereInput[]
    id?: IntFilter<"LapanganGambar"> | number
    lapangan_id?: IntFilter<"LapanganGambar"> | number
    file_name?: StringFilter<"LapanganGambar"> | string
    created_at?: DateTimeFilter<"LapanganGambar"> | Date | string
  }

  export type JadwalLapanganUpsertWithWhereUniqueWithoutLapanganInput = {
    where: JadwalLapanganWhereUniqueInput
    update: XOR<JadwalLapanganUpdateWithoutLapanganInput, JadwalLapanganUncheckedUpdateWithoutLapanganInput>
    create: XOR<JadwalLapanganCreateWithoutLapanganInput, JadwalLapanganUncheckedCreateWithoutLapanganInput>
  }

  export type JadwalLapanganUpdateWithWhereUniqueWithoutLapanganInput = {
    where: JadwalLapanganWhereUniqueInput
    data: XOR<JadwalLapanganUpdateWithoutLapanganInput, JadwalLapanganUncheckedUpdateWithoutLapanganInput>
  }

  export type JadwalLapanganUpdateManyWithWhereWithoutLapanganInput = {
    where: JadwalLapanganScalarWhereInput
    data: XOR<JadwalLapanganUpdateManyMutationInput, JadwalLapanganUncheckedUpdateManyWithoutLapanganInput>
  }

  export type JadwalLapanganScalarWhereInput = {
    AND?: JadwalLapanganScalarWhereInput | JadwalLapanganScalarWhereInput[]
    OR?: JadwalLapanganScalarWhereInput[]
    NOT?: JadwalLapanganScalarWhereInput | JadwalLapanganScalarWhereInput[]
    id?: IntFilter<"JadwalLapangan"> | number
    lapangan_id?: IntFilter<"JadwalLapangan"> | number
    tanggal?: DateTimeFilter<"JadwalLapangan"> | Date | string
    slot?: StringFilter<"JadwalLapangan"> | string
    status?: Enumjadwal_statusFilter<"JadwalLapangan"> | $Enums.jadwal_status
    locked_until?: DateTimeNullableFilter<"JadwalLapangan"> | Date | string | null
  }

  export type order_bookingUpsertWithWhereUniqueWithoutLapanganInput = {
    where: order_bookingWhereUniqueInput
    update: XOR<order_bookingUpdateWithoutLapanganInput, order_bookingUncheckedUpdateWithoutLapanganInput>
    create: XOR<order_bookingCreateWithoutLapanganInput, order_bookingUncheckedCreateWithoutLapanganInput>
  }

  export type order_bookingUpdateWithWhereUniqueWithoutLapanganInput = {
    where: order_bookingWhereUniqueInput
    data: XOR<order_bookingUpdateWithoutLapanganInput, order_bookingUncheckedUpdateWithoutLapanganInput>
  }

  export type order_bookingUpdateManyWithWhereWithoutLapanganInput = {
    where: order_bookingScalarWhereInput
    data: XOR<order_bookingUpdateManyMutationInput, order_bookingUncheckedUpdateManyWithoutLapanganInput>
  }

  export type transaksiUpsertWithWhereUniqueWithoutLapanganInput = {
    where: transaksiWhereUniqueInput
    update: XOR<transaksiUpdateWithoutLapanganInput, transaksiUncheckedUpdateWithoutLapanganInput>
    create: XOR<transaksiCreateWithoutLapanganInput, transaksiUncheckedCreateWithoutLapanganInput>
  }

  export type transaksiUpdateWithWhereUniqueWithoutLapanganInput = {
    where: transaksiWhereUniqueInput
    data: XOR<transaksiUpdateWithoutLapanganInput, transaksiUncheckedUpdateWithoutLapanganInput>
  }

  export type transaksiUpdateManyWithWhereWithoutLapanganInput = {
    where: transaksiScalarWhereInput
    data: XOR<transaksiUpdateManyMutationInput, transaksiUncheckedUpdateManyWithoutLapanganInput>
  }

  export type ulasanUpsertWithWhereUniqueWithoutLapanganInput = {
    where: ulasanWhereUniqueInput
    update: XOR<ulasanUpdateWithoutLapanganInput, ulasanUncheckedUpdateWithoutLapanganInput>
    create: XOR<ulasanCreateWithoutLapanganInput, ulasanUncheckedCreateWithoutLapanganInput>
  }

  export type ulasanUpdateWithWhereUniqueWithoutLapanganInput = {
    where: ulasanWhereUniqueInput
    data: XOR<ulasanUpdateWithoutLapanganInput, ulasanUncheckedUpdateWithoutLapanganInput>
  }

  export type ulasanUpdateManyWithWhereWithoutLapanganInput = {
    where: ulasanScalarWhereInput
    data: XOR<ulasanUpdateManyMutationInput, ulasanUncheckedUpdateManyWithoutLapanganInput>
  }

  export type LapanganCreateWithoutDetailInput = {
    nama: string
    slug: string
    lokasi?: string | null
    harga: Decimal | DecimalJsLike | number | string
    gambar?: string | null
    rating?: number | null
    status?: $Enums.lapangan_status
    created_at?: Date | string
    mitra: MitraCreateNestedOneWithoutLapanganInput
    gambarList?: LapanganGambarCreateNestedManyWithoutLapanganInput
    jadwal?: JadwalLapanganCreateNestedManyWithoutLapanganInput
    orders?: order_bookingCreateNestedManyWithoutLapanganInput
    transaksi?: transaksiCreateNestedManyWithoutLapanganInput
    ulasan?: ulasanCreateNestedManyWithoutLapanganInput
  }

  export type LapanganUncheckedCreateWithoutDetailInput = {
    id?: number
    mitra_id: number
    nama: string
    slug: string
    lokasi?: string | null
    harga: Decimal | DecimalJsLike | number | string
    gambar?: string | null
    rating?: number | null
    status?: $Enums.lapangan_status
    created_at?: Date | string
    gambarList?: LapanganGambarUncheckedCreateNestedManyWithoutLapanganInput
    jadwal?: JadwalLapanganUncheckedCreateNestedManyWithoutLapanganInput
    orders?: order_bookingUncheckedCreateNestedManyWithoutLapanganInput
    transaksi?: transaksiUncheckedCreateNestedManyWithoutLapanganInput
    ulasan?: ulasanUncheckedCreateNestedManyWithoutLapanganInput
  }

  export type LapanganCreateOrConnectWithoutDetailInput = {
    where: LapanganWhereUniqueInput
    create: XOR<LapanganCreateWithoutDetailInput, LapanganUncheckedCreateWithoutDetailInput>
  }

  export type LapanganUpsertWithoutDetailInput = {
    update: XOR<LapanganUpdateWithoutDetailInput, LapanganUncheckedUpdateWithoutDetailInput>
    create: XOR<LapanganCreateWithoutDetailInput, LapanganUncheckedCreateWithoutDetailInput>
    where?: LapanganWhereInput
  }

  export type LapanganUpdateToOneWithWhereWithoutDetailInput = {
    where?: LapanganWhereInput
    data: XOR<LapanganUpdateWithoutDetailInput, LapanganUncheckedUpdateWithoutDetailInput>
  }

  export type LapanganUpdateWithoutDetailInput = {
    nama?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    lokasi?: NullableStringFieldUpdateOperationsInput | string | null
    harga?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    gambar?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: Enumlapangan_statusFieldUpdateOperationsInput | $Enums.lapangan_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    mitra?: MitraUpdateOneRequiredWithoutLapanganNestedInput
    gambarList?: LapanganGambarUpdateManyWithoutLapanganNestedInput
    jadwal?: JadwalLapanganUpdateManyWithoutLapanganNestedInput
    orders?: order_bookingUpdateManyWithoutLapanganNestedInput
    transaksi?: transaksiUpdateManyWithoutLapanganNestedInput
    ulasan?: ulasanUpdateManyWithoutLapanganNestedInput
  }

  export type LapanganUncheckedUpdateWithoutDetailInput = {
    id?: IntFieldUpdateOperationsInput | number
    mitra_id?: IntFieldUpdateOperationsInput | number
    nama?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    lokasi?: NullableStringFieldUpdateOperationsInput | string | null
    harga?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    gambar?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: Enumlapangan_statusFieldUpdateOperationsInput | $Enums.lapangan_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    gambarList?: LapanganGambarUncheckedUpdateManyWithoutLapanganNestedInput
    jadwal?: JadwalLapanganUncheckedUpdateManyWithoutLapanganNestedInput
    orders?: order_bookingUncheckedUpdateManyWithoutLapanganNestedInput
    transaksi?: transaksiUncheckedUpdateManyWithoutLapanganNestedInput
    ulasan?: ulasanUncheckedUpdateManyWithoutLapanganNestedInput
  }

  export type LapanganCreateWithoutGambarListInput = {
    nama: string
    slug: string
    lokasi?: string | null
    harga: Decimal | DecimalJsLike | number | string
    gambar?: string | null
    rating?: number | null
    status?: $Enums.lapangan_status
    created_at?: Date | string
    mitra: MitraCreateNestedOneWithoutLapanganInput
    detail?: LapanganDetailCreateNestedOneWithoutLapanganInput
    jadwal?: JadwalLapanganCreateNestedManyWithoutLapanganInput
    orders?: order_bookingCreateNestedManyWithoutLapanganInput
    transaksi?: transaksiCreateNestedManyWithoutLapanganInput
    ulasan?: ulasanCreateNestedManyWithoutLapanganInput
  }

  export type LapanganUncheckedCreateWithoutGambarListInput = {
    id?: number
    mitra_id: number
    nama: string
    slug: string
    lokasi?: string | null
    harga: Decimal | DecimalJsLike | number | string
    gambar?: string | null
    rating?: number | null
    status?: $Enums.lapangan_status
    created_at?: Date | string
    detail?: LapanganDetailUncheckedCreateNestedOneWithoutLapanganInput
    jadwal?: JadwalLapanganUncheckedCreateNestedManyWithoutLapanganInput
    orders?: order_bookingUncheckedCreateNestedManyWithoutLapanganInput
    transaksi?: transaksiUncheckedCreateNestedManyWithoutLapanganInput
    ulasan?: ulasanUncheckedCreateNestedManyWithoutLapanganInput
  }

  export type LapanganCreateOrConnectWithoutGambarListInput = {
    where: LapanganWhereUniqueInput
    create: XOR<LapanganCreateWithoutGambarListInput, LapanganUncheckedCreateWithoutGambarListInput>
  }

  export type LapanganUpsertWithoutGambarListInput = {
    update: XOR<LapanganUpdateWithoutGambarListInput, LapanganUncheckedUpdateWithoutGambarListInput>
    create: XOR<LapanganCreateWithoutGambarListInput, LapanganUncheckedCreateWithoutGambarListInput>
    where?: LapanganWhereInput
  }

  export type LapanganUpdateToOneWithWhereWithoutGambarListInput = {
    where?: LapanganWhereInput
    data: XOR<LapanganUpdateWithoutGambarListInput, LapanganUncheckedUpdateWithoutGambarListInput>
  }

  export type LapanganUpdateWithoutGambarListInput = {
    nama?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    lokasi?: NullableStringFieldUpdateOperationsInput | string | null
    harga?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    gambar?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: Enumlapangan_statusFieldUpdateOperationsInput | $Enums.lapangan_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    mitra?: MitraUpdateOneRequiredWithoutLapanganNestedInput
    detail?: LapanganDetailUpdateOneWithoutLapanganNestedInput
    jadwal?: JadwalLapanganUpdateManyWithoutLapanganNestedInput
    orders?: order_bookingUpdateManyWithoutLapanganNestedInput
    transaksi?: transaksiUpdateManyWithoutLapanganNestedInput
    ulasan?: ulasanUpdateManyWithoutLapanganNestedInput
  }

  export type LapanganUncheckedUpdateWithoutGambarListInput = {
    id?: IntFieldUpdateOperationsInput | number
    mitra_id?: IntFieldUpdateOperationsInput | number
    nama?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    lokasi?: NullableStringFieldUpdateOperationsInput | string | null
    harga?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    gambar?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: Enumlapangan_statusFieldUpdateOperationsInput | $Enums.lapangan_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    detail?: LapanganDetailUncheckedUpdateOneWithoutLapanganNestedInput
    jadwal?: JadwalLapanganUncheckedUpdateManyWithoutLapanganNestedInput
    orders?: order_bookingUncheckedUpdateManyWithoutLapanganNestedInput
    transaksi?: transaksiUncheckedUpdateManyWithoutLapanganNestedInput
    ulasan?: ulasanUncheckedUpdateManyWithoutLapanganNestedInput
  }

  export type LapanganCreateWithoutJadwalInput = {
    nama: string
    slug: string
    lokasi?: string | null
    harga: Decimal | DecimalJsLike | number | string
    gambar?: string | null
    rating?: number | null
    status?: $Enums.lapangan_status
    created_at?: Date | string
    mitra: MitraCreateNestedOneWithoutLapanganInput
    detail?: LapanganDetailCreateNestedOneWithoutLapanganInput
    gambarList?: LapanganGambarCreateNestedManyWithoutLapanganInput
    orders?: order_bookingCreateNestedManyWithoutLapanganInput
    transaksi?: transaksiCreateNestedManyWithoutLapanganInput
    ulasan?: ulasanCreateNestedManyWithoutLapanganInput
  }

  export type LapanganUncheckedCreateWithoutJadwalInput = {
    id?: number
    mitra_id: number
    nama: string
    slug: string
    lokasi?: string | null
    harga: Decimal | DecimalJsLike | number | string
    gambar?: string | null
    rating?: number | null
    status?: $Enums.lapangan_status
    created_at?: Date | string
    detail?: LapanganDetailUncheckedCreateNestedOneWithoutLapanganInput
    gambarList?: LapanganGambarUncheckedCreateNestedManyWithoutLapanganInput
    orders?: order_bookingUncheckedCreateNestedManyWithoutLapanganInput
    transaksi?: transaksiUncheckedCreateNestedManyWithoutLapanganInput
    ulasan?: ulasanUncheckedCreateNestedManyWithoutLapanganInput
  }

  export type LapanganCreateOrConnectWithoutJadwalInput = {
    where: LapanganWhereUniqueInput
    create: XOR<LapanganCreateWithoutJadwalInput, LapanganUncheckedCreateWithoutJadwalInput>
  }

  export type order_bookingCreateWithoutJadwalLapanganInput = {
    tanggal: Date | string
    jam_mulai: string
    jam_selesai: string
    total_harga: Decimal | DecimalJsLike | number | string
    status: string
    sewa_raket?: boolean
    biaya_raket?: number
    created_at?: Date | string
    expired_at?: Date | string | null
    user: usersCreateNestedOneWithoutOrdersInput
    lapangan: LapanganCreateNestedOneWithoutOrdersInput
    transaksi?: transaksiCreateNestedOneWithoutOrderInput
    refund?: refundCreateNestedOneWithoutOrderInput
    wallet_histories?: wallet_historyCreateNestedManyWithoutOrderInput
  }

  export type order_bookingUncheckedCreateWithoutJadwalLapanganInput = {
    id?: number
    user_id: number
    lapangan_id: number
    tanggal: Date | string
    jam_mulai: string
    jam_selesai: string
    total_harga: Decimal | DecimalJsLike | number | string
    status: string
    sewa_raket?: boolean
    biaya_raket?: number
    created_at?: Date | string
    expired_at?: Date | string | null
    transaksi?: transaksiUncheckedCreateNestedOneWithoutOrderInput
    refund?: refundUncheckedCreateNestedOneWithoutOrderInput
    wallet_histories?: wallet_historyUncheckedCreateNestedManyWithoutOrderInput
  }

  export type order_bookingCreateOrConnectWithoutJadwalLapanganInput = {
    where: order_bookingWhereUniqueInput
    create: XOR<order_bookingCreateWithoutJadwalLapanganInput, order_bookingUncheckedCreateWithoutJadwalLapanganInput>
  }

  export type order_bookingCreateManyJadwalLapanganInputEnvelope = {
    data: order_bookingCreateManyJadwalLapanganInput | order_bookingCreateManyJadwalLapanganInput[]
    skipDuplicates?: boolean
  }

  export type transaksiCreateWithoutJadwalInput = {
    total_harga: Decimal | DecimalJsLike | number | string
    status_pembayaran?: $Enums.transaksi_status_pembayaran
    created_at?: Date | string
    user: usersCreateNestedOneWithoutTransaksiInput
    lapangan: LapanganCreateNestedOneWithoutTransaksiInput
    order?: order_bookingCreateNestedOneWithoutTransaksiInput
    refund?: refundCreateNestedOneWithoutTransaksiInput
    sewa_raket?: sewa_raketCreateNestedManyWithoutTransaksiInput
  }

  export type transaksiUncheckedCreateWithoutJadwalInput = {
    id?: number
    user_id: number
    lapangan_id: number
    order_id?: number | null
    total_harga: Decimal | DecimalJsLike | number | string
    status_pembayaran?: $Enums.transaksi_status_pembayaran
    created_at?: Date | string
    refund?: refundUncheckedCreateNestedOneWithoutTransaksiInput
    sewa_raket?: sewa_raketUncheckedCreateNestedManyWithoutTransaksiInput
  }

  export type transaksiCreateOrConnectWithoutJadwalInput = {
    where: transaksiWhereUniqueInput
    create: XOR<transaksiCreateWithoutJadwalInput, transaksiUncheckedCreateWithoutJadwalInput>
  }

  export type transaksiCreateManyJadwalInputEnvelope = {
    data: transaksiCreateManyJadwalInput | transaksiCreateManyJadwalInput[]
    skipDuplicates?: boolean
  }

  export type LapanganUpsertWithoutJadwalInput = {
    update: XOR<LapanganUpdateWithoutJadwalInput, LapanganUncheckedUpdateWithoutJadwalInput>
    create: XOR<LapanganCreateWithoutJadwalInput, LapanganUncheckedCreateWithoutJadwalInput>
    where?: LapanganWhereInput
  }

  export type LapanganUpdateToOneWithWhereWithoutJadwalInput = {
    where?: LapanganWhereInput
    data: XOR<LapanganUpdateWithoutJadwalInput, LapanganUncheckedUpdateWithoutJadwalInput>
  }

  export type LapanganUpdateWithoutJadwalInput = {
    nama?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    lokasi?: NullableStringFieldUpdateOperationsInput | string | null
    harga?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    gambar?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: Enumlapangan_statusFieldUpdateOperationsInput | $Enums.lapangan_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    mitra?: MitraUpdateOneRequiredWithoutLapanganNestedInput
    detail?: LapanganDetailUpdateOneWithoutLapanganNestedInput
    gambarList?: LapanganGambarUpdateManyWithoutLapanganNestedInput
    orders?: order_bookingUpdateManyWithoutLapanganNestedInput
    transaksi?: transaksiUpdateManyWithoutLapanganNestedInput
    ulasan?: ulasanUpdateManyWithoutLapanganNestedInput
  }

  export type LapanganUncheckedUpdateWithoutJadwalInput = {
    id?: IntFieldUpdateOperationsInput | number
    mitra_id?: IntFieldUpdateOperationsInput | number
    nama?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    lokasi?: NullableStringFieldUpdateOperationsInput | string | null
    harga?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    gambar?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: Enumlapangan_statusFieldUpdateOperationsInput | $Enums.lapangan_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    detail?: LapanganDetailUncheckedUpdateOneWithoutLapanganNestedInput
    gambarList?: LapanganGambarUncheckedUpdateManyWithoutLapanganNestedInput
    orders?: order_bookingUncheckedUpdateManyWithoutLapanganNestedInput
    transaksi?: transaksiUncheckedUpdateManyWithoutLapanganNestedInput
    ulasan?: ulasanUncheckedUpdateManyWithoutLapanganNestedInput
  }

  export type order_bookingUpsertWithWhereUniqueWithoutJadwalLapanganInput = {
    where: order_bookingWhereUniqueInput
    update: XOR<order_bookingUpdateWithoutJadwalLapanganInput, order_bookingUncheckedUpdateWithoutJadwalLapanganInput>
    create: XOR<order_bookingCreateWithoutJadwalLapanganInput, order_bookingUncheckedCreateWithoutJadwalLapanganInput>
  }

  export type order_bookingUpdateWithWhereUniqueWithoutJadwalLapanganInput = {
    where: order_bookingWhereUniqueInput
    data: XOR<order_bookingUpdateWithoutJadwalLapanganInput, order_bookingUncheckedUpdateWithoutJadwalLapanganInput>
  }

  export type order_bookingUpdateManyWithWhereWithoutJadwalLapanganInput = {
    where: order_bookingScalarWhereInput
    data: XOR<order_bookingUpdateManyMutationInput, order_bookingUncheckedUpdateManyWithoutJadwalLapanganInput>
  }

  export type transaksiUpsertWithWhereUniqueWithoutJadwalInput = {
    where: transaksiWhereUniqueInput
    update: XOR<transaksiUpdateWithoutJadwalInput, transaksiUncheckedUpdateWithoutJadwalInput>
    create: XOR<transaksiCreateWithoutJadwalInput, transaksiUncheckedCreateWithoutJadwalInput>
  }

  export type transaksiUpdateWithWhereUniqueWithoutJadwalInput = {
    where: transaksiWhereUniqueInput
    data: XOR<transaksiUpdateWithoutJadwalInput, transaksiUncheckedUpdateWithoutJadwalInput>
  }

  export type transaksiUpdateManyWithWhereWithoutJadwalInput = {
    where: transaksiScalarWhereInput
    data: XOR<transaksiUpdateManyMutationInput, transaksiUncheckedUpdateManyWithoutJadwalInput>
  }

  export type usersCreateWithoutOrdersInput = {
    nama: string
    username: string
    email: string
    password: string
    no_hp?: string | null
    foto?: string | null
    bio?: string | null
    role?: $Enums.users_role
    status?: $Enums.users_status
    created_at?: Date | string
    updated_at?: Date | string
    mitra?: MitraCreateNestedOneWithoutUserInput
    transaksi?: transaksiCreateNestedManyWithoutUserInput
    notifikasi?: notifikasiCreateNestedManyWithoutUserInput
    ulasan?: ulasanCreateNestedManyWithoutUserInput
    wallet?: wallet_userCreateNestedOneWithoutUserInput
    refund?: refundCreateNestedManyWithoutUserInput
  }

  export type usersUncheckedCreateWithoutOrdersInput = {
    id?: number
    nama: string
    username: string
    email: string
    password: string
    no_hp?: string | null
    foto?: string | null
    bio?: string | null
    role?: $Enums.users_role
    status?: $Enums.users_status
    created_at?: Date | string
    updated_at?: Date | string
    mitra?: MitraUncheckedCreateNestedOneWithoutUserInput
    transaksi?: transaksiUncheckedCreateNestedManyWithoutUserInput
    notifikasi?: notifikasiUncheckedCreateNestedManyWithoutUserInput
    ulasan?: ulasanUncheckedCreateNestedManyWithoutUserInput
    wallet?: wallet_userUncheckedCreateNestedOneWithoutUserInput
    refund?: refundUncheckedCreateNestedManyWithoutUserInput
  }

  export type usersCreateOrConnectWithoutOrdersInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutOrdersInput, usersUncheckedCreateWithoutOrdersInput>
  }

  export type LapanganCreateWithoutOrdersInput = {
    nama: string
    slug: string
    lokasi?: string | null
    harga: Decimal | DecimalJsLike | number | string
    gambar?: string | null
    rating?: number | null
    status?: $Enums.lapangan_status
    created_at?: Date | string
    mitra: MitraCreateNestedOneWithoutLapanganInput
    detail?: LapanganDetailCreateNestedOneWithoutLapanganInput
    gambarList?: LapanganGambarCreateNestedManyWithoutLapanganInput
    jadwal?: JadwalLapanganCreateNestedManyWithoutLapanganInput
    transaksi?: transaksiCreateNestedManyWithoutLapanganInput
    ulasan?: ulasanCreateNestedManyWithoutLapanganInput
  }

  export type LapanganUncheckedCreateWithoutOrdersInput = {
    id?: number
    mitra_id: number
    nama: string
    slug: string
    lokasi?: string | null
    harga: Decimal | DecimalJsLike | number | string
    gambar?: string | null
    rating?: number | null
    status?: $Enums.lapangan_status
    created_at?: Date | string
    detail?: LapanganDetailUncheckedCreateNestedOneWithoutLapanganInput
    gambarList?: LapanganGambarUncheckedCreateNestedManyWithoutLapanganInput
    jadwal?: JadwalLapanganUncheckedCreateNestedManyWithoutLapanganInput
    transaksi?: transaksiUncheckedCreateNestedManyWithoutLapanganInput
    ulasan?: ulasanUncheckedCreateNestedManyWithoutLapanganInput
  }

  export type LapanganCreateOrConnectWithoutOrdersInput = {
    where: LapanganWhereUniqueInput
    create: XOR<LapanganCreateWithoutOrdersInput, LapanganUncheckedCreateWithoutOrdersInput>
  }

  export type JadwalLapanganCreateWithoutOrdersInput = {
    tanggal: Date | string
    slot: string
    status?: $Enums.jadwal_status
    locked_until?: Date | string | null
    lapangan: LapanganCreateNestedOneWithoutJadwalInput
    transaksi?: transaksiCreateNestedManyWithoutJadwalInput
  }

  export type JadwalLapanganUncheckedCreateWithoutOrdersInput = {
    id?: number
    lapangan_id: number
    tanggal: Date | string
    slot: string
    status?: $Enums.jadwal_status
    locked_until?: Date | string | null
    transaksi?: transaksiUncheckedCreateNestedManyWithoutJadwalInput
  }

  export type JadwalLapanganCreateOrConnectWithoutOrdersInput = {
    where: JadwalLapanganWhereUniqueInput
    create: XOR<JadwalLapanganCreateWithoutOrdersInput, JadwalLapanganUncheckedCreateWithoutOrdersInput>
  }

  export type transaksiCreateWithoutOrderInput = {
    total_harga: Decimal | DecimalJsLike | number | string
    status_pembayaran?: $Enums.transaksi_status_pembayaran
    created_at?: Date | string
    user: usersCreateNestedOneWithoutTransaksiInput
    lapangan: LapanganCreateNestedOneWithoutTransaksiInput
    jadwal: JadwalLapanganCreateNestedOneWithoutTransaksiInput
    refund?: refundCreateNestedOneWithoutTransaksiInput
    sewa_raket?: sewa_raketCreateNestedManyWithoutTransaksiInput
  }

  export type transaksiUncheckedCreateWithoutOrderInput = {
    id?: number
    user_id: number
    lapangan_id: number
    jadwal_id: number
    total_harga: Decimal | DecimalJsLike | number | string
    status_pembayaran?: $Enums.transaksi_status_pembayaran
    created_at?: Date | string
    refund?: refundUncheckedCreateNestedOneWithoutTransaksiInput
    sewa_raket?: sewa_raketUncheckedCreateNestedManyWithoutTransaksiInput
  }

  export type transaksiCreateOrConnectWithoutOrderInput = {
    where: transaksiWhereUniqueInput
    create: XOR<transaksiCreateWithoutOrderInput, transaksiUncheckedCreateWithoutOrderInput>
  }

  export type refundCreateWithoutOrderInput = {
    jumlah: Decimal | DecimalJsLike | number | string
    alasan?: string | null
    status?: $Enums.refund_status
    created_at?: Date | string
    processed_at?: Date | string | null
    user: usersCreateNestedOneWithoutRefundInput
    transaksi: transaksiCreateNestedOneWithoutRefundInput
  }

  export type refundUncheckedCreateWithoutOrderInput = {
    id?: number
    user_id: number
    transaksi_id: number
    jumlah: Decimal | DecimalJsLike | number | string
    alasan?: string | null
    status?: $Enums.refund_status
    created_at?: Date | string
    processed_at?: Date | string | null
  }

  export type refundCreateOrConnectWithoutOrderInput = {
    where: refundWhereUniqueInput
    create: XOR<refundCreateWithoutOrderInput, refundUncheckedCreateWithoutOrderInput>
  }

  export type wallet_historyCreateWithoutOrderInput = {
    jumlah: number
    saldo_akhir: number
    tipe: $Enums.wallet_tipe
    transaksi_id?: number | null
    created_at?: Date | string
    wallet: wallet_userCreateNestedOneWithoutHistoryInput
  }

  export type wallet_historyUncheckedCreateWithoutOrderInput = {
    id?: number
    wallet_id: number
    jumlah: number
    saldo_akhir: number
    tipe: $Enums.wallet_tipe
    transaksi_id?: number | null
    created_at?: Date | string
  }

  export type wallet_historyCreateOrConnectWithoutOrderInput = {
    where: wallet_historyWhereUniqueInput
    create: XOR<wallet_historyCreateWithoutOrderInput, wallet_historyUncheckedCreateWithoutOrderInput>
  }

  export type wallet_historyCreateManyOrderInputEnvelope = {
    data: wallet_historyCreateManyOrderInput | wallet_historyCreateManyOrderInput[]
    skipDuplicates?: boolean
  }

  export type usersUpsertWithoutOrdersInput = {
    update: XOR<usersUpdateWithoutOrdersInput, usersUncheckedUpdateWithoutOrdersInput>
    create: XOR<usersCreateWithoutOrdersInput, usersUncheckedCreateWithoutOrdersInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutOrdersInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutOrdersInput, usersUncheckedUpdateWithoutOrdersInput>
  }

  export type usersUpdateWithoutOrdersInput = {
    nama?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    no_hp?: NullableStringFieldUpdateOperationsInput | string | null
    foto?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    role?: Enumusers_roleFieldUpdateOperationsInput | $Enums.users_role
    status?: Enumusers_statusFieldUpdateOperationsInput | $Enums.users_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    mitra?: MitraUpdateOneWithoutUserNestedInput
    transaksi?: transaksiUpdateManyWithoutUserNestedInput
    notifikasi?: notifikasiUpdateManyWithoutUserNestedInput
    ulasan?: ulasanUpdateManyWithoutUserNestedInput
    wallet?: wallet_userUpdateOneWithoutUserNestedInput
    refund?: refundUpdateManyWithoutUserNestedInput
  }

  export type usersUncheckedUpdateWithoutOrdersInput = {
    id?: IntFieldUpdateOperationsInput | number
    nama?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    no_hp?: NullableStringFieldUpdateOperationsInput | string | null
    foto?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    role?: Enumusers_roleFieldUpdateOperationsInput | $Enums.users_role
    status?: Enumusers_statusFieldUpdateOperationsInput | $Enums.users_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    mitra?: MitraUncheckedUpdateOneWithoutUserNestedInput
    transaksi?: transaksiUncheckedUpdateManyWithoutUserNestedInput
    notifikasi?: notifikasiUncheckedUpdateManyWithoutUserNestedInput
    ulasan?: ulasanUncheckedUpdateManyWithoutUserNestedInput
    wallet?: wallet_userUncheckedUpdateOneWithoutUserNestedInput
    refund?: refundUncheckedUpdateManyWithoutUserNestedInput
  }

  export type LapanganUpsertWithoutOrdersInput = {
    update: XOR<LapanganUpdateWithoutOrdersInput, LapanganUncheckedUpdateWithoutOrdersInput>
    create: XOR<LapanganCreateWithoutOrdersInput, LapanganUncheckedCreateWithoutOrdersInput>
    where?: LapanganWhereInput
  }

  export type LapanganUpdateToOneWithWhereWithoutOrdersInput = {
    where?: LapanganWhereInput
    data: XOR<LapanganUpdateWithoutOrdersInput, LapanganUncheckedUpdateWithoutOrdersInput>
  }

  export type LapanganUpdateWithoutOrdersInput = {
    nama?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    lokasi?: NullableStringFieldUpdateOperationsInput | string | null
    harga?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    gambar?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: Enumlapangan_statusFieldUpdateOperationsInput | $Enums.lapangan_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    mitra?: MitraUpdateOneRequiredWithoutLapanganNestedInput
    detail?: LapanganDetailUpdateOneWithoutLapanganNestedInput
    gambarList?: LapanganGambarUpdateManyWithoutLapanganNestedInput
    jadwal?: JadwalLapanganUpdateManyWithoutLapanganNestedInput
    transaksi?: transaksiUpdateManyWithoutLapanganNestedInput
    ulasan?: ulasanUpdateManyWithoutLapanganNestedInput
  }

  export type LapanganUncheckedUpdateWithoutOrdersInput = {
    id?: IntFieldUpdateOperationsInput | number
    mitra_id?: IntFieldUpdateOperationsInput | number
    nama?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    lokasi?: NullableStringFieldUpdateOperationsInput | string | null
    harga?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    gambar?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: Enumlapangan_statusFieldUpdateOperationsInput | $Enums.lapangan_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    detail?: LapanganDetailUncheckedUpdateOneWithoutLapanganNestedInput
    gambarList?: LapanganGambarUncheckedUpdateManyWithoutLapanganNestedInput
    jadwal?: JadwalLapanganUncheckedUpdateManyWithoutLapanganNestedInput
    transaksi?: transaksiUncheckedUpdateManyWithoutLapanganNestedInput
    ulasan?: ulasanUncheckedUpdateManyWithoutLapanganNestedInput
  }

  export type JadwalLapanganUpsertWithoutOrdersInput = {
    update: XOR<JadwalLapanganUpdateWithoutOrdersInput, JadwalLapanganUncheckedUpdateWithoutOrdersInput>
    create: XOR<JadwalLapanganCreateWithoutOrdersInput, JadwalLapanganUncheckedCreateWithoutOrdersInput>
    where?: JadwalLapanganWhereInput
  }

  export type JadwalLapanganUpdateToOneWithWhereWithoutOrdersInput = {
    where?: JadwalLapanganWhereInput
    data: XOR<JadwalLapanganUpdateWithoutOrdersInput, JadwalLapanganUncheckedUpdateWithoutOrdersInput>
  }

  export type JadwalLapanganUpdateWithoutOrdersInput = {
    tanggal?: DateTimeFieldUpdateOperationsInput | Date | string
    slot?: StringFieldUpdateOperationsInput | string
    status?: Enumjadwal_statusFieldUpdateOperationsInput | $Enums.jadwal_status
    locked_until?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lapangan?: LapanganUpdateOneRequiredWithoutJadwalNestedInput
    transaksi?: transaksiUpdateManyWithoutJadwalNestedInput
  }

  export type JadwalLapanganUncheckedUpdateWithoutOrdersInput = {
    id?: IntFieldUpdateOperationsInput | number
    lapangan_id?: IntFieldUpdateOperationsInput | number
    tanggal?: DateTimeFieldUpdateOperationsInput | Date | string
    slot?: StringFieldUpdateOperationsInput | string
    status?: Enumjadwal_statusFieldUpdateOperationsInput | $Enums.jadwal_status
    locked_until?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transaksi?: transaksiUncheckedUpdateManyWithoutJadwalNestedInput
  }

  export type transaksiUpsertWithoutOrderInput = {
    update: XOR<transaksiUpdateWithoutOrderInput, transaksiUncheckedUpdateWithoutOrderInput>
    create: XOR<transaksiCreateWithoutOrderInput, transaksiUncheckedCreateWithoutOrderInput>
    where?: transaksiWhereInput
  }

  export type transaksiUpdateToOneWithWhereWithoutOrderInput = {
    where?: transaksiWhereInput
    data: XOR<transaksiUpdateWithoutOrderInput, transaksiUncheckedUpdateWithoutOrderInput>
  }

  export type transaksiUpdateWithoutOrderInput = {
    total_harga?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status_pembayaran?: Enumtransaksi_status_pembayaranFieldUpdateOperationsInput | $Enums.transaksi_status_pembayaran
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: usersUpdateOneRequiredWithoutTransaksiNestedInput
    lapangan?: LapanganUpdateOneRequiredWithoutTransaksiNestedInput
    jadwal?: JadwalLapanganUpdateOneRequiredWithoutTransaksiNestedInput
    refund?: refundUpdateOneWithoutTransaksiNestedInput
    sewa_raket?: sewa_raketUpdateManyWithoutTransaksiNestedInput
  }

  export type transaksiUncheckedUpdateWithoutOrderInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    lapangan_id?: IntFieldUpdateOperationsInput | number
    jadwal_id?: IntFieldUpdateOperationsInput | number
    total_harga?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status_pembayaran?: Enumtransaksi_status_pembayaranFieldUpdateOperationsInput | $Enums.transaksi_status_pembayaran
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    refund?: refundUncheckedUpdateOneWithoutTransaksiNestedInput
    sewa_raket?: sewa_raketUncheckedUpdateManyWithoutTransaksiNestedInput
  }

  export type refundUpsertWithoutOrderInput = {
    update: XOR<refundUpdateWithoutOrderInput, refundUncheckedUpdateWithoutOrderInput>
    create: XOR<refundCreateWithoutOrderInput, refundUncheckedCreateWithoutOrderInput>
    where?: refundWhereInput
  }

  export type refundUpdateToOneWithWhereWithoutOrderInput = {
    where?: refundWhereInput
    data: XOR<refundUpdateWithoutOrderInput, refundUncheckedUpdateWithoutOrderInput>
  }

  export type refundUpdateWithoutOrderInput = {
    jumlah?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    alasan?: NullableStringFieldUpdateOperationsInput | string | null
    status?: Enumrefund_statusFieldUpdateOperationsInput | $Enums.refund_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    processed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: usersUpdateOneRequiredWithoutRefundNestedInput
    transaksi?: transaksiUpdateOneRequiredWithoutRefundNestedInput
  }

  export type refundUncheckedUpdateWithoutOrderInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    transaksi_id?: IntFieldUpdateOperationsInput | number
    jumlah?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    alasan?: NullableStringFieldUpdateOperationsInput | string | null
    status?: Enumrefund_statusFieldUpdateOperationsInput | $Enums.refund_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    processed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type wallet_historyUpsertWithWhereUniqueWithoutOrderInput = {
    where: wallet_historyWhereUniqueInput
    update: XOR<wallet_historyUpdateWithoutOrderInput, wallet_historyUncheckedUpdateWithoutOrderInput>
    create: XOR<wallet_historyCreateWithoutOrderInput, wallet_historyUncheckedCreateWithoutOrderInput>
  }

  export type wallet_historyUpdateWithWhereUniqueWithoutOrderInput = {
    where: wallet_historyWhereUniqueInput
    data: XOR<wallet_historyUpdateWithoutOrderInput, wallet_historyUncheckedUpdateWithoutOrderInput>
  }

  export type wallet_historyUpdateManyWithWhereWithoutOrderInput = {
    where: wallet_historyScalarWhereInput
    data: XOR<wallet_historyUpdateManyMutationInput, wallet_historyUncheckedUpdateManyWithoutOrderInput>
  }

  export type wallet_historyScalarWhereInput = {
    AND?: wallet_historyScalarWhereInput | wallet_historyScalarWhereInput[]
    OR?: wallet_historyScalarWhereInput[]
    NOT?: wallet_historyScalarWhereInput | wallet_historyScalarWhereInput[]
    id?: IntFilter<"wallet_history"> | number
    wallet_id?: IntFilter<"wallet_history"> | number
    jumlah?: IntFilter<"wallet_history"> | number
    saldo_akhir?: IntFilter<"wallet_history"> | number
    tipe?: Enumwallet_tipeFilter<"wallet_history"> | $Enums.wallet_tipe
    transaksi_id?: IntNullableFilter<"wallet_history"> | number | null
    order_id?: IntNullableFilter<"wallet_history"> | number | null
    created_at?: DateTimeFilter<"wallet_history"> | Date | string
  }

  export type usersCreateWithoutTransaksiInput = {
    nama: string
    username: string
    email: string
    password: string
    no_hp?: string | null
    foto?: string | null
    bio?: string | null
    role?: $Enums.users_role
    status?: $Enums.users_status
    created_at?: Date | string
    updated_at?: Date | string
    mitra?: MitraCreateNestedOneWithoutUserInput
    orders?: order_bookingCreateNestedManyWithoutUserInput
    notifikasi?: notifikasiCreateNestedManyWithoutUserInput
    ulasan?: ulasanCreateNestedManyWithoutUserInput
    wallet?: wallet_userCreateNestedOneWithoutUserInput
    refund?: refundCreateNestedManyWithoutUserInput
  }

  export type usersUncheckedCreateWithoutTransaksiInput = {
    id?: number
    nama: string
    username: string
    email: string
    password: string
    no_hp?: string | null
    foto?: string | null
    bio?: string | null
    role?: $Enums.users_role
    status?: $Enums.users_status
    created_at?: Date | string
    updated_at?: Date | string
    mitra?: MitraUncheckedCreateNestedOneWithoutUserInput
    orders?: order_bookingUncheckedCreateNestedManyWithoutUserInput
    notifikasi?: notifikasiUncheckedCreateNestedManyWithoutUserInput
    ulasan?: ulasanUncheckedCreateNestedManyWithoutUserInput
    wallet?: wallet_userUncheckedCreateNestedOneWithoutUserInput
    refund?: refundUncheckedCreateNestedManyWithoutUserInput
  }

  export type usersCreateOrConnectWithoutTransaksiInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutTransaksiInput, usersUncheckedCreateWithoutTransaksiInput>
  }

  export type LapanganCreateWithoutTransaksiInput = {
    nama: string
    slug: string
    lokasi?: string | null
    harga: Decimal | DecimalJsLike | number | string
    gambar?: string | null
    rating?: number | null
    status?: $Enums.lapangan_status
    created_at?: Date | string
    mitra: MitraCreateNestedOneWithoutLapanganInput
    detail?: LapanganDetailCreateNestedOneWithoutLapanganInput
    gambarList?: LapanganGambarCreateNestedManyWithoutLapanganInput
    jadwal?: JadwalLapanganCreateNestedManyWithoutLapanganInput
    orders?: order_bookingCreateNestedManyWithoutLapanganInput
    ulasan?: ulasanCreateNestedManyWithoutLapanganInput
  }

  export type LapanganUncheckedCreateWithoutTransaksiInput = {
    id?: number
    mitra_id: number
    nama: string
    slug: string
    lokasi?: string | null
    harga: Decimal | DecimalJsLike | number | string
    gambar?: string | null
    rating?: number | null
    status?: $Enums.lapangan_status
    created_at?: Date | string
    detail?: LapanganDetailUncheckedCreateNestedOneWithoutLapanganInput
    gambarList?: LapanganGambarUncheckedCreateNestedManyWithoutLapanganInput
    jadwal?: JadwalLapanganUncheckedCreateNestedManyWithoutLapanganInput
    orders?: order_bookingUncheckedCreateNestedManyWithoutLapanganInput
    ulasan?: ulasanUncheckedCreateNestedManyWithoutLapanganInput
  }

  export type LapanganCreateOrConnectWithoutTransaksiInput = {
    where: LapanganWhereUniqueInput
    create: XOR<LapanganCreateWithoutTransaksiInput, LapanganUncheckedCreateWithoutTransaksiInput>
  }

  export type JadwalLapanganCreateWithoutTransaksiInput = {
    tanggal: Date | string
    slot: string
    status?: $Enums.jadwal_status
    locked_until?: Date | string | null
    lapangan: LapanganCreateNestedOneWithoutJadwalInput
    orders?: order_bookingCreateNestedManyWithoutJadwalLapanganInput
  }

  export type JadwalLapanganUncheckedCreateWithoutTransaksiInput = {
    id?: number
    lapangan_id: number
    tanggal: Date | string
    slot: string
    status?: $Enums.jadwal_status
    locked_until?: Date | string | null
    orders?: order_bookingUncheckedCreateNestedManyWithoutJadwalLapanganInput
  }

  export type JadwalLapanganCreateOrConnectWithoutTransaksiInput = {
    where: JadwalLapanganWhereUniqueInput
    create: XOR<JadwalLapanganCreateWithoutTransaksiInput, JadwalLapanganUncheckedCreateWithoutTransaksiInput>
  }

  export type order_bookingCreateWithoutTransaksiInput = {
    tanggal: Date | string
    jam_mulai: string
    jam_selesai: string
    total_harga: Decimal | DecimalJsLike | number | string
    status: string
    sewa_raket?: boolean
    biaya_raket?: number
    created_at?: Date | string
    expired_at?: Date | string | null
    user: usersCreateNestedOneWithoutOrdersInput
    lapangan: LapanganCreateNestedOneWithoutOrdersInput
    jadwalLapangan: JadwalLapanganCreateNestedOneWithoutOrdersInput
    refund?: refundCreateNestedOneWithoutOrderInput
    wallet_histories?: wallet_historyCreateNestedManyWithoutOrderInput
  }

  export type order_bookingUncheckedCreateWithoutTransaksiInput = {
    id?: number
    user_id: number
    lapangan_id: number
    jadwalLapanganId: number
    tanggal: Date | string
    jam_mulai: string
    jam_selesai: string
    total_harga: Decimal | DecimalJsLike | number | string
    status: string
    sewa_raket?: boolean
    biaya_raket?: number
    created_at?: Date | string
    expired_at?: Date | string | null
    refund?: refundUncheckedCreateNestedOneWithoutOrderInput
    wallet_histories?: wallet_historyUncheckedCreateNestedManyWithoutOrderInput
  }

  export type order_bookingCreateOrConnectWithoutTransaksiInput = {
    where: order_bookingWhereUniqueInput
    create: XOR<order_bookingCreateWithoutTransaksiInput, order_bookingUncheckedCreateWithoutTransaksiInput>
  }

  export type refundCreateWithoutTransaksiInput = {
    jumlah: Decimal | DecimalJsLike | number | string
    alasan?: string | null
    status?: $Enums.refund_status
    created_at?: Date | string
    processed_at?: Date | string | null
    user: usersCreateNestedOneWithoutRefundInput
    order: order_bookingCreateNestedOneWithoutRefundInput
  }

  export type refundUncheckedCreateWithoutTransaksiInput = {
    id?: number
    user_id: number
    order_id: number
    jumlah: Decimal | DecimalJsLike | number | string
    alasan?: string | null
    status?: $Enums.refund_status
    created_at?: Date | string
    processed_at?: Date | string | null
  }

  export type refundCreateOrConnectWithoutTransaksiInput = {
    where: refundWhereUniqueInput
    create: XOR<refundCreateWithoutTransaksiInput, refundUncheckedCreateWithoutTransaksiInput>
  }

  export type sewa_raketCreateWithoutTransaksiInput = {
    jumlah: number
    total_harga: Decimal | DecimalJsLike | number | string
    raket: raket_padelCreateNestedOneWithoutSewa_raketInput
  }

  export type sewa_raketUncheckedCreateWithoutTransaksiInput = {
    id?: number
    raket_id: number
    jumlah: number
    total_harga: Decimal | DecimalJsLike | number | string
  }

  export type sewa_raketCreateOrConnectWithoutTransaksiInput = {
    where: sewa_raketWhereUniqueInput
    create: XOR<sewa_raketCreateWithoutTransaksiInput, sewa_raketUncheckedCreateWithoutTransaksiInput>
  }

  export type sewa_raketCreateManyTransaksiInputEnvelope = {
    data: sewa_raketCreateManyTransaksiInput | sewa_raketCreateManyTransaksiInput[]
    skipDuplicates?: boolean
  }

  export type usersUpsertWithoutTransaksiInput = {
    update: XOR<usersUpdateWithoutTransaksiInput, usersUncheckedUpdateWithoutTransaksiInput>
    create: XOR<usersCreateWithoutTransaksiInput, usersUncheckedCreateWithoutTransaksiInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutTransaksiInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutTransaksiInput, usersUncheckedUpdateWithoutTransaksiInput>
  }

  export type usersUpdateWithoutTransaksiInput = {
    nama?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    no_hp?: NullableStringFieldUpdateOperationsInput | string | null
    foto?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    role?: Enumusers_roleFieldUpdateOperationsInput | $Enums.users_role
    status?: Enumusers_statusFieldUpdateOperationsInput | $Enums.users_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    mitra?: MitraUpdateOneWithoutUserNestedInput
    orders?: order_bookingUpdateManyWithoutUserNestedInput
    notifikasi?: notifikasiUpdateManyWithoutUserNestedInput
    ulasan?: ulasanUpdateManyWithoutUserNestedInput
    wallet?: wallet_userUpdateOneWithoutUserNestedInput
    refund?: refundUpdateManyWithoutUserNestedInput
  }

  export type usersUncheckedUpdateWithoutTransaksiInput = {
    id?: IntFieldUpdateOperationsInput | number
    nama?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    no_hp?: NullableStringFieldUpdateOperationsInput | string | null
    foto?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    role?: Enumusers_roleFieldUpdateOperationsInput | $Enums.users_role
    status?: Enumusers_statusFieldUpdateOperationsInput | $Enums.users_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    mitra?: MitraUncheckedUpdateOneWithoutUserNestedInput
    orders?: order_bookingUncheckedUpdateManyWithoutUserNestedInput
    notifikasi?: notifikasiUncheckedUpdateManyWithoutUserNestedInput
    ulasan?: ulasanUncheckedUpdateManyWithoutUserNestedInput
    wallet?: wallet_userUncheckedUpdateOneWithoutUserNestedInput
    refund?: refundUncheckedUpdateManyWithoutUserNestedInput
  }

  export type LapanganUpsertWithoutTransaksiInput = {
    update: XOR<LapanganUpdateWithoutTransaksiInput, LapanganUncheckedUpdateWithoutTransaksiInput>
    create: XOR<LapanganCreateWithoutTransaksiInput, LapanganUncheckedCreateWithoutTransaksiInput>
    where?: LapanganWhereInput
  }

  export type LapanganUpdateToOneWithWhereWithoutTransaksiInput = {
    where?: LapanganWhereInput
    data: XOR<LapanganUpdateWithoutTransaksiInput, LapanganUncheckedUpdateWithoutTransaksiInput>
  }

  export type LapanganUpdateWithoutTransaksiInput = {
    nama?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    lokasi?: NullableStringFieldUpdateOperationsInput | string | null
    harga?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    gambar?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: Enumlapangan_statusFieldUpdateOperationsInput | $Enums.lapangan_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    mitra?: MitraUpdateOneRequiredWithoutLapanganNestedInput
    detail?: LapanganDetailUpdateOneWithoutLapanganNestedInput
    gambarList?: LapanganGambarUpdateManyWithoutLapanganNestedInput
    jadwal?: JadwalLapanganUpdateManyWithoutLapanganNestedInput
    orders?: order_bookingUpdateManyWithoutLapanganNestedInput
    ulasan?: ulasanUpdateManyWithoutLapanganNestedInput
  }

  export type LapanganUncheckedUpdateWithoutTransaksiInput = {
    id?: IntFieldUpdateOperationsInput | number
    mitra_id?: IntFieldUpdateOperationsInput | number
    nama?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    lokasi?: NullableStringFieldUpdateOperationsInput | string | null
    harga?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    gambar?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: Enumlapangan_statusFieldUpdateOperationsInput | $Enums.lapangan_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    detail?: LapanganDetailUncheckedUpdateOneWithoutLapanganNestedInput
    gambarList?: LapanganGambarUncheckedUpdateManyWithoutLapanganNestedInput
    jadwal?: JadwalLapanganUncheckedUpdateManyWithoutLapanganNestedInput
    orders?: order_bookingUncheckedUpdateManyWithoutLapanganNestedInput
    ulasan?: ulasanUncheckedUpdateManyWithoutLapanganNestedInput
  }

  export type JadwalLapanganUpsertWithoutTransaksiInput = {
    update: XOR<JadwalLapanganUpdateWithoutTransaksiInput, JadwalLapanganUncheckedUpdateWithoutTransaksiInput>
    create: XOR<JadwalLapanganCreateWithoutTransaksiInput, JadwalLapanganUncheckedCreateWithoutTransaksiInput>
    where?: JadwalLapanganWhereInput
  }

  export type JadwalLapanganUpdateToOneWithWhereWithoutTransaksiInput = {
    where?: JadwalLapanganWhereInput
    data: XOR<JadwalLapanganUpdateWithoutTransaksiInput, JadwalLapanganUncheckedUpdateWithoutTransaksiInput>
  }

  export type JadwalLapanganUpdateWithoutTransaksiInput = {
    tanggal?: DateTimeFieldUpdateOperationsInput | Date | string
    slot?: StringFieldUpdateOperationsInput | string
    status?: Enumjadwal_statusFieldUpdateOperationsInput | $Enums.jadwal_status
    locked_until?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lapangan?: LapanganUpdateOneRequiredWithoutJadwalNestedInput
    orders?: order_bookingUpdateManyWithoutJadwalLapanganNestedInput
  }

  export type JadwalLapanganUncheckedUpdateWithoutTransaksiInput = {
    id?: IntFieldUpdateOperationsInput | number
    lapangan_id?: IntFieldUpdateOperationsInput | number
    tanggal?: DateTimeFieldUpdateOperationsInput | Date | string
    slot?: StringFieldUpdateOperationsInput | string
    status?: Enumjadwal_statusFieldUpdateOperationsInput | $Enums.jadwal_status
    locked_until?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    orders?: order_bookingUncheckedUpdateManyWithoutJadwalLapanganNestedInput
  }

  export type order_bookingUpsertWithoutTransaksiInput = {
    update: XOR<order_bookingUpdateWithoutTransaksiInput, order_bookingUncheckedUpdateWithoutTransaksiInput>
    create: XOR<order_bookingCreateWithoutTransaksiInput, order_bookingUncheckedCreateWithoutTransaksiInput>
    where?: order_bookingWhereInput
  }

  export type order_bookingUpdateToOneWithWhereWithoutTransaksiInput = {
    where?: order_bookingWhereInput
    data: XOR<order_bookingUpdateWithoutTransaksiInput, order_bookingUncheckedUpdateWithoutTransaksiInput>
  }

  export type order_bookingUpdateWithoutTransaksiInput = {
    tanggal?: DateTimeFieldUpdateOperationsInput | Date | string
    jam_mulai?: StringFieldUpdateOperationsInput | string
    jam_selesai?: StringFieldUpdateOperationsInput | string
    total_harga?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    sewa_raket?: BoolFieldUpdateOperationsInput | boolean
    biaya_raket?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    expired_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: usersUpdateOneRequiredWithoutOrdersNestedInput
    lapangan?: LapanganUpdateOneRequiredWithoutOrdersNestedInput
    jadwalLapangan?: JadwalLapanganUpdateOneRequiredWithoutOrdersNestedInput
    refund?: refundUpdateOneWithoutOrderNestedInput
    wallet_histories?: wallet_historyUpdateManyWithoutOrderNestedInput
  }

  export type order_bookingUncheckedUpdateWithoutTransaksiInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    lapangan_id?: IntFieldUpdateOperationsInput | number
    jadwalLapanganId?: IntFieldUpdateOperationsInput | number
    tanggal?: DateTimeFieldUpdateOperationsInput | Date | string
    jam_mulai?: StringFieldUpdateOperationsInput | string
    jam_selesai?: StringFieldUpdateOperationsInput | string
    total_harga?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    sewa_raket?: BoolFieldUpdateOperationsInput | boolean
    biaya_raket?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    expired_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refund?: refundUncheckedUpdateOneWithoutOrderNestedInput
    wallet_histories?: wallet_historyUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type refundUpsertWithoutTransaksiInput = {
    update: XOR<refundUpdateWithoutTransaksiInput, refundUncheckedUpdateWithoutTransaksiInput>
    create: XOR<refundCreateWithoutTransaksiInput, refundUncheckedCreateWithoutTransaksiInput>
    where?: refundWhereInput
  }

  export type refundUpdateToOneWithWhereWithoutTransaksiInput = {
    where?: refundWhereInput
    data: XOR<refundUpdateWithoutTransaksiInput, refundUncheckedUpdateWithoutTransaksiInput>
  }

  export type refundUpdateWithoutTransaksiInput = {
    jumlah?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    alasan?: NullableStringFieldUpdateOperationsInput | string | null
    status?: Enumrefund_statusFieldUpdateOperationsInput | $Enums.refund_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    processed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: usersUpdateOneRequiredWithoutRefundNestedInput
    order?: order_bookingUpdateOneRequiredWithoutRefundNestedInput
  }

  export type refundUncheckedUpdateWithoutTransaksiInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    order_id?: IntFieldUpdateOperationsInput | number
    jumlah?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    alasan?: NullableStringFieldUpdateOperationsInput | string | null
    status?: Enumrefund_statusFieldUpdateOperationsInput | $Enums.refund_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    processed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type sewa_raketUpsertWithWhereUniqueWithoutTransaksiInput = {
    where: sewa_raketWhereUniqueInput
    update: XOR<sewa_raketUpdateWithoutTransaksiInput, sewa_raketUncheckedUpdateWithoutTransaksiInput>
    create: XOR<sewa_raketCreateWithoutTransaksiInput, sewa_raketUncheckedCreateWithoutTransaksiInput>
  }

  export type sewa_raketUpdateWithWhereUniqueWithoutTransaksiInput = {
    where: sewa_raketWhereUniqueInput
    data: XOR<sewa_raketUpdateWithoutTransaksiInput, sewa_raketUncheckedUpdateWithoutTransaksiInput>
  }

  export type sewa_raketUpdateManyWithWhereWithoutTransaksiInput = {
    where: sewa_raketScalarWhereInput
    data: XOR<sewa_raketUpdateManyMutationInput, sewa_raketUncheckedUpdateManyWithoutTransaksiInput>
  }

  export type sewa_raketScalarWhereInput = {
    AND?: sewa_raketScalarWhereInput | sewa_raketScalarWhereInput[]
    OR?: sewa_raketScalarWhereInput[]
    NOT?: sewa_raketScalarWhereInput | sewa_raketScalarWhereInput[]
    id?: IntFilter<"sewa_raket"> | number
    transaksi_id?: IntFilter<"sewa_raket"> | number
    raket_id?: IntFilter<"sewa_raket"> | number
    jumlah?: IntFilter<"sewa_raket"> | number
    total_harga?: DecimalFilter<"sewa_raket"> | Decimal | DecimalJsLike | number | string
  }

  export type sewa_raketCreateWithoutRaketInput = {
    jumlah: number
    total_harga: Decimal | DecimalJsLike | number | string
    transaksi: transaksiCreateNestedOneWithoutSewa_raketInput
  }

  export type sewa_raketUncheckedCreateWithoutRaketInput = {
    id?: number
    transaksi_id: number
    jumlah: number
    total_harga: Decimal | DecimalJsLike | number | string
  }

  export type sewa_raketCreateOrConnectWithoutRaketInput = {
    where: sewa_raketWhereUniqueInput
    create: XOR<sewa_raketCreateWithoutRaketInput, sewa_raketUncheckedCreateWithoutRaketInput>
  }

  export type sewa_raketCreateManyRaketInputEnvelope = {
    data: sewa_raketCreateManyRaketInput | sewa_raketCreateManyRaketInput[]
    skipDuplicates?: boolean
  }

  export type sewa_raketUpsertWithWhereUniqueWithoutRaketInput = {
    where: sewa_raketWhereUniqueInput
    update: XOR<sewa_raketUpdateWithoutRaketInput, sewa_raketUncheckedUpdateWithoutRaketInput>
    create: XOR<sewa_raketCreateWithoutRaketInput, sewa_raketUncheckedCreateWithoutRaketInput>
  }

  export type sewa_raketUpdateWithWhereUniqueWithoutRaketInput = {
    where: sewa_raketWhereUniqueInput
    data: XOR<sewa_raketUpdateWithoutRaketInput, sewa_raketUncheckedUpdateWithoutRaketInput>
  }

  export type sewa_raketUpdateManyWithWhereWithoutRaketInput = {
    where: sewa_raketScalarWhereInput
    data: XOR<sewa_raketUpdateManyMutationInput, sewa_raketUncheckedUpdateManyWithoutRaketInput>
  }

  export type transaksiCreateWithoutSewa_raketInput = {
    total_harga: Decimal | DecimalJsLike | number | string
    status_pembayaran?: $Enums.transaksi_status_pembayaran
    created_at?: Date | string
    user: usersCreateNestedOneWithoutTransaksiInput
    lapangan: LapanganCreateNestedOneWithoutTransaksiInput
    jadwal: JadwalLapanganCreateNestedOneWithoutTransaksiInput
    order?: order_bookingCreateNestedOneWithoutTransaksiInput
    refund?: refundCreateNestedOneWithoutTransaksiInput
  }

  export type transaksiUncheckedCreateWithoutSewa_raketInput = {
    id?: number
    user_id: number
    lapangan_id: number
    jadwal_id: number
    order_id?: number | null
    total_harga: Decimal | DecimalJsLike | number | string
    status_pembayaran?: $Enums.transaksi_status_pembayaran
    created_at?: Date | string
    refund?: refundUncheckedCreateNestedOneWithoutTransaksiInput
  }

  export type transaksiCreateOrConnectWithoutSewa_raketInput = {
    where: transaksiWhereUniqueInput
    create: XOR<transaksiCreateWithoutSewa_raketInput, transaksiUncheckedCreateWithoutSewa_raketInput>
  }

  export type raket_padelCreateWithoutSewa_raketInput = {
    nama: string
    harga: Decimal | DecimalJsLike | number | string
  }

  export type raket_padelUncheckedCreateWithoutSewa_raketInput = {
    id?: number
    nama: string
    harga: Decimal | DecimalJsLike | number | string
  }

  export type raket_padelCreateOrConnectWithoutSewa_raketInput = {
    where: raket_padelWhereUniqueInput
    create: XOR<raket_padelCreateWithoutSewa_raketInput, raket_padelUncheckedCreateWithoutSewa_raketInput>
  }

  export type transaksiUpsertWithoutSewa_raketInput = {
    update: XOR<transaksiUpdateWithoutSewa_raketInput, transaksiUncheckedUpdateWithoutSewa_raketInput>
    create: XOR<transaksiCreateWithoutSewa_raketInput, transaksiUncheckedCreateWithoutSewa_raketInput>
    where?: transaksiWhereInput
  }

  export type transaksiUpdateToOneWithWhereWithoutSewa_raketInput = {
    where?: transaksiWhereInput
    data: XOR<transaksiUpdateWithoutSewa_raketInput, transaksiUncheckedUpdateWithoutSewa_raketInput>
  }

  export type transaksiUpdateWithoutSewa_raketInput = {
    total_harga?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status_pembayaran?: Enumtransaksi_status_pembayaranFieldUpdateOperationsInput | $Enums.transaksi_status_pembayaran
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: usersUpdateOneRequiredWithoutTransaksiNestedInput
    lapangan?: LapanganUpdateOneRequiredWithoutTransaksiNestedInput
    jadwal?: JadwalLapanganUpdateOneRequiredWithoutTransaksiNestedInput
    order?: order_bookingUpdateOneWithoutTransaksiNestedInput
    refund?: refundUpdateOneWithoutTransaksiNestedInput
  }

  export type transaksiUncheckedUpdateWithoutSewa_raketInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    lapangan_id?: IntFieldUpdateOperationsInput | number
    jadwal_id?: IntFieldUpdateOperationsInput | number
    order_id?: NullableIntFieldUpdateOperationsInput | number | null
    total_harga?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status_pembayaran?: Enumtransaksi_status_pembayaranFieldUpdateOperationsInput | $Enums.transaksi_status_pembayaran
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    refund?: refundUncheckedUpdateOneWithoutTransaksiNestedInput
  }

  export type raket_padelUpsertWithoutSewa_raketInput = {
    update: XOR<raket_padelUpdateWithoutSewa_raketInput, raket_padelUncheckedUpdateWithoutSewa_raketInput>
    create: XOR<raket_padelCreateWithoutSewa_raketInput, raket_padelUncheckedCreateWithoutSewa_raketInput>
    where?: raket_padelWhereInput
  }

  export type raket_padelUpdateToOneWithWhereWithoutSewa_raketInput = {
    where?: raket_padelWhereInput
    data: XOR<raket_padelUpdateWithoutSewa_raketInput, raket_padelUncheckedUpdateWithoutSewa_raketInput>
  }

  export type raket_padelUpdateWithoutSewa_raketInput = {
    nama?: StringFieldUpdateOperationsInput | string
    harga?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type raket_padelUncheckedUpdateWithoutSewa_raketInput = {
    id?: IntFieldUpdateOperationsInput | number
    nama?: StringFieldUpdateOperationsInput | string
    harga?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type usersCreateWithoutWalletInput = {
    nama: string
    username: string
    email: string
    password: string
    no_hp?: string | null
    foto?: string | null
    bio?: string | null
    role?: $Enums.users_role
    status?: $Enums.users_status
    created_at?: Date | string
    updated_at?: Date | string
    mitra?: MitraCreateNestedOneWithoutUserInput
    orders?: order_bookingCreateNestedManyWithoutUserInput
    transaksi?: transaksiCreateNestedManyWithoutUserInput
    notifikasi?: notifikasiCreateNestedManyWithoutUserInput
    ulasan?: ulasanCreateNestedManyWithoutUserInput
    refund?: refundCreateNestedManyWithoutUserInput
  }

  export type usersUncheckedCreateWithoutWalletInput = {
    id?: number
    nama: string
    username: string
    email: string
    password: string
    no_hp?: string | null
    foto?: string | null
    bio?: string | null
    role?: $Enums.users_role
    status?: $Enums.users_status
    created_at?: Date | string
    updated_at?: Date | string
    mitra?: MitraUncheckedCreateNestedOneWithoutUserInput
    orders?: order_bookingUncheckedCreateNestedManyWithoutUserInput
    transaksi?: transaksiUncheckedCreateNestedManyWithoutUserInput
    notifikasi?: notifikasiUncheckedCreateNestedManyWithoutUserInput
    ulasan?: ulasanUncheckedCreateNestedManyWithoutUserInput
    refund?: refundUncheckedCreateNestedManyWithoutUserInput
  }

  export type usersCreateOrConnectWithoutWalletInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutWalletInput, usersUncheckedCreateWithoutWalletInput>
  }

  export type wallet_historyCreateWithoutWalletInput = {
    jumlah: number
    saldo_akhir: number
    tipe: $Enums.wallet_tipe
    transaksi_id?: number | null
    created_at?: Date | string
    order?: order_bookingCreateNestedOneWithoutWallet_historiesInput
  }

  export type wallet_historyUncheckedCreateWithoutWalletInput = {
    id?: number
    jumlah: number
    saldo_akhir: number
    tipe: $Enums.wallet_tipe
    transaksi_id?: number | null
    order_id?: number | null
    created_at?: Date | string
  }

  export type wallet_historyCreateOrConnectWithoutWalletInput = {
    where: wallet_historyWhereUniqueInput
    create: XOR<wallet_historyCreateWithoutWalletInput, wallet_historyUncheckedCreateWithoutWalletInput>
  }

  export type wallet_historyCreateManyWalletInputEnvelope = {
    data: wallet_historyCreateManyWalletInput | wallet_historyCreateManyWalletInput[]
    skipDuplicates?: boolean
  }

  export type usersUpsertWithoutWalletInput = {
    update: XOR<usersUpdateWithoutWalletInput, usersUncheckedUpdateWithoutWalletInput>
    create: XOR<usersCreateWithoutWalletInput, usersUncheckedCreateWithoutWalletInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutWalletInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutWalletInput, usersUncheckedUpdateWithoutWalletInput>
  }

  export type usersUpdateWithoutWalletInput = {
    nama?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    no_hp?: NullableStringFieldUpdateOperationsInput | string | null
    foto?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    role?: Enumusers_roleFieldUpdateOperationsInput | $Enums.users_role
    status?: Enumusers_statusFieldUpdateOperationsInput | $Enums.users_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    mitra?: MitraUpdateOneWithoutUserNestedInput
    orders?: order_bookingUpdateManyWithoutUserNestedInput
    transaksi?: transaksiUpdateManyWithoutUserNestedInput
    notifikasi?: notifikasiUpdateManyWithoutUserNestedInput
    ulasan?: ulasanUpdateManyWithoutUserNestedInput
    refund?: refundUpdateManyWithoutUserNestedInput
  }

  export type usersUncheckedUpdateWithoutWalletInput = {
    id?: IntFieldUpdateOperationsInput | number
    nama?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    no_hp?: NullableStringFieldUpdateOperationsInput | string | null
    foto?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    role?: Enumusers_roleFieldUpdateOperationsInput | $Enums.users_role
    status?: Enumusers_statusFieldUpdateOperationsInput | $Enums.users_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    mitra?: MitraUncheckedUpdateOneWithoutUserNestedInput
    orders?: order_bookingUncheckedUpdateManyWithoutUserNestedInput
    transaksi?: transaksiUncheckedUpdateManyWithoutUserNestedInput
    notifikasi?: notifikasiUncheckedUpdateManyWithoutUserNestedInput
    ulasan?: ulasanUncheckedUpdateManyWithoutUserNestedInput
    refund?: refundUncheckedUpdateManyWithoutUserNestedInput
  }

  export type wallet_historyUpsertWithWhereUniqueWithoutWalletInput = {
    where: wallet_historyWhereUniqueInput
    update: XOR<wallet_historyUpdateWithoutWalletInput, wallet_historyUncheckedUpdateWithoutWalletInput>
    create: XOR<wallet_historyCreateWithoutWalletInput, wallet_historyUncheckedCreateWithoutWalletInput>
  }

  export type wallet_historyUpdateWithWhereUniqueWithoutWalletInput = {
    where: wallet_historyWhereUniqueInput
    data: XOR<wallet_historyUpdateWithoutWalletInput, wallet_historyUncheckedUpdateWithoutWalletInput>
  }

  export type wallet_historyUpdateManyWithWhereWithoutWalletInput = {
    where: wallet_historyScalarWhereInput
    data: XOR<wallet_historyUpdateManyMutationInput, wallet_historyUncheckedUpdateManyWithoutWalletInput>
  }

  export type wallet_userCreateWithoutHistoryInput = {
    saldo?: number
    updated_at?: Date | string
    user: usersCreateNestedOneWithoutWalletInput
  }

  export type wallet_userUncheckedCreateWithoutHistoryInput = {
    id?: number
    user_id: number
    saldo?: number
    updated_at?: Date | string
  }

  export type wallet_userCreateOrConnectWithoutHistoryInput = {
    where: wallet_userWhereUniqueInput
    create: XOR<wallet_userCreateWithoutHistoryInput, wallet_userUncheckedCreateWithoutHistoryInput>
  }

  export type order_bookingCreateWithoutWallet_historiesInput = {
    tanggal: Date | string
    jam_mulai: string
    jam_selesai: string
    total_harga: Decimal | DecimalJsLike | number | string
    status: string
    sewa_raket?: boolean
    biaya_raket?: number
    created_at?: Date | string
    expired_at?: Date | string | null
    user: usersCreateNestedOneWithoutOrdersInput
    lapangan: LapanganCreateNestedOneWithoutOrdersInput
    jadwalLapangan: JadwalLapanganCreateNestedOneWithoutOrdersInput
    transaksi?: transaksiCreateNestedOneWithoutOrderInput
    refund?: refundCreateNestedOneWithoutOrderInput
  }

  export type order_bookingUncheckedCreateWithoutWallet_historiesInput = {
    id?: number
    user_id: number
    lapangan_id: number
    jadwalLapanganId: number
    tanggal: Date | string
    jam_mulai: string
    jam_selesai: string
    total_harga: Decimal | DecimalJsLike | number | string
    status: string
    sewa_raket?: boolean
    biaya_raket?: number
    created_at?: Date | string
    expired_at?: Date | string | null
    transaksi?: transaksiUncheckedCreateNestedOneWithoutOrderInput
    refund?: refundUncheckedCreateNestedOneWithoutOrderInput
  }

  export type order_bookingCreateOrConnectWithoutWallet_historiesInput = {
    where: order_bookingWhereUniqueInput
    create: XOR<order_bookingCreateWithoutWallet_historiesInput, order_bookingUncheckedCreateWithoutWallet_historiesInput>
  }

  export type wallet_userUpsertWithoutHistoryInput = {
    update: XOR<wallet_userUpdateWithoutHistoryInput, wallet_userUncheckedUpdateWithoutHistoryInput>
    create: XOR<wallet_userCreateWithoutHistoryInput, wallet_userUncheckedCreateWithoutHistoryInput>
    where?: wallet_userWhereInput
  }

  export type wallet_userUpdateToOneWithWhereWithoutHistoryInput = {
    where?: wallet_userWhereInput
    data: XOR<wallet_userUpdateWithoutHistoryInput, wallet_userUncheckedUpdateWithoutHistoryInput>
  }

  export type wallet_userUpdateWithoutHistoryInput = {
    saldo?: IntFieldUpdateOperationsInput | number
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: usersUpdateOneRequiredWithoutWalletNestedInput
  }

  export type wallet_userUncheckedUpdateWithoutHistoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    saldo?: IntFieldUpdateOperationsInput | number
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type order_bookingUpsertWithoutWallet_historiesInput = {
    update: XOR<order_bookingUpdateWithoutWallet_historiesInput, order_bookingUncheckedUpdateWithoutWallet_historiesInput>
    create: XOR<order_bookingCreateWithoutWallet_historiesInput, order_bookingUncheckedCreateWithoutWallet_historiesInput>
    where?: order_bookingWhereInput
  }

  export type order_bookingUpdateToOneWithWhereWithoutWallet_historiesInput = {
    where?: order_bookingWhereInput
    data: XOR<order_bookingUpdateWithoutWallet_historiesInput, order_bookingUncheckedUpdateWithoutWallet_historiesInput>
  }

  export type order_bookingUpdateWithoutWallet_historiesInput = {
    tanggal?: DateTimeFieldUpdateOperationsInput | Date | string
    jam_mulai?: StringFieldUpdateOperationsInput | string
    jam_selesai?: StringFieldUpdateOperationsInput | string
    total_harga?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    sewa_raket?: BoolFieldUpdateOperationsInput | boolean
    biaya_raket?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    expired_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: usersUpdateOneRequiredWithoutOrdersNestedInput
    lapangan?: LapanganUpdateOneRequiredWithoutOrdersNestedInput
    jadwalLapangan?: JadwalLapanganUpdateOneRequiredWithoutOrdersNestedInput
    transaksi?: transaksiUpdateOneWithoutOrderNestedInput
    refund?: refundUpdateOneWithoutOrderNestedInput
  }

  export type order_bookingUncheckedUpdateWithoutWallet_historiesInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    lapangan_id?: IntFieldUpdateOperationsInput | number
    jadwalLapanganId?: IntFieldUpdateOperationsInput | number
    tanggal?: DateTimeFieldUpdateOperationsInput | Date | string
    jam_mulai?: StringFieldUpdateOperationsInput | string
    jam_selesai?: StringFieldUpdateOperationsInput | string
    total_harga?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    sewa_raket?: BoolFieldUpdateOperationsInput | boolean
    biaya_raket?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    expired_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transaksi?: transaksiUncheckedUpdateOneWithoutOrderNestedInput
    refund?: refundUncheckedUpdateOneWithoutOrderNestedInput
  }

  export type usersCreateWithoutRefundInput = {
    nama: string
    username: string
    email: string
    password: string
    no_hp?: string | null
    foto?: string | null
    bio?: string | null
    role?: $Enums.users_role
    status?: $Enums.users_status
    created_at?: Date | string
    updated_at?: Date | string
    mitra?: MitraCreateNestedOneWithoutUserInput
    orders?: order_bookingCreateNestedManyWithoutUserInput
    transaksi?: transaksiCreateNestedManyWithoutUserInput
    notifikasi?: notifikasiCreateNestedManyWithoutUserInput
    ulasan?: ulasanCreateNestedManyWithoutUserInput
    wallet?: wallet_userCreateNestedOneWithoutUserInput
  }

  export type usersUncheckedCreateWithoutRefundInput = {
    id?: number
    nama: string
    username: string
    email: string
    password: string
    no_hp?: string | null
    foto?: string | null
    bio?: string | null
    role?: $Enums.users_role
    status?: $Enums.users_status
    created_at?: Date | string
    updated_at?: Date | string
    mitra?: MitraUncheckedCreateNestedOneWithoutUserInput
    orders?: order_bookingUncheckedCreateNestedManyWithoutUserInput
    transaksi?: transaksiUncheckedCreateNestedManyWithoutUserInput
    notifikasi?: notifikasiUncheckedCreateNestedManyWithoutUserInput
    ulasan?: ulasanUncheckedCreateNestedManyWithoutUserInput
    wallet?: wallet_userUncheckedCreateNestedOneWithoutUserInput
  }

  export type usersCreateOrConnectWithoutRefundInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutRefundInput, usersUncheckedCreateWithoutRefundInput>
  }

  export type transaksiCreateWithoutRefundInput = {
    total_harga: Decimal | DecimalJsLike | number | string
    status_pembayaran?: $Enums.transaksi_status_pembayaran
    created_at?: Date | string
    user: usersCreateNestedOneWithoutTransaksiInput
    lapangan: LapanganCreateNestedOneWithoutTransaksiInput
    jadwal: JadwalLapanganCreateNestedOneWithoutTransaksiInput
    order?: order_bookingCreateNestedOneWithoutTransaksiInput
    sewa_raket?: sewa_raketCreateNestedManyWithoutTransaksiInput
  }

  export type transaksiUncheckedCreateWithoutRefundInput = {
    id?: number
    user_id: number
    lapangan_id: number
    jadwal_id: number
    order_id?: number | null
    total_harga: Decimal | DecimalJsLike | number | string
    status_pembayaran?: $Enums.transaksi_status_pembayaran
    created_at?: Date | string
    sewa_raket?: sewa_raketUncheckedCreateNestedManyWithoutTransaksiInput
  }

  export type transaksiCreateOrConnectWithoutRefundInput = {
    where: transaksiWhereUniqueInput
    create: XOR<transaksiCreateWithoutRefundInput, transaksiUncheckedCreateWithoutRefundInput>
  }

  export type order_bookingCreateWithoutRefundInput = {
    tanggal: Date | string
    jam_mulai: string
    jam_selesai: string
    total_harga: Decimal | DecimalJsLike | number | string
    status: string
    sewa_raket?: boolean
    biaya_raket?: number
    created_at?: Date | string
    expired_at?: Date | string | null
    user: usersCreateNestedOneWithoutOrdersInput
    lapangan: LapanganCreateNestedOneWithoutOrdersInput
    jadwalLapangan: JadwalLapanganCreateNestedOneWithoutOrdersInput
    transaksi?: transaksiCreateNestedOneWithoutOrderInput
    wallet_histories?: wallet_historyCreateNestedManyWithoutOrderInput
  }

  export type order_bookingUncheckedCreateWithoutRefundInput = {
    id?: number
    user_id: number
    lapangan_id: number
    jadwalLapanganId: number
    tanggal: Date | string
    jam_mulai: string
    jam_selesai: string
    total_harga: Decimal | DecimalJsLike | number | string
    status: string
    sewa_raket?: boolean
    biaya_raket?: number
    created_at?: Date | string
    expired_at?: Date | string | null
    transaksi?: transaksiUncheckedCreateNestedOneWithoutOrderInput
    wallet_histories?: wallet_historyUncheckedCreateNestedManyWithoutOrderInput
  }

  export type order_bookingCreateOrConnectWithoutRefundInput = {
    where: order_bookingWhereUniqueInput
    create: XOR<order_bookingCreateWithoutRefundInput, order_bookingUncheckedCreateWithoutRefundInput>
  }

  export type usersUpsertWithoutRefundInput = {
    update: XOR<usersUpdateWithoutRefundInput, usersUncheckedUpdateWithoutRefundInput>
    create: XOR<usersCreateWithoutRefundInput, usersUncheckedCreateWithoutRefundInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutRefundInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutRefundInput, usersUncheckedUpdateWithoutRefundInput>
  }

  export type usersUpdateWithoutRefundInput = {
    nama?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    no_hp?: NullableStringFieldUpdateOperationsInput | string | null
    foto?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    role?: Enumusers_roleFieldUpdateOperationsInput | $Enums.users_role
    status?: Enumusers_statusFieldUpdateOperationsInput | $Enums.users_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    mitra?: MitraUpdateOneWithoutUserNestedInput
    orders?: order_bookingUpdateManyWithoutUserNestedInput
    transaksi?: transaksiUpdateManyWithoutUserNestedInput
    notifikasi?: notifikasiUpdateManyWithoutUserNestedInput
    ulasan?: ulasanUpdateManyWithoutUserNestedInput
    wallet?: wallet_userUpdateOneWithoutUserNestedInput
  }

  export type usersUncheckedUpdateWithoutRefundInput = {
    id?: IntFieldUpdateOperationsInput | number
    nama?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    no_hp?: NullableStringFieldUpdateOperationsInput | string | null
    foto?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    role?: Enumusers_roleFieldUpdateOperationsInput | $Enums.users_role
    status?: Enumusers_statusFieldUpdateOperationsInput | $Enums.users_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    mitra?: MitraUncheckedUpdateOneWithoutUserNestedInput
    orders?: order_bookingUncheckedUpdateManyWithoutUserNestedInput
    transaksi?: transaksiUncheckedUpdateManyWithoutUserNestedInput
    notifikasi?: notifikasiUncheckedUpdateManyWithoutUserNestedInput
    ulasan?: ulasanUncheckedUpdateManyWithoutUserNestedInput
    wallet?: wallet_userUncheckedUpdateOneWithoutUserNestedInput
  }

  export type transaksiUpsertWithoutRefundInput = {
    update: XOR<transaksiUpdateWithoutRefundInput, transaksiUncheckedUpdateWithoutRefundInput>
    create: XOR<transaksiCreateWithoutRefundInput, transaksiUncheckedCreateWithoutRefundInput>
    where?: transaksiWhereInput
  }

  export type transaksiUpdateToOneWithWhereWithoutRefundInput = {
    where?: transaksiWhereInput
    data: XOR<transaksiUpdateWithoutRefundInput, transaksiUncheckedUpdateWithoutRefundInput>
  }

  export type transaksiUpdateWithoutRefundInput = {
    total_harga?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status_pembayaran?: Enumtransaksi_status_pembayaranFieldUpdateOperationsInput | $Enums.transaksi_status_pembayaran
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: usersUpdateOneRequiredWithoutTransaksiNestedInput
    lapangan?: LapanganUpdateOneRequiredWithoutTransaksiNestedInput
    jadwal?: JadwalLapanganUpdateOneRequiredWithoutTransaksiNestedInput
    order?: order_bookingUpdateOneWithoutTransaksiNestedInput
    sewa_raket?: sewa_raketUpdateManyWithoutTransaksiNestedInput
  }

  export type transaksiUncheckedUpdateWithoutRefundInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    lapangan_id?: IntFieldUpdateOperationsInput | number
    jadwal_id?: IntFieldUpdateOperationsInput | number
    order_id?: NullableIntFieldUpdateOperationsInput | number | null
    total_harga?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status_pembayaran?: Enumtransaksi_status_pembayaranFieldUpdateOperationsInput | $Enums.transaksi_status_pembayaran
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    sewa_raket?: sewa_raketUncheckedUpdateManyWithoutTransaksiNestedInput
  }

  export type order_bookingUpsertWithoutRefundInput = {
    update: XOR<order_bookingUpdateWithoutRefundInput, order_bookingUncheckedUpdateWithoutRefundInput>
    create: XOR<order_bookingCreateWithoutRefundInput, order_bookingUncheckedCreateWithoutRefundInput>
    where?: order_bookingWhereInput
  }

  export type order_bookingUpdateToOneWithWhereWithoutRefundInput = {
    where?: order_bookingWhereInput
    data: XOR<order_bookingUpdateWithoutRefundInput, order_bookingUncheckedUpdateWithoutRefundInput>
  }

  export type order_bookingUpdateWithoutRefundInput = {
    tanggal?: DateTimeFieldUpdateOperationsInput | Date | string
    jam_mulai?: StringFieldUpdateOperationsInput | string
    jam_selesai?: StringFieldUpdateOperationsInput | string
    total_harga?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    sewa_raket?: BoolFieldUpdateOperationsInput | boolean
    biaya_raket?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    expired_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: usersUpdateOneRequiredWithoutOrdersNestedInput
    lapangan?: LapanganUpdateOneRequiredWithoutOrdersNestedInput
    jadwalLapangan?: JadwalLapanganUpdateOneRequiredWithoutOrdersNestedInput
    transaksi?: transaksiUpdateOneWithoutOrderNestedInput
    wallet_histories?: wallet_historyUpdateManyWithoutOrderNestedInput
  }

  export type order_bookingUncheckedUpdateWithoutRefundInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    lapangan_id?: IntFieldUpdateOperationsInput | number
    jadwalLapanganId?: IntFieldUpdateOperationsInput | number
    tanggal?: DateTimeFieldUpdateOperationsInput | Date | string
    jam_mulai?: StringFieldUpdateOperationsInput | string
    jam_selesai?: StringFieldUpdateOperationsInput | string
    total_harga?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    sewa_raket?: BoolFieldUpdateOperationsInput | boolean
    biaya_raket?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    expired_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transaksi?: transaksiUncheckedUpdateOneWithoutOrderNestedInput
    wallet_histories?: wallet_historyUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type usersCreateWithoutNotifikasiInput = {
    nama: string
    username: string
    email: string
    password: string
    no_hp?: string | null
    foto?: string | null
    bio?: string | null
    role?: $Enums.users_role
    status?: $Enums.users_status
    created_at?: Date | string
    updated_at?: Date | string
    mitra?: MitraCreateNestedOneWithoutUserInput
    orders?: order_bookingCreateNestedManyWithoutUserInput
    transaksi?: transaksiCreateNestedManyWithoutUserInput
    ulasan?: ulasanCreateNestedManyWithoutUserInput
    wallet?: wallet_userCreateNestedOneWithoutUserInput
    refund?: refundCreateNestedManyWithoutUserInput
  }

  export type usersUncheckedCreateWithoutNotifikasiInput = {
    id?: number
    nama: string
    username: string
    email: string
    password: string
    no_hp?: string | null
    foto?: string | null
    bio?: string | null
    role?: $Enums.users_role
    status?: $Enums.users_status
    created_at?: Date | string
    updated_at?: Date | string
    mitra?: MitraUncheckedCreateNestedOneWithoutUserInput
    orders?: order_bookingUncheckedCreateNestedManyWithoutUserInput
    transaksi?: transaksiUncheckedCreateNestedManyWithoutUserInput
    ulasan?: ulasanUncheckedCreateNestedManyWithoutUserInput
    wallet?: wallet_userUncheckedCreateNestedOneWithoutUserInput
    refund?: refundUncheckedCreateNestedManyWithoutUserInput
  }

  export type usersCreateOrConnectWithoutNotifikasiInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutNotifikasiInput, usersUncheckedCreateWithoutNotifikasiInput>
  }

  export type usersUpsertWithoutNotifikasiInput = {
    update: XOR<usersUpdateWithoutNotifikasiInput, usersUncheckedUpdateWithoutNotifikasiInput>
    create: XOR<usersCreateWithoutNotifikasiInput, usersUncheckedCreateWithoutNotifikasiInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutNotifikasiInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutNotifikasiInput, usersUncheckedUpdateWithoutNotifikasiInput>
  }

  export type usersUpdateWithoutNotifikasiInput = {
    nama?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    no_hp?: NullableStringFieldUpdateOperationsInput | string | null
    foto?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    role?: Enumusers_roleFieldUpdateOperationsInput | $Enums.users_role
    status?: Enumusers_statusFieldUpdateOperationsInput | $Enums.users_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    mitra?: MitraUpdateOneWithoutUserNestedInput
    orders?: order_bookingUpdateManyWithoutUserNestedInput
    transaksi?: transaksiUpdateManyWithoutUserNestedInput
    ulasan?: ulasanUpdateManyWithoutUserNestedInput
    wallet?: wallet_userUpdateOneWithoutUserNestedInput
    refund?: refundUpdateManyWithoutUserNestedInput
  }

  export type usersUncheckedUpdateWithoutNotifikasiInput = {
    id?: IntFieldUpdateOperationsInput | number
    nama?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    no_hp?: NullableStringFieldUpdateOperationsInput | string | null
    foto?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    role?: Enumusers_roleFieldUpdateOperationsInput | $Enums.users_role
    status?: Enumusers_statusFieldUpdateOperationsInput | $Enums.users_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    mitra?: MitraUncheckedUpdateOneWithoutUserNestedInput
    orders?: order_bookingUncheckedUpdateManyWithoutUserNestedInput
    transaksi?: transaksiUncheckedUpdateManyWithoutUserNestedInput
    ulasan?: ulasanUncheckedUpdateManyWithoutUserNestedInput
    wallet?: wallet_userUncheckedUpdateOneWithoutUserNestedInput
    refund?: refundUncheckedUpdateManyWithoutUserNestedInput
  }

  export type usersCreateWithoutUlasanInput = {
    nama: string
    username: string
    email: string
    password: string
    no_hp?: string | null
    foto?: string | null
    bio?: string | null
    role?: $Enums.users_role
    status?: $Enums.users_status
    created_at?: Date | string
    updated_at?: Date | string
    mitra?: MitraCreateNestedOneWithoutUserInput
    orders?: order_bookingCreateNestedManyWithoutUserInput
    transaksi?: transaksiCreateNestedManyWithoutUserInput
    notifikasi?: notifikasiCreateNestedManyWithoutUserInput
    wallet?: wallet_userCreateNestedOneWithoutUserInput
    refund?: refundCreateNestedManyWithoutUserInput
  }

  export type usersUncheckedCreateWithoutUlasanInput = {
    id?: number
    nama: string
    username: string
    email: string
    password: string
    no_hp?: string | null
    foto?: string | null
    bio?: string | null
    role?: $Enums.users_role
    status?: $Enums.users_status
    created_at?: Date | string
    updated_at?: Date | string
    mitra?: MitraUncheckedCreateNestedOneWithoutUserInput
    orders?: order_bookingUncheckedCreateNestedManyWithoutUserInput
    transaksi?: transaksiUncheckedCreateNestedManyWithoutUserInput
    notifikasi?: notifikasiUncheckedCreateNestedManyWithoutUserInput
    wallet?: wallet_userUncheckedCreateNestedOneWithoutUserInput
    refund?: refundUncheckedCreateNestedManyWithoutUserInput
  }

  export type usersCreateOrConnectWithoutUlasanInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutUlasanInput, usersUncheckedCreateWithoutUlasanInput>
  }

  export type LapanganCreateWithoutUlasanInput = {
    nama: string
    slug: string
    lokasi?: string | null
    harga: Decimal | DecimalJsLike | number | string
    gambar?: string | null
    rating?: number | null
    status?: $Enums.lapangan_status
    created_at?: Date | string
    mitra: MitraCreateNestedOneWithoutLapanganInput
    detail?: LapanganDetailCreateNestedOneWithoutLapanganInput
    gambarList?: LapanganGambarCreateNestedManyWithoutLapanganInput
    jadwal?: JadwalLapanganCreateNestedManyWithoutLapanganInput
    orders?: order_bookingCreateNestedManyWithoutLapanganInput
    transaksi?: transaksiCreateNestedManyWithoutLapanganInput
  }

  export type LapanganUncheckedCreateWithoutUlasanInput = {
    id?: number
    mitra_id: number
    nama: string
    slug: string
    lokasi?: string | null
    harga: Decimal | DecimalJsLike | number | string
    gambar?: string | null
    rating?: number | null
    status?: $Enums.lapangan_status
    created_at?: Date | string
    detail?: LapanganDetailUncheckedCreateNestedOneWithoutLapanganInput
    gambarList?: LapanganGambarUncheckedCreateNestedManyWithoutLapanganInput
    jadwal?: JadwalLapanganUncheckedCreateNestedManyWithoutLapanganInput
    orders?: order_bookingUncheckedCreateNestedManyWithoutLapanganInput
    transaksi?: transaksiUncheckedCreateNestedManyWithoutLapanganInput
  }

  export type LapanganCreateOrConnectWithoutUlasanInput = {
    where: LapanganWhereUniqueInput
    create: XOR<LapanganCreateWithoutUlasanInput, LapanganUncheckedCreateWithoutUlasanInput>
  }

  export type usersUpsertWithoutUlasanInput = {
    update: XOR<usersUpdateWithoutUlasanInput, usersUncheckedUpdateWithoutUlasanInput>
    create: XOR<usersCreateWithoutUlasanInput, usersUncheckedCreateWithoutUlasanInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutUlasanInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutUlasanInput, usersUncheckedUpdateWithoutUlasanInput>
  }

  export type usersUpdateWithoutUlasanInput = {
    nama?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    no_hp?: NullableStringFieldUpdateOperationsInput | string | null
    foto?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    role?: Enumusers_roleFieldUpdateOperationsInput | $Enums.users_role
    status?: Enumusers_statusFieldUpdateOperationsInput | $Enums.users_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    mitra?: MitraUpdateOneWithoutUserNestedInput
    orders?: order_bookingUpdateManyWithoutUserNestedInput
    transaksi?: transaksiUpdateManyWithoutUserNestedInput
    notifikasi?: notifikasiUpdateManyWithoutUserNestedInput
    wallet?: wallet_userUpdateOneWithoutUserNestedInput
    refund?: refundUpdateManyWithoutUserNestedInput
  }

  export type usersUncheckedUpdateWithoutUlasanInput = {
    id?: IntFieldUpdateOperationsInput | number
    nama?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    no_hp?: NullableStringFieldUpdateOperationsInput | string | null
    foto?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    role?: Enumusers_roleFieldUpdateOperationsInput | $Enums.users_role
    status?: Enumusers_statusFieldUpdateOperationsInput | $Enums.users_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    mitra?: MitraUncheckedUpdateOneWithoutUserNestedInput
    orders?: order_bookingUncheckedUpdateManyWithoutUserNestedInput
    transaksi?: transaksiUncheckedUpdateManyWithoutUserNestedInput
    notifikasi?: notifikasiUncheckedUpdateManyWithoutUserNestedInput
    wallet?: wallet_userUncheckedUpdateOneWithoutUserNestedInput
    refund?: refundUncheckedUpdateManyWithoutUserNestedInput
  }

  export type LapanganUpsertWithoutUlasanInput = {
    update: XOR<LapanganUpdateWithoutUlasanInput, LapanganUncheckedUpdateWithoutUlasanInput>
    create: XOR<LapanganCreateWithoutUlasanInput, LapanganUncheckedCreateWithoutUlasanInput>
    where?: LapanganWhereInput
  }

  export type LapanganUpdateToOneWithWhereWithoutUlasanInput = {
    where?: LapanganWhereInput
    data: XOR<LapanganUpdateWithoutUlasanInput, LapanganUncheckedUpdateWithoutUlasanInput>
  }

  export type LapanganUpdateWithoutUlasanInput = {
    nama?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    lokasi?: NullableStringFieldUpdateOperationsInput | string | null
    harga?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    gambar?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: Enumlapangan_statusFieldUpdateOperationsInput | $Enums.lapangan_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    mitra?: MitraUpdateOneRequiredWithoutLapanganNestedInput
    detail?: LapanganDetailUpdateOneWithoutLapanganNestedInput
    gambarList?: LapanganGambarUpdateManyWithoutLapanganNestedInput
    jadwal?: JadwalLapanganUpdateManyWithoutLapanganNestedInput
    orders?: order_bookingUpdateManyWithoutLapanganNestedInput
    transaksi?: transaksiUpdateManyWithoutLapanganNestedInput
  }

  export type LapanganUncheckedUpdateWithoutUlasanInput = {
    id?: IntFieldUpdateOperationsInput | number
    mitra_id?: IntFieldUpdateOperationsInput | number
    nama?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    lokasi?: NullableStringFieldUpdateOperationsInput | string | null
    harga?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    gambar?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: Enumlapangan_statusFieldUpdateOperationsInput | $Enums.lapangan_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    detail?: LapanganDetailUncheckedUpdateOneWithoutLapanganNestedInput
    gambarList?: LapanganGambarUncheckedUpdateManyWithoutLapanganNestedInput
    jadwal?: JadwalLapanganUncheckedUpdateManyWithoutLapanganNestedInput
    orders?: order_bookingUncheckedUpdateManyWithoutLapanganNestedInput
    transaksi?: transaksiUncheckedUpdateManyWithoutLapanganNestedInput
  }

  export type MitraCreateWithoutPendapatanInput = {
    nama_usaha: string
    alamat_usaha: string
    no_ktp: string
    foto_ktp: string
    withdraw_type?: string | null
    withdraw_day?: number | null
    bank_mitra?: string | null
    no_rekening_mitra?: string | null
    status?: $Enums.mitra_status
    created_at?: Date | string
    user: usersCreateNestedOneWithoutMitraInput
    lapangan?: LapanganCreateNestedManyWithoutMitraInput
    pencairan?: pencairan_pendapatanCreateNestedManyWithoutMitraInput
  }

  export type MitraUncheckedCreateWithoutPendapatanInput = {
    id?: number
    userId: number
    nama_usaha: string
    alamat_usaha: string
    no_ktp: string
    foto_ktp: string
    withdraw_type?: string | null
    withdraw_day?: number | null
    bank_mitra?: string | null
    no_rekening_mitra?: string | null
    status?: $Enums.mitra_status
    created_at?: Date | string
    lapangan?: LapanganUncheckedCreateNestedManyWithoutMitraInput
    pencairan?: pencairan_pendapatanUncheckedCreateNestedManyWithoutMitraInput
  }

  export type MitraCreateOrConnectWithoutPendapatanInput = {
    where: MitraWhereUniqueInput
    create: XOR<MitraCreateWithoutPendapatanInput, MitraUncheckedCreateWithoutPendapatanInput>
  }

  export type MitraUpsertWithoutPendapatanInput = {
    update: XOR<MitraUpdateWithoutPendapatanInput, MitraUncheckedUpdateWithoutPendapatanInput>
    create: XOR<MitraCreateWithoutPendapatanInput, MitraUncheckedCreateWithoutPendapatanInput>
    where?: MitraWhereInput
  }

  export type MitraUpdateToOneWithWhereWithoutPendapatanInput = {
    where?: MitraWhereInput
    data: XOR<MitraUpdateWithoutPendapatanInput, MitraUncheckedUpdateWithoutPendapatanInput>
  }

  export type MitraUpdateWithoutPendapatanInput = {
    nama_usaha?: StringFieldUpdateOperationsInput | string
    alamat_usaha?: StringFieldUpdateOperationsInput | string
    no_ktp?: StringFieldUpdateOperationsInput | string
    foto_ktp?: StringFieldUpdateOperationsInput | string
    withdraw_type?: NullableStringFieldUpdateOperationsInput | string | null
    withdraw_day?: NullableIntFieldUpdateOperationsInput | number | null
    bank_mitra?: NullableStringFieldUpdateOperationsInput | string | null
    no_rekening_mitra?: NullableStringFieldUpdateOperationsInput | string | null
    status?: Enummitra_statusFieldUpdateOperationsInput | $Enums.mitra_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: usersUpdateOneRequiredWithoutMitraNestedInput
    lapangan?: LapanganUpdateManyWithoutMitraNestedInput
    pencairan?: pencairan_pendapatanUpdateManyWithoutMitraNestedInput
  }

  export type MitraUncheckedUpdateWithoutPendapatanInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    nama_usaha?: StringFieldUpdateOperationsInput | string
    alamat_usaha?: StringFieldUpdateOperationsInput | string
    no_ktp?: StringFieldUpdateOperationsInput | string
    foto_ktp?: StringFieldUpdateOperationsInput | string
    withdraw_type?: NullableStringFieldUpdateOperationsInput | string | null
    withdraw_day?: NullableIntFieldUpdateOperationsInput | number | null
    bank_mitra?: NullableStringFieldUpdateOperationsInput | string | null
    no_rekening_mitra?: NullableStringFieldUpdateOperationsInput | string | null
    status?: Enummitra_statusFieldUpdateOperationsInput | $Enums.mitra_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    lapangan?: LapanganUncheckedUpdateManyWithoutMitraNestedInput
    pencairan?: pencairan_pendapatanUncheckedUpdateManyWithoutMitraNestedInput
  }

  export type MitraCreateWithoutPencairanInput = {
    nama_usaha: string
    alamat_usaha: string
    no_ktp: string
    foto_ktp: string
    withdraw_type?: string | null
    withdraw_day?: number | null
    bank_mitra?: string | null
    no_rekening_mitra?: string | null
    status?: $Enums.mitra_status
    created_at?: Date | string
    user: usersCreateNestedOneWithoutMitraInput
    lapangan?: LapanganCreateNestedManyWithoutMitraInput
    pendapatan?: pendapatan_mitraCreateNestedManyWithoutMitraInput
  }

  export type MitraUncheckedCreateWithoutPencairanInput = {
    id?: number
    userId: number
    nama_usaha: string
    alamat_usaha: string
    no_ktp: string
    foto_ktp: string
    withdraw_type?: string | null
    withdraw_day?: number | null
    bank_mitra?: string | null
    no_rekening_mitra?: string | null
    status?: $Enums.mitra_status
    created_at?: Date | string
    lapangan?: LapanganUncheckedCreateNestedManyWithoutMitraInput
    pendapatan?: pendapatan_mitraUncheckedCreateNestedManyWithoutMitraInput
  }

  export type MitraCreateOrConnectWithoutPencairanInput = {
    where: MitraWhereUniqueInput
    create: XOR<MitraCreateWithoutPencairanInput, MitraUncheckedCreateWithoutPencairanInput>
  }

  export type MitraUpsertWithoutPencairanInput = {
    update: XOR<MitraUpdateWithoutPencairanInput, MitraUncheckedUpdateWithoutPencairanInput>
    create: XOR<MitraCreateWithoutPencairanInput, MitraUncheckedCreateWithoutPencairanInput>
    where?: MitraWhereInput
  }

  export type MitraUpdateToOneWithWhereWithoutPencairanInput = {
    where?: MitraWhereInput
    data: XOR<MitraUpdateWithoutPencairanInput, MitraUncheckedUpdateWithoutPencairanInput>
  }

  export type MitraUpdateWithoutPencairanInput = {
    nama_usaha?: StringFieldUpdateOperationsInput | string
    alamat_usaha?: StringFieldUpdateOperationsInput | string
    no_ktp?: StringFieldUpdateOperationsInput | string
    foto_ktp?: StringFieldUpdateOperationsInput | string
    withdraw_type?: NullableStringFieldUpdateOperationsInput | string | null
    withdraw_day?: NullableIntFieldUpdateOperationsInput | number | null
    bank_mitra?: NullableStringFieldUpdateOperationsInput | string | null
    no_rekening_mitra?: NullableStringFieldUpdateOperationsInput | string | null
    status?: Enummitra_statusFieldUpdateOperationsInput | $Enums.mitra_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: usersUpdateOneRequiredWithoutMitraNestedInput
    lapangan?: LapanganUpdateManyWithoutMitraNestedInput
    pendapatan?: pendapatan_mitraUpdateManyWithoutMitraNestedInput
  }

  export type MitraUncheckedUpdateWithoutPencairanInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    nama_usaha?: StringFieldUpdateOperationsInput | string
    alamat_usaha?: StringFieldUpdateOperationsInput | string
    no_ktp?: StringFieldUpdateOperationsInput | string
    foto_ktp?: StringFieldUpdateOperationsInput | string
    withdraw_type?: NullableStringFieldUpdateOperationsInput | string | null
    withdraw_day?: NullableIntFieldUpdateOperationsInput | number | null
    bank_mitra?: NullableStringFieldUpdateOperationsInput | string | null
    no_rekening_mitra?: NullableStringFieldUpdateOperationsInput | string | null
    status?: Enummitra_statusFieldUpdateOperationsInput | $Enums.mitra_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    lapangan?: LapanganUncheckedUpdateManyWithoutMitraNestedInput
    pendapatan?: pendapatan_mitraUncheckedUpdateManyWithoutMitraNestedInput
  }

  export type order_bookingCreateManyUserInput = {
    id?: number
    lapangan_id: number
    jadwalLapanganId: number
    tanggal: Date | string
    jam_mulai: string
    jam_selesai: string
    total_harga: Decimal | DecimalJsLike | number | string
    status: string
    sewa_raket?: boolean
    biaya_raket?: number
    created_at?: Date | string
    expired_at?: Date | string | null
  }

  export type transaksiCreateManyUserInput = {
    id?: number
    lapangan_id: number
    jadwal_id: number
    order_id?: number | null
    total_harga: Decimal | DecimalJsLike | number | string
    status_pembayaran?: $Enums.transaksi_status_pembayaran
    created_at?: Date | string
  }

  export type notifikasiCreateManyUserInput = {
    id?: number
    pesan: string
    dibaca?: boolean
    created_at?: Date | string
  }

  export type ulasanCreateManyUserInput = {
    id?: number
    lapangan_id: number
    rating: number
    komentar?: string | null
    created_at?: Date | string
  }

  export type refundCreateManyUserInput = {
    id?: number
    transaksi_id: number
    order_id: number
    jumlah: Decimal | DecimalJsLike | number | string
    alasan?: string | null
    status?: $Enums.refund_status
    created_at?: Date | string
    processed_at?: Date | string | null
  }

  export type order_bookingUpdateWithoutUserInput = {
    tanggal?: DateTimeFieldUpdateOperationsInput | Date | string
    jam_mulai?: StringFieldUpdateOperationsInput | string
    jam_selesai?: StringFieldUpdateOperationsInput | string
    total_harga?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    sewa_raket?: BoolFieldUpdateOperationsInput | boolean
    biaya_raket?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    expired_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lapangan?: LapanganUpdateOneRequiredWithoutOrdersNestedInput
    jadwalLapangan?: JadwalLapanganUpdateOneRequiredWithoutOrdersNestedInput
    transaksi?: transaksiUpdateOneWithoutOrderNestedInput
    refund?: refundUpdateOneWithoutOrderNestedInput
    wallet_histories?: wallet_historyUpdateManyWithoutOrderNestedInput
  }

  export type order_bookingUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    lapangan_id?: IntFieldUpdateOperationsInput | number
    jadwalLapanganId?: IntFieldUpdateOperationsInput | number
    tanggal?: DateTimeFieldUpdateOperationsInput | Date | string
    jam_mulai?: StringFieldUpdateOperationsInput | string
    jam_selesai?: StringFieldUpdateOperationsInput | string
    total_harga?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    sewa_raket?: BoolFieldUpdateOperationsInput | boolean
    biaya_raket?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    expired_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transaksi?: transaksiUncheckedUpdateOneWithoutOrderNestedInput
    refund?: refundUncheckedUpdateOneWithoutOrderNestedInput
    wallet_histories?: wallet_historyUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type order_bookingUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    lapangan_id?: IntFieldUpdateOperationsInput | number
    jadwalLapanganId?: IntFieldUpdateOperationsInput | number
    tanggal?: DateTimeFieldUpdateOperationsInput | Date | string
    jam_mulai?: StringFieldUpdateOperationsInput | string
    jam_selesai?: StringFieldUpdateOperationsInput | string
    total_harga?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    sewa_raket?: BoolFieldUpdateOperationsInput | boolean
    biaya_raket?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    expired_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type transaksiUpdateWithoutUserInput = {
    total_harga?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status_pembayaran?: Enumtransaksi_status_pembayaranFieldUpdateOperationsInput | $Enums.transaksi_status_pembayaran
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    lapangan?: LapanganUpdateOneRequiredWithoutTransaksiNestedInput
    jadwal?: JadwalLapanganUpdateOneRequiredWithoutTransaksiNestedInput
    order?: order_bookingUpdateOneWithoutTransaksiNestedInput
    refund?: refundUpdateOneWithoutTransaksiNestedInput
    sewa_raket?: sewa_raketUpdateManyWithoutTransaksiNestedInput
  }

  export type transaksiUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    lapangan_id?: IntFieldUpdateOperationsInput | number
    jadwal_id?: IntFieldUpdateOperationsInput | number
    order_id?: NullableIntFieldUpdateOperationsInput | number | null
    total_harga?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status_pembayaran?: Enumtransaksi_status_pembayaranFieldUpdateOperationsInput | $Enums.transaksi_status_pembayaran
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    refund?: refundUncheckedUpdateOneWithoutTransaksiNestedInput
    sewa_raket?: sewa_raketUncheckedUpdateManyWithoutTransaksiNestedInput
  }

  export type transaksiUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    lapangan_id?: IntFieldUpdateOperationsInput | number
    jadwal_id?: IntFieldUpdateOperationsInput | number
    order_id?: NullableIntFieldUpdateOperationsInput | number | null
    total_harga?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status_pembayaran?: Enumtransaksi_status_pembayaranFieldUpdateOperationsInput | $Enums.transaksi_status_pembayaran
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type notifikasiUpdateWithoutUserInput = {
    pesan?: StringFieldUpdateOperationsInput | string
    dibaca?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type notifikasiUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    pesan?: StringFieldUpdateOperationsInput | string
    dibaca?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type notifikasiUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    pesan?: StringFieldUpdateOperationsInput | string
    dibaca?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ulasanUpdateWithoutUserInput = {
    rating?: IntFieldUpdateOperationsInput | number
    komentar?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    lapangan?: LapanganUpdateOneRequiredWithoutUlasanNestedInput
  }

  export type ulasanUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    lapangan_id?: IntFieldUpdateOperationsInput | number
    rating?: IntFieldUpdateOperationsInput | number
    komentar?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ulasanUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    lapangan_id?: IntFieldUpdateOperationsInput | number
    rating?: IntFieldUpdateOperationsInput | number
    komentar?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type refundUpdateWithoutUserInput = {
    jumlah?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    alasan?: NullableStringFieldUpdateOperationsInput | string | null
    status?: Enumrefund_statusFieldUpdateOperationsInput | $Enums.refund_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    processed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transaksi?: transaksiUpdateOneRequiredWithoutRefundNestedInput
    order?: order_bookingUpdateOneRequiredWithoutRefundNestedInput
  }

  export type refundUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    transaksi_id?: IntFieldUpdateOperationsInput | number
    order_id?: IntFieldUpdateOperationsInput | number
    jumlah?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    alasan?: NullableStringFieldUpdateOperationsInput | string | null
    status?: Enumrefund_statusFieldUpdateOperationsInput | $Enums.refund_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    processed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type refundUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    transaksi_id?: IntFieldUpdateOperationsInput | number
    order_id?: IntFieldUpdateOperationsInput | number
    jumlah?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    alasan?: NullableStringFieldUpdateOperationsInput | string | null
    status?: Enumrefund_statusFieldUpdateOperationsInput | $Enums.refund_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    processed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LapanganCreateManyMitraInput = {
    id?: number
    nama: string
    slug: string
    lokasi?: string | null
    harga: Decimal | DecimalJsLike | number | string
    gambar?: string | null
    rating?: number | null
    status?: $Enums.lapangan_status
    created_at?: Date | string
  }

  export type pendapatan_mitraCreateManyMitraInput = {
    id?: number
    transaksi_id: number
    jumlah: Decimal | DecimalJsLike | number | string
    created_at?: Date | string
  }

  export type pencairan_pendapatanCreateManyMitraInput = {
    id?: number
    jumlah: Decimal | DecimalJsLike | number | string
    status?: $Enums.pencairan_status
    created_at?: Date | string
  }

  export type LapanganUpdateWithoutMitraInput = {
    nama?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    lokasi?: NullableStringFieldUpdateOperationsInput | string | null
    harga?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    gambar?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: Enumlapangan_statusFieldUpdateOperationsInput | $Enums.lapangan_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    detail?: LapanganDetailUpdateOneWithoutLapanganNestedInput
    gambarList?: LapanganGambarUpdateManyWithoutLapanganNestedInput
    jadwal?: JadwalLapanganUpdateManyWithoutLapanganNestedInput
    orders?: order_bookingUpdateManyWithoutLapanganNestedInput
    transaksi?: transaksiUpdateManyWithoutLapanganNestedInput
    ulasan?: ulasanUpdateManyWithoutLapanganNestedInput
  }

  export type LapanganUncheckedUpdateWithoutMitraInput = {
    id?: IntFieldUpdateOperationsInput | number
    nama?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    lokasi?: NullableStringFieldUpdateOperationsInput | string | null
    harga?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    gambar?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: Enumlapangan_statusFieldUpdateOperationsInput | $Enums.lapangan_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    detail?: LapanganDetailUncheckedUpdateOneWithoutLapanganNestedInput
    gambarList?: LapanganGambarUncheckedUpdateManyWithoutLapanganNestedInput
    jadwal?: JadwalLapanganUncheckedUpdateManyWithoutLapanganNestedInput
    orders?: order_bookingUncheckedUpdateManyWithoutLapanganNestedInput
    transaksi?: transaksiUncheckedUpdateManyWithoutLapanganNestedInput
    ulasan?: ulasanUncheckedUpdateManyWithoutLapanganNestedInput
  }

  export type LapanganUncheckedUpdateManyWithoutMitraInput = {
    id?: IntFieldUpdateOperationsInput | number
    nama?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    lokasi?: NullableStringFieldUpdateOperationsInput | string | null
    harga?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    gambar?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: Enumlapangan_statusFieldUpdateOperationsInput | $Enums.lapangan_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type pendapatan_mitraUpdateWithoutMitraInput = {
    transaksi_id?: IntFieldUpdateOperationsInput | number
    jumlah?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type pendapatan_mitraUncheckedUpdateWithoutMitraInput = {
    id?: IntFieldUpdateOperationsInput | number
    transaksi_id?: IntFieldUpdateOperationsInput | number
    jumlah?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type pendapatan_mitraUncheckedUpdateManyWithoutMitraInput = {
    id?: IntFieldUpdateOperationsInput | number
    transaksi_id?: IntFieldUpdateOperationsInput | number
    jumlah?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type pencairan_pendapatanUpdateWithoutMitraInput = {
    jumlah?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: Enumpencairan_statusFieldUpdateOperationsInput | $Enums.pencairan_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type pencairan_pendapatanUncheckedUpdateWithoutMitraInput = {
    id?: IntFieldUpdateOperationsInput | number
    jumlah?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: Enumpencairan_statusFieldUpdateOperationsInput | $Enums.pencairan_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type pencairan_pendapatanUncheckedUpdateManyWithoutMitraInput = {
    id?: IntFieldUpdateOperationsInput | number
    jumlah?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: Enumpencairan_statusFieldUpdateOperationsInput | $Enums.pencairan_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LapanganGambarCreateManyLapanganInput = {
    id?: number
    file_name: string
    created_at?: Date | string
  }

  export type JadwalLapanganCreateManyLapanganInput = {
    id?: number
    tanggal: Date | string
    slot: string
    status?: $Enums.jadwal_status
    locked_until?: Date | string | null
  }

  export type order_bookingCreateManyLapanganInput = {
    id?: number
    user_id: number
    jadwalLapanganId: number
    tanggal: Date | string
    jam_mulai: string
    jam_selesai: string
    total_harga: Decimal | DecimalJsLike | number | string
    status: string
    sewa_raket?: boolean
    biaya_raket?: number
    created_at?: Date | string
    expired_at?: Date | string | null
  }

  export type transaksiCreateManyLapanganInput = {
    id?: number
    user_id: number
    jadwal_id: number
    order_id?: number | null
    total_harga: Decimal | DecimalJsLike | number | string
    status_pembayaran?: $Enums.transaksi_status_pembayaran
    created_at?: Date | string
  }

  export type ulasanCreateManyLapanganInput = {
    id?: number
    user_id: number
    rating: number
    komentar?: string | null
    created_at?: Date | string
  }

  export type LapanganGambarUpdateWithoutLapanganInput = {
    file_name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LapanganGambarUncheckedUpdateWithoutLapanganInput = {
    id?: IntFieldUpdateOperationsInput | number
    file_name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LapanganGambarUncheckedUpdateManyWithoutLapanganInput = {
    id?: IntFieldUpdateOperationsInput | number
    file_name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JadwalLapanganUpdateWithoutLapanganInput = {
    tanggal?: DateTimeFieldUpdateOperationsInput | Date | string
    slot?: StringFieldUpdateOperationsInput | string
    status?: Enumjadwal_statusFieldUpdateOperationsInput | $Enums.jadwal_status
    locked_until?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    orders?: order_bookingUpdateManyWithoutJadwalLapanganNestedInput
    transaksi?: transaksiUpdateManyWithoutJadwalNestedInput
  }

  export type JadwalLapanganUncheckedUpdateWithoutLapanganInput = {
    id?: IntFieldUpdateOperationsInput | number
    tanggal?: DateTimeFieldUpdateOperationsInput | Date | string
    slot?: StringFieldUpdateOperationsInput | string
    status?: Enumjadwal_statusFieldUpdateOperationsInput | $Enums.jadwal_status
    locked_until?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    orders?: order_bookingUncheckedUpdateManyWithoutJadwalLapanganNestedInput
    transaksi?: transaksiUncheckedUpdateManyWithoutJadwalNestedInput
  }

  export type JadwalLapanganUncheckedUpdateManyWithoutLapanganInput = {
    id?: IntFieldUpdateOperationsInput | number
    tanggal?: DateTimeFieldUpdateOperationsInput | Date | string
    slot?: StringFieldUpdateOperationsInput | string
    status?: Enumjadwal_statusFieldUpdateOperationsInput | $Enums.jadwal_status
    locked_until?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type order_bookingUpdateWithoutLapanganInput = {
    tanggal?: DateTimeFieldUpdateOperationsInput | Date | string
    jam_mulai?: StringFieldUpdateOperationsInput | string
    jam_selesai?: StringFieldUpdateOperationsInput | string
    total_harga?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    sewa_raket?: BoolFieldUpdateOperationsInput | boolean
    biaya_raket?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    expired_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: usersUpdateOneRequiredWithoutOrdersNestedInput
    jadwalLapangan?: JadwalLapanganUpdateOneRequiredWithoutOrdersNestedInput
    transaksi?: transaksiUpdateOneWithoutOrderNestedInput
    refund?: refundUpdateOneWithoutOrderNestedInput
    wallet_histories?: wallet_historyUpdateManyWithoutOrderNestedInput
  }

  export type order_bookingUncheckedUpdateWithoutLapanganInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    jadwalLapanganId?: IntFieldUpdateOperationsInput | number
    tanggal?: DateTimeFieldUpdateOperationsInput | Date | string
    jam_mulai?: StringFieldUpdateOperationsInput | string
    jam_selesai?: StringFieldUpdateOperationsInput | string
    total_harga?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    sewa_raket?: BoolFieldUpdateOperationsInput | boolean
    biaya_raket?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    expired_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transaksi?: transaksiUncheckedUpdateOneWithoutOrderNestedInput
    refund?: refundUncheckedUpdateOneWithoutOrderNestedInput
    wallet_histories?: wallet_historyUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type order_bookingUncheckedUpdateManyWithoutLapanganInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    jadwalLapanganId?: IntFieldUpdateOperationsInput | number
    tanggal?: DateTimeFieldUpdateOperationsInput | Date | string
    jam_mulai?: StringFieldUpdateOperationsInput | string
    jam_selesai?: StringFieldUpdateOperationsInput | string
    total_harga?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    sewa_raket?: BoolFieldUpdateOperationsInput | boolean
    biaya_raket?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    expired_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type transaksiUpdateWithoutLapanganInput = {
    total_harga?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status_pembayaran?: Enumtransaksi_status_pembayaranFieldUpdateOperationsInput | $Enums.transaksi_status_pembayaran
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: usersUpdateOneRequiredWithoutTransaksiNestedInput
    jadwal?: JadwalLapanganUpdateOneRequiredWithoutTransaksiNestedInput
    order?: order_bookingUpdateOneWithoutTransaksiNestedInput
    refund?: refundUpdateOneWithoutTransaksiNestedInput
    sewa_raket?: sewa_raketUpdateManyWithoutTransaksiNestedInput
  }

  export type transaksiUncheckedUpdateWithoutLapanganInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    jadwal_id?: IntFieldUpdateOperationsInput | number
    order_id?: NullableIntFieldUpdateOperationsInput | number | null
    total_harga?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status_pembayaran?: Enumtransaksi_status_pembayaranFieldUpdateOperationsInput | $Enums.transaksi_status_pembayaran
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    refund?: refundUncheckedUpdateOneWithoutTransaksiNestedInput
    sewa_raket?: sewa_raketUncheckedUpdateManyWithoutTransaksiNestedInput
  }

  export type transaksiUncheckedUpdateManyWithoutLapanganInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    jadwal_id?: IntFieldUpdateOperationsInput | number
    order_id?: NullableIntFieldUpdateOperationsInput | number | null
    total_harga?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status_pembayaran?: Enumtransaksi_status_pembayaranFieldUpdateOperationsInput | $Enums.transaksi_status_pembayaran
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ulasanUpdateWithoutLapanganInput = {
    rating?: IntFieldUpdateOperationsInput | number
    komentar?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: usersUpdateOneRequiredWithoutUlasanNestedInput
  }

  export type ulasanUncheckedUpdateWithoutLapanganInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    rating?: IntFieldUpdateOperationsInput | number
    komentar?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ulasanUncheckedUpdateManyWithoutLapanganInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    rating?: IntFieldUpdateOperationsInput | number
    komentar?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type order_bookingCreateManyJadwalLapanganInput = {
    id?: number
    user_id: number
    lapangan_id: number
    tanggal: Date | string
    jam_mulai: string
    jam_selesai: string
    total_harga: Decimal | DecimalJsLike | number | string
    status: string
    sewa_raket?: boolean
    biaya_raket?: number
    created_at?: Date | string
    expired_at?: Date | string | null
  }

  export type transaksiCreateManyJadwalInput = {
    id?: number
    user_id: number
    lapangan_id: number
    order_id?: number | null
    total_harga: Decimal | DecimalJsLike | number | string
    status_pembayaran?: $Enums.transaksi_status_pembayaran
    created_at?: Date | string
  }

  export type order_bookingUpdateWithoutJadwalLapanganInput = {
    tanggal?: DateTimeFieldUpdateOperationsInput | Date | string
    jam_mulai?: StringFieldUpdateOperationsInput | string
    jam_selesai?: StringFieldUpdateOperationsInput | string
    total_harga?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    sewa_raket?: BoolFieldUpdateOperationsInput | boolean
    biaya_raket?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    expired_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: usersUpdateOneRequiredWithoutOrdersNestedInput
    lapangan?: LapanganUpdateOneRequiredWithoutOrdersNestedInput
    transaksi?: transaksiUpdateOneWithoutOrderNestedInput
    refund?: refundUpdateOneWithoutOrderNestedInput
    wallet_histories?: wallet_historyUpdateManyWithoutOrderNestedInput
  }

  export type order_bookingUncheckedUpdateWithoutJadwalLapanganInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    lapangan_id?: IntFieldUpdateOperationsInput | number
    tanggal?: DateTimeFieldUpdateOperationsInput | Date | string
    jam_mulai?: StringFieldUpdateOperationsInput | string
    jam_selesai?: StringFieldUpdateOperationsInput | string
    total_harga?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    sewa_raket?: BoolFieldUpdateOperationsInput | boolean
    biaya_raket?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    expired_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transaksi?: transaksiUncheckedUpdateOneWithoutOrderNestedInput
    refund?: refundUncheckedUpdateOneWithoutOrderNestedInput
    wallet_histories?: wallet_historyUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type order_bookingUncheckedUpdateManyWithoutJadwalLapanganInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    lapangan_id?: IntFieldUpdateOperationsInput | number
    tanggal?: DateTimeFieldUpdateOperationsInput | Date | string
    jam_mulai?: StringFieldUpdateOperationsInput | string
    jam_selesai?: StringFieldUpdateOperationsInput | string
    total_harga?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    sewa_raket?: BoolFieldUpdateOperationsInput | boolean
    biaya_raket?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    expired_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type transaksiUpdateWithoutJadwalInput = {
    total_harga?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status_pembayaran?: Enumtransaksi_status_pembayaranFieldUpdateOperationsInput | $Enums.transaksi_status_pembayaran
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: usersUpdateOneRequiredWithoutTransaksiNestedInput
    lapangan?: LapanganUpdateOneRequiredWithoutTransaksiNestedInput
    order?: order_bookingUpdateOneWithoutTransaksiNestedInput
    refund?: refundUpdateOneWithoutTransaksiNestedInput
    sewa_raket?: sewa_raketUpdateManyWithoutTransaksiNestedInput
  }

  export type transaksiUncheckedUpdateWithoutJadwalInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    lapangan_id?: IntFieldUpdateOperationsInput | number
    order_id?: NullableIntFieldUpdateOperationsInput | number | null
    total_harga?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status_pembayaran?: Enumtransaksi_status_pembayaranFieldUpdateOperationsInput | $Enums.transaksi_status_pembayaran
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    refund?: refundUncheckedUpdateOneWithoutTransaksiNestedInput
    sewa_raket?: sewa_raketUncheckedUpdateManyWithoutTransaksiNestedInput
  }

  export type transaksiUncheckedUpdateManyWithoutJadwalInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    lapangan_id?: IntFieldUpdateOperationsInput | number
    order_id?: NullableIntFieldUpdateOperationsInput | number | null
    total_harga?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status_pembayaran?: Enumtransaksi_status_pembayaranFieldUpdateOperationsInput | $Enums.transaksi_status_pembayaran
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type wallet_historyCreateManyOrderInput = {
    id?: number
    wallet_id: number
    jumlah: number
    saldo_akhir: number
    tipe: $Enums.wallet_tipe
    transaksi_id?: number | null
    created_at?: Date | string
  }

  export type wallet_historyUpdateWithoutOrderInput = {
    jumlah?: IntFieldUpdateOperationsInput | number
    saldo_akhir?: IntFieldUpdateOperationsInput | number
    tipe?: Enumwallet_tipeFieldUpdateOperationsInput | $Enums.wallet_tipe
    transaksi_id?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    wallet?: wallet_userUpdateOneRequiredWithoutHistoryNestedInput
  }

  export type wallet_historyUncheckedUpdateWithoutOrderInput = {
    id?: IntFieldUpdateOperationsInput | number
    wallet_id?: IntFieldUpdateOperationsInput | number
    jumlah?: IntFieldUpdateOperationsInput | number
    saldo_akhir?: IntFieldUpdateOperationsInput | number
    tipe?: Enumwallet_tipeFieldUpdateOperationsInput | $Enums.wallet_tipe
    transaksi_id?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type wallet_historyUncheckedUpdateManyWithoutOrderInput = {
    id?: IntFieldUpdateOperationsInput | number
    wallet_id?: IntFieldUpdateOperationsInput | number
    jumlah?: IntFieldUpdateOperationsInput | number
    saldo_akhir?: IntFieldUpdateOperationsInput | number
    tipe?: Enumwallet_tipeFieldUpdateOperationsInput | $Enums.wallet_tipe
    transaksi_id?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type sewa_raketCreateManyTransaksiInput = {
    id?: number
    raket_id: number
    jumlah: number
    total_harga: Decimal | DecimalJsLike | number | string
  }

  export type sewa_raketUpdateWithoutTransaksiInput = {
    jumlah?: IntFieldUpdateOperationsInput | number
    total_harga?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    raket?: raket_padelUpdateOneRequiredWithoutSewa_raketNestedInput
  }

  export type sewa_raketUncheckedUpdateWithoutTransaksiInput = {
    id?: IntFieldUpdateOperationsInput | number
    raket_id?: IntFieldUpdateOperationsInput | number
    jumlah?: IntFieldUpdateOperationsInput | number
    total_harga?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type sewa_raketUncheckedUpdateManyWithoutTransaksiInput = {
    id?: IntFieldUpdateOperationsInput | number
    raket_id?: IntFieldUpdateOperationsInput | number
    jumlah?: IntFieldUpdateOperationsInput | number
    total_harga?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type sewa_raketCreateManyRaketInput = {
    id?: number
    transaksi_id: number
    jumlah: number
    total_harga: Decimal | DecimalJsLike | number | string
  }

  export type sewa_raketUpdateWithoutRaketInput = {
    jumlah?: IntFieldUpdateOperationsInput | number
    total_harga?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    transaksi?: transaksiUpdateOneRequiredWithoutSewa_raketNestedInput
  }

  export type sewa_raketUncheckedUpdateWithoutRaketInput = {
    id?: IntFieldUpdateOperationsInput | number
    transaksi_id?: IntFieldUpdateOperationsInput | number
    jumlah?: IntFieldUpdateOperationsInput | number
    total_harga?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type sewa_raketUncheckedUpdateManyWithoutRaketInput = {
    id?: IntFieldUpdateOperationsInput | number
    transaksi_id?: IntFieldUpdateOperationsInput | number
    jumlah?: IntFieldUpdateOperationsInput | number
    total_harga?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type wallet_historyCreateManyWalletInput = {
    id?: number
    jumlah: number
    saldo_akhir: number
    tipe: $Enums.wallet_tipe
    transaksi_id?: number | null
    order_id?: number | null
    created_at?: Date | string
  }

  export type wallet_historyUpdateWithoutWalletInput = {
    jumlah?: IntFieldUpdateOperationsInput | number
    saldo_akhir?: IntFieldUpdateOperationsInput | number
    tipe?: Enumwallet_tipeFieldUpdateOperationsInput | $Enums.wallet_tipe
    transaksi_id?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: order_bookingUpdateOneWithoutWallet_historiesNestedInput
  }

  export type wallet_historyUncheckedUpdateWithoutWalletInput = {
    id?: IntFieldUpdateOperationsInput | number
    jumlah?: IntFieldUpdateOperationsInput | number
    saldo_akhir?: IntFieldUpdateOperationsInput | number
    tipe?: Enumwallet_tipeFieldUpdateOperationsInput | $Enums.wallet_tipe
    transaksi_id?: NullableIntFieldUpdateOperationsInput | number | null
    order_id?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type wallet_historyUncheckedUpdateManyWithoutWalletInput = {
    id?: IntFieldUpdateOperationsInput | number
    jumlah?: IntFieldUpdateOperationsInput | number
    saldo_akhir?: IntFieldUpdateOperationsInput | number
    tipe?: Enumwallet_tipeFieldUpdateOperationsInput | $Enums.wallet_tipe
    transaksi_id?: NullableIntFieldUpdateOperationsInput | number | null
    order_id?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use UsersCountOutputTypeDefaultArgs instead
     */
    export type UsersCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UsersCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MitraCountOutputTypeDefaultArgs instead
     */
    export type MitraCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MitraCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LapanganCountOutputTypeDefaultArgs instead
     */
    export type LapanganCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LapanganCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use JadwalLapanganCountOutputTypeDefaultArgs instead
     */
    export type JadwalLapanganCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = JadwalLapanganCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use Order_bookingCountOutputTypeDefaultArgs instead
     */
    export type Order_bookingCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Order_bookingCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TransaksiCountOutputTypeDefaultArgs instead
     */
    export type TransaksiCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TransaksiCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use Raket_padelCountOutputTypeDefaultArgs instead
     */
    export type Raket_padelCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Raket_padelCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use Wallet_userCountOutputTypeDefaultArgs instead
     */
    export type Wallet_userCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Wallet_userCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use usersDefaultArgs instead
     */
    export type usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = usersDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MitraDefaultArgs instead
     */
    export type MitraArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MitraDefaultArgs<ExtArgs>
    /**
     * @deprecated Use otp_codesDefaultArgs instead
     */
    export type otp_codesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = otp_codesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LapanganDefaultArgs instead
     */
    export type LapanganArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LapanganDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LapanganDetailDefaultArgs instead
     */
    export type LapanganDetailArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LapanganDetailDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LapanganGambarDefaultArgs instead
     */
    export type LapanganGambarArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LapanganGambarDefaultArgs<ExtArgs>
    /**
     * @deprecated Use JadwalLapanganDefaultArgs instead
     */
    export type JadwalLapanganArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = JadwalLapanganDefaultArgs<ExtArgs>
    /**
     * @deprecated Use order_bookingDefaultArgs instead
     */
    export type order_bookingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = order_bookingDefaultArgs<ExtArgs>
    /**
     * @deprecated Use transaksiDefaultArgs instead
     */
    export type transaksiArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = transaksiDefaultArgs<ExtArgs>
    /**
     * @deprecated Use raket_padelDefaultArgs instead
     */
    export type raket_padelArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = raket_padelDefaultArgs<ExtArgs>
    /**
     * @deprecated Use sewa_raketDefaultArgs instead
     */
    export type sewa_raketArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = sewa_raketDefaultArgs<ExtArgs>
    /**
     * @deprecated Use wallet_userDefaultArgs instead
     */
    export type wallet_userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = wallet_userDefaultArgs<ExtArgs>
    /**
     * @deprecated Use wallet_historyDefaultArgs instead
     */
    export type wallet_historyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = wallet_historyDefaultArgs<ExtArgs>
    /**
     * @deprecated Use refundDefaultArgs instead
     */
    export type refundArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = refundDefaultArgs<ExtArgs>
    /**
     * @deprecated Use notifikasiDefaultArgs instead
     */
    export type notifikasiArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = notifikasiDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ulasanDefaultArgs instead
     */
    export type ulasanArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ulasanDefaultArgs<ExtArgs>
    /**
     * @deprecated Use pendapatan_mitraDefaultArgs instead
     */
    export type pendapatan_mitraArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = pendapatan_mitraDefaultArgs<ExtArgs>
    /**
     * @deprecated Use pencairan_pendapatanDefaultArgs instead
     */
    export type pencairan_pendapatanArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = pencairan_pendapatanDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}